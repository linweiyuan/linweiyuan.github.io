{"meta":{"title":"林伟源的技术博客","subtitle":null,"description":null,"author":"林伟源","url":"https://linweiyuan.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-05-20T01:12:21.112Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"about/index.html","permalink":"https://linweiyuan.github.io/about/index.html","excerpt":"","text":"姓名：林伟源 邮箱：&#114;&#111;&#111;&#x74;&#64;&#108;&#105;&#110;&#x77;&#101;&#105;&#121;&#x75;&#x61;&#110;&#46;&#99;&#111;&#x6d;"},{"title":"分类","date":"2023-05-20T01:12:21.112Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"categories/index.html","permalink":"https://linweiyuan.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2023-05-20T01:12:21.112Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"links/index.html","permalink":"https://linweiyuan.github.io/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2023-05-20T01:12:21.112Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"repository/index.html","permalink":"https://linweiyuan.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-05-20T01:12:21.112Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"tags/index.html","permalink":"https://linweiyuan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LMMS-One Summer's Day","slug":"LMMS-One-Summer-s-Day","date":"2023-05-12T17:34:52.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2023/05/12/LMMS-One-Summer-s-Day.html","link":"","permalink":"https://linweiyuan.github.io/2023/05/12/LMMS-One-Summer-s-Day.html","excerpt":"","text":"const videojsidda350850e9de443dbb9036cc5e3bce68 = videojs('videojs-id-da350850-e9de-443d-bb90-36cc5e3bce68', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/categories/LMMS/"}],"tags":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/tags/LMMS/"},{"name":"千与千寻","slug":"千与千寻","permalink":"https://linweiyuan.github.io/tags/%E5%8D%83%E4%B8%8E%E5%8D%83%E5%AF%BB/"},{"name":"One Summer's Day","slug":"One-Summer-s-Day","permalink":"https://linweiyuan.github.io/tags/One-Summer-s-Day/"}]},{"title":"LMMS-Always With Me","slug":"LMMS-Always-With-Me","date":"2023-05-12T05:40:18.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2023/05/12/LMMS-Always-With-Me.html","link":"","permalink":"https://linweiyuan.github.io/2023/05/12/LMMS-Always-With-Me.html","excerpt":"","text":"const videojsid0b04dc7668f5457abd37459a49f244a5 = videojs('videojs-id-0b04dc76-68f5-457a-bd37-459a49f244a5', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/categories/LMMS/"}],"tags":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/tags/LMMS/"},{"name":"Always With Me","slug":"Always-With-Me","permalink":"https://linweiyuan.github.io/tags/Always-With-Me/"},{"name":"千与千寻","slug":"千与千寻","permalink":"https://linweiyuan.github.io/tags/%E5%8D%83%E4%B8%8E%E5%8D%83%E5%AF%BB/"}]},{"title":"LMMS-一百万个可能","slug":"LMMS-一百万个可能","date":"2023-05-10T17:42:20.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2023/05/10/LMMS-一百万个可能.html","link":"","permalink":"https://linweiyuan.github.io/2023/05/10/LMMS-%E4%B8%80%E7%99%BE%E4%B8%87%E4%B8%AA%E5%8F%AF%E8%83%BD.html","excerpt":"","text":"const videojsidf09269fa8e18464ab1b20019b3c862e2 = videojs('videojs-id-f09269fa-8e18-464a-b1b2-0019b3c862e2', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/categories/LMMS/"}],"tags":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/tags/LMMS/"},{"name":"一百万个可能","slug":"一百万个可能","permalink":"https://linweiyuan.github.io/tags/%E4%B8%80%E7%99%BE%E4%B8%87%E4%B8%AA%E5%8F%AF%E8%83%BD/"}]},{"title":"LMMS-孤勇者","slug":"LMMS-孤勇者","date":"2023-05-08T16:41:25.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2023/05/08/LMMS-孤勇者.html","link":"","permalink":"https://linweiyuan.github.io/2023/05/08/LMMS-%E5%AD%A4%E5%8B%87%E8%80%85.html","excerpt":"","text":"const videojsid76693a6ca70949fba0dd3cceb991a605 = videojs('videojs-id-76693a6c-a709-49fb-a0dd-3cceb991a605', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/categories/LMMS/"}],"tags":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/tags/LMMS/"},{"name":"孤勇者","slug":"孤勇者","permalink":"https://linweiyuan.github.io/tags/%E5%AD%A4%E5%8B%87%E8%80%85/"}]},{"title":"LMMS-夜的钢琴曲五","slug":"LMMS-夜的钢琴曲五","date":"2023-05-06T16:10:14.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2023/05/06/LMMS-夜的钢琴曲五.html","link":"","permalink":"https://linweiyuan.github.io/2023/05/06/LMMS-%E5%A4%9C%E7%9A%84%E9%92%A2%E7%90%B4%E6%9B%B2%E4%BA%94.html","excerpt":"","text":"const videojsidc9c35650357e4dd1bd1d2304f7928581 = videojs('videojs-id-c9c35650-357e-4dd1-bd1d-2304f7928581', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/categories/LMMS/"}],"tags":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/tags/LMMS/"},{"name":"夜的钢琴曲","slug":"夜的钢琴曲","permalink":"https://linweiyuan.github.io/tags/%E5%A4%9C%E7%9A%84%E9%92%A2%E7%90%B4%E6%9B%B2/"}]},{"title":"新版本 go-chatgpt-api","slug":"新版本-go-chatgpt-api","date":"2023-05-03T03:12:06.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2023/05/03/新版本-go-chatgpt-api.html","link":"","permalink":"https://linweiyuan.github.io/2023/05/03/%E6%96%B0%E7%89%88%E6%9C%AC-go-chatgpt-api.html","excerpt":"","text":"经过一段时间的迭代和测试，目前新版本 go-chatgpt-api 貌似变得越来越稳定了，但是控制权还是在 ChatGPT 手上，如果官方要改接口或者随随便便加验证导致本项目失效，是轻而易举的，但是还是那句话，失效会尝试更新 java-chatgpt-api 的话，目前还能用，但是后续一般不会再更新了，资源占用多，镜像下载量没有 go-chatgpt-api 十分之一，被我抛弃了 详细的介绍在 README 和视频中，就不再多说了 视频 const videojsidbcaa8d5df5f7408b8e3eb32fa7e3a003 = videojs('videojs-id-bcaa8d5d-f5f7-408b-8e3e-b32fa7e3a003', { html5: { hls: { overrideNative: true } } }); 服务器被攻击 const videojsid26c78c173ae34d9cac2aa71e95121561 = videojs('videojs-id-26c78c17-3ae3-4d9c-ac2a-a71e95121561', { html5: { hls: { overrideNative: true } } }); 第二天看一下比昨天还多了一倍流量，一天的入站流量比一个月的还多… 我域名本来 DNS 解析在阿里云，今天换到了 Cloudflare，换了台服务器，隐藏了源站 IP，开启了 DDoS 防护，配置了 WAF，然后重新上线了 API 通过这次教训，我深刻明白到互联网上永远不要对陌生人存有善意 无所谓，我会出手脚本小子罢了","categories":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/categories/ChatGPT/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/tags/ChatGPT/"}]},{"title":"一种解决 ChatGPT Access denied 的方法","slug":"一种解决-ChatGPT-Access-denied-的方法","date":"2023-04-15T05:42:08.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2023/04/15/一种解决-ChatGPT-Access-denied-的方法.html","link":"","permalink":"https://linweiyuan.github.io/2023/04/15/%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3-ChatGPT-Access-denied-%E7%9A%84%E6%96%B9%E6%B3%95.html","excerpt":"","text":"ChatGPT 封禁了一堆 VPS 供应商，我自己用的 Vultr 也很早就 Access denied 看到网上有绕过的方法，不过里面牵涉到很多计算机网络的东西，好多知识我已经忘了，所以在这里没办法解释太多，因为我也不懂 按照通俗易懂的说法就是利用 Cloudflare WARP 客户端，来实现一个伪装 比如我自己的服务器，开启前 curl -x ipinfo.io： 123456789101112&#123; &quot;ip&quot;: &quot;149.28.197.45&quot;, &quot;hostname&quot;: &quot;149.28.197.45.vultrusercontent.com&quot;, &quot;city&quot;: &quot;Santa Clara&quot;, &quot;region&quot;: &quot;California&quot;, &quot;country&quot;: &quot;US&quot;, &quot;loc&quot;: &quot;37.3924,-121.9623&quot;, &quot;org&quot;: &quot;AS20473 The Constant Company, LLC&quot;, &quot;postal&quot;: &quot;95054&quot;, &quot;timezone&quot;: &quot;America/Los_Angeles&quot;, &quot;readme&quot;: &quot;https://ipinfo.io/missingauth&quot;&#125; （这服务器没啥东西） 开启后 curl -x socks5://127.0.0.1:40000 ipinfo.io： 1234567891011&#123; &quot;ip&quot;: &quot;104.28.201.74&quot;, &quot;city&quot;: &quot;San Jose&quot;, &quot;region&quot;: &quot;California&quot;, &quot;country&quot;: &quot;US&quot;, &quot;loc&quot;: &quot;37.3394,-121.8950&quot;, &quot;org&quot;: &quot;AS13335 Cloudflare, Inc.&quot;, &quot;postal&quot;: &quot;95103&quot;, &quot;timezone&quot;: &quot;America/Los_Angeles&quot;, &quot;readme&quot;: &quot;https://ipinfo.io/missingauth&quot;&#125; 看 org，其实是 Cloudflare 了 于是从实用的角度打包了另一个辅助的镜像 chatgpt-proxy-server-warp，来达到这个目的 测试过还挺好用的 我自己开始测试的时候，如果在 VPS 上直接裸跑 WARP 客户端，会改到里面的网络配置，SSH 也会断开，看日志好像是修改了防火墙配置 但是在容器里跑，就没有这个问题 演示视频 const videojsid38707eb8bca34d3b99007588004cc799 = videojs('videojs-id-38707eb8-bca3-4d3b-9900-7588004cc799', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/categories/ChatGPT/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/tags/ChatGPT/"},{"name":"Cloudflare","slug":"Cloudflare","permalink":"https://linweiyuan.github.io/tags/Cloudflare/"},{"name":"WARP","slug":"WARP","permalink":"https://linweiyuan.github.io/tags/WARP/"}]},{"title":"ChatGPT 如何自建代理","slug":"ChatGPT-如何自建代理","date":"2023-04-08T16:11:04.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2023/04/08/ChatGPT-如何自建代理.html","link":"","permalink":"https://linweiyuan.github.io/2023/04/08/ChatGPT-%E5%A6%82%E4%BD%95%E8%87%AA%E5%BB%BA%E4%BB%A3%E7%90%86.html","excerpt":"","text":"经过一段时间的摸爬滚打，慢慢摸索出一套比较好的解决方案（就目前来说） 只能个人自用，多人公用会出现各种奇怪的问题，并且程序里加了锁只能一个接一个对话 （已找到方法解决这个问题，目前支持多人用不同的 accessToken 共用一个代理，但是如果是相同 accessToken 的话，还是会提示 Only one message at a time. Please allow any other responses to complete before sending another message, or wait one minute.，更新了视频在最下方） java-chatgpt-api 这边换成了 Playwright，开发测试会方便点，当然也是第一次用，好多 API 还用不明白，总之感觉挺强大的，如果前端玩得好，使用起来能更加得心应手 Java 版本的话，又 JVM、又 Spring、又 Playwright，跑起来非常占用内存，跑着跑着内存就占用 1G+ （可能泄漏了），适合本地部署 go-chatgpt-api 的话则还是依赖外置代理 chatgpt-proxy-server，因为测试过 playwright-go，Firefox 版本太低跑不起来，而 Chromium 能跑，但是过不了验证 Go 版本内存占用仅需十几兆，外置代理几百兆，加起来比 Java 能少一半，适合最低配 1 核 1G 服务器（当然也适合本地） 其中官网里的一旦对话超过 max_tokens，就会自动截断，需要发继续才能回复，这里被我魔改成了后台自动发继续请求，前端只需回车，全部内容一次性返回（可能有 bug） Java 那边依赖 Playwright 特性做了个处理验证码失败自动截图的功能方便排查，Go 这边则没有 其他的功能差不多相同，核心处理基本一样，具体实现方式可能有点差别 闭源代理见仁见智，涉及到 apiKey 或者 accessToken 安全 我这边的实现还是一种不是非常稳定的方式，不一定能完美解决验证码问题，也不一定正常使用无 bug 但是勉强能用，如果不行了，重启一下服务，大概率又复活，有问题我也会尝试修复 说句题外话，我说全部代码开源，有人质疑我提供的 docker 镜像把自己的闭源的二进制 go-chatgpt-api 文件打了进去，害怕有后门 我想说，其实你可以自己打包 我这个是代码提交后 github actions 自动打包推送到 docker 仓库的 换句话说，开源的代理关心 token 安全，反手把自己的 token 往其他人搭建好的闭源代理里送。我不理解 饭圈文化渗透到技术圈 如何使用、调试，全在视频里了 视频 const videojsid3fd574a99e3448c394859b63d983e3c4 = videojs('videojs-id-3fd574a9-9e34-48c3-9485-9b63d983e3c4', { html5: { hls: { overrideNative: true } } }); 多人共用一个代理 const videojsid99c2c472f1be443f968f3db5b9dad703 = videojs('videojs-id-99c2c472-f1be-443f-968f-3db5b9dad703', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/categories/ChatGPT/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/tags/ChatGPT/"},{"name":"Proxy","slug":"Proxy","permalink":"https://linweiyuan.github.io/tags/Proxy/"}]},{"title":"异步JS","slug":"异步JS","date":"2023-03-19T06:12:29.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2023/03/19/异步JS.html","link":"","permalink":"https://linweiyuan.github.io/2023/03/19/%E5%BC%82%E6%AD%A5JS.html","excerpt":"","text":"按照国际惯例，说异步之前，需要说下同步 同步比如如下代码，正常来说，会依次打印 123 123console.log(1);console.log(2);console.log(3); JS 的代码执行是单线程的，这个不是说 JS 引擎只有一个线程，而是执行代码的是一个线程，另外还有其他的线程做其他的事情 在上面输出 123 的情况下，如果第二步非常耗时，而这些步骤之间没有强的依赖关系的话，就会影响效率 这个时候就可以通过回调函数来处理第二步请求，也叫 callback 回调函数12345console.log(1);setTimeout(() =&gt; &#123; console.log(2);&#125;, 1000);console.log(3); 在第二步模拟一个耗时操作，比如要用 1 秒，如果按照上面的同步方式，则会输出 1，卡 1 秒后再输出 23，但是如果用回调，则不会阻塞，输出 13，1 秒后再通过回调，输出 2 耗时任务越多，这个效果越明显 下面用 XHR 模拟一个比较真实的场景 XHR 有 5 种状态：XMLHttpRequest.readyState Value State Description 0 UNSENT Client has been created. open() not called yet. 1 OPENED open() has been called. 2 HEADERS_RECEIVED send() has been called, and headers and status are available. 3 LOADING Downloading; responseText holds partial data. 4 DONE The operation is complete. 在一个普通的请求中，如果正常完成，会返回 DONE，然后就可以根据 xhr 的状态码和 HTTP 的状态码来进行处理 123456789101112const xhr = new XMLHttpRequest();xhr.addEventListener(&quot;readystatechange&quot;, () =&gt; &#123; if (xhr.readyState === xhr.DONE) &#123; if (xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(&quot;error&quot;); &#125; &#125; xhr.open(&quot;GET&quot;, &quot;xxx&quot;); xhr.send();&#125;); 考虑到可能会在多个地方需要发出这个请求，稍微封装下 1234567891011121314const getData = () =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.addEventListener(&quot;readystatechange&quot;, () =&gt; &#123; if (xhr.readyState === xhr.DONE) &#123; if (xhr.status === 200) &#123; console.log(xhr.responseText); &#125; else &#123; console.log(&quot;error&quot;); &#125; &#125; &#125;); xhr.open(&quot;GET&quot;, &quot;xxx&quot;); xhr.send();&#125;; 这样就可以很方便的进行调用 1getData(); 如果要通过回调函数的方式，则可以改为 12345678910111213141516171819202122const getData = (callback) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.addEventListener(&quot;readystatechange&quot;, () =&gt; &#123; if (xhr.readyState === xhr.DONE) &#123; if (xhr.status === 200) &#123; callback(xhr.responseText, undefined); &#125; else &#123; callback(undefined, &quot;error&quot;); &#125; &#125; &#125;); xhr.open(&quot;GET&quot;, &quot;xxx&quot;); xhr.send();&#125;;getData((data, err) =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 传入了一个回调函数，带两个参数，并进行成功与否的处理 这部分处理很像 Go 的双返回值，太像了 12345678func getData() (string, error) &#123; return data, nil;&#125;data, err := getData()if err != nil &#123; // print data&#125; 如果在 getData() 前后分别打印 12，则会输出 12，再执行里面的耗时任务，达到一个异步处理的效果 这就是回调函数，但是回调函数带来了一个问题 如果任务之间有强依赖，比如我要先登录，再获取用户信息，再进行另外的操作，如果用回调函数的写法，就会出现一个问题 12345678910111213login((data, err) =&gt; &#123; if (!err) &#123; getUserInfo((data, err) =&gt; &#123; if (!err) &#123; getData((data, err) =&gt; &#123; if (!err) &#123; // ok &#125; &#125;); &#125; &#125;); &#125;&#125;); 如果有 N 个请求，就会出现一个 &gt;，业界叫回调地狱 虽然代码是给机器执行的，但那是编译过的，源代码是给人看的，这样会不好维护 于是出现了一个新对象 Promise PromisePromise 用人话说就是一些需要一定的时间去完成的事情，不知道英文为什么叫这个名字，如果你用中文的承诺去套，也可以说得通 比如你结婚的时候，许下承诺，一辈子，那就是需要很长时间来完成的事情 Promise 会出现两种可能的结果： 成功的时候，走 resolve 失败则走 reject 同时也接收这两个函数作为参数 这样上面的 getData() 就可以改写成 12345678910111213141516const getData = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.addEventListener(&quot;readystatechange&quot;, () =&gt; &#123; if (xhr.readyState === xhr.DONE) &#123; if (xhr.status === 200) &#123; resolve(xhr.responseText); &#125; else &#123; reject(&quot;error&quot;); &#125; &#125; &#125;); xhr.open(&quot;GET&quot;, &quot;xxx&quot;); xhr.send(); &#125;);&#125;; 而 Promise 的后续一般用 then() 来处理 resolve 的结果，catch() 来处理 reject 的结果 123getData() .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 那么 Promise 是如何解决回调地狱的? 123456789101112login() .then((data) =&gt; &#123; console.log(data); return getUserInfo(); &#125;) .then((data) =&gt; &#123; console.log(data); return getData(); &#125;) .then((data) =&gt; &#123; console.log(data); &#125;); 既然每个请求都返回 Promise，而 Promise 又要 then() 来处理，那么通过将 Promise 进行 return， 再通过 then() 来处理，则可完成相同的效果 这样在一定程度上避免的回调的嵌套，但是还是不太直观 那么还有没有另外的方式？ 有 async &#x2F; await通过将函数设置为 async，在这个异步函数内部则可通过 await 来进行顺序的处理 改写上面方法，要定义一个异步方法，async 关键字要写在 function 前面，如果是箭头函数，则在参数前面 123456789101112const getData = async () =&gt; &#123; const loginResponse = await fetch(&quot;login&quot;); const loginData = await loginResponse.json(); const userInfoResponse = await fetch(&quot;userInfo&quot;); const userInfoData = await userInfoResponse.json(); const response = await fetch(&quot;data&quot;); const data = response.json(); return data;&#125;; 由于 fetch 本身是异步的，返回一个 Promise，因此里面通过 await 关键字可以得到最终的结果 又由于这个方法也设置成了异步方法，所以也需要通过 then() 再来进行最后的处理 1getData().then((data) =&gt; console.log(data)); 值得注意的是，一般情况下，请求不是 2xx 就会当作失败，出异常，理应走 reject，但是这个 fetch 即使出了 404 或者 500，还是走 resolve，这个时候，需要进一步判断它的 ok 属性或 HTTP 状态码，才能判断请求是否正常","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://linweiyuan.github.io/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"https://linweiyuan.github.io/tags/Promise/"}]},{"title":"一种取巧的方式绕过 Cloudflare v2 验证","slug":"一种取巧的方式绕过-Cloudflare-v2-验证","date":"2023-03-14T07:09:34.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2023/03/14/一种取巧的方式绕过-Cloudflare-v2-验证.html","link":"","permalink":"https://linweiyuan.github.io/2023/03/14/%E4%B8%80%E7%A7%8D%E5%8F%96%E5%B7%A7%E7%9A%84%E6%96%B9%E5%BC%8F%E7%BB%95%E8%BF%87-Cloudflare-v2-%E9%AA%8C%E8%AF%81.html","excerpt":"","text":"ChatGPT 一直在反爬虫的方式上下功夫，与第三方 API 开发者斗智斗勇 网页版服务刚出来的时候，是可以直接调用的 进入 2023 年，加了 Cloudflare 的验证，这个时候死掉了一堆第三方 API，好多至今仍然是瘫痪状态 但是通过分析发现，OpenAI 旗下的某个子域名其实在提供着相同的 API 服务，并且没加 CF 验证，于是部分第三方 API 复活 后面这个域名挂了，另一个域名又出来 但是在几天前，这个域名也挂了，接口全部 404，之前的第三方 API 又挂了 留给世人一个难题，如何绕过 CF 验证，方便快捷地使用网页版的服务？ 为什么不用公开 API？总体来说，除了 429，ChatGPT 比公开的 API 智能许多，我都用过有发言权 在绕过 CF 反爬虫的机制上，做过很多资料查询，使用过各种姿势，最后无一死在 403，尝试过的方式包括： 请求头修改这是最低级的方式，通过修改请求头的方式模拟浏览器，失败 设置 Cloudflare Cookie获取 CF 验证码需要的 Cookie，再在请求的时候加上，失败 JA3 指纹修改JA3 指纹识别的原理是什么，这里有篇详细的文章：TLS Fingerprinting with JA3 and JA3S 这个发生在握手阶段的 Client Hello 包，通过一些算法来计算出 JA3 指纹，简单来说，一个请求库发出的请求的指纹是固定的，比如我可以知道你的请求是不是来自 cURL，如果是，不合法，直接 403 这个概念有点类似一些库会自动设置 UserAgent，看下日志就能看得到，只是这个 JA3 发生在更底层的协议中 Java 这语言太高级了，在涉及 SSL&#x2F;TLS 方面的 API 过于复杂，我也缺少相关知识，所以这部分用 Golang 现有的请求库试过，确实能修改到指纹，这样的话，CF 就不知道我们的请求是来自哪个工具了，但是结果仍然是失败 JS 逆向这个尝试过，不是很懂 JS，太耗时间了，但是如果这个成功了，可能会一劳永逸，如果验证算法更新了，有之前的经验可能随便改改就能适配 自动化测试工具如果用浏览器去访问，就非常正常，所以想到另一种思路，可以在我们的第三方 API 的基础上，外挂个浏览器 顺其自然就会想到用 Selenium 或者其他类似的模拟浏览器的自动化测试工具，发送请求到我们的 API 的时候，模拟浏览器的点击操作发送请求 但是发现，如果用这些工具打开 ChatGPT，会一直重复出现 CF 验证码，点了之后又出现，再点还出现，无论试了 Selenium、Puppeteer、Playwright，结果都是一样 查询资料发现，其实这些所谓 WebDriver 的实现都会遵循一个规范，就是使用这些工具的时候，获取 navigator 的 webdriver 属性时，会返回 true，而普通浏览器会返回 undefined 那我们是不是可以覆盖它的默认实现，比如自定义 function，当访问这个属性的时候返回 undefined？试过了，不行，包括加一些 ChromeOptions，也不行 1234var webDriver = new ChromeDriver(chromeOptions);webDriver.executeCdpCommand(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, Map.of( &quot;source&quot;, &quot;Object.defineProperty(navigator, &#x27;webdriver&#x27;, &#123;get: () =&gt; undefined&#125;)&quot;)); 正当准备弃坑的时候，发现了一个工具确实能绕过 CF 验证，那就是 undetected_chromedriver 利用这个库能通过 CF 验证进入登录界面，是不是就可以登录，然后操作 dom 模拟数据输入和发送呢？理论上是，我没试，因为突然想到了另外一种方式 XMLHttpRequest既然这个 undetected_chromedriver 能正常打开页面，而我们的请求都是 XHR，那如果直接通过 JS 操作 XHR 会发生什么？ 结果是 200，某种程序上来说，已经成功绕过了 CF 验证 于是开始重写 API，将我们第三方 API 对 ChatGPT 的 API 的调用统统改成 JS 由于我大多写 Java，对于 JS 掌握得不是很好，这个时候遇到一个难题 普通的阻塞 API 都可以用 executeScript() 然后通过 return xhr.responseText; 返回响应，但是对话的时候，是 text/event-stream，这个时候如何处理 我知道 Spring 有个 WebFlux 是专门做这个事情的，但是我们又该如何从 JS 那里接管响应数据呢？ 接管到数据后，如何又把它们整合到 Flux 里返回呢？ 首先是第二个问题的解决方案： 12345678910return Flux.create(fluxSink -&gt; &#123; while (true) &#123; // 如果正常拿到数据 fluxSink.next(data); // 没数据了或者报错 fluxSink.complete(); break; &#125;&#125;); 如何获取数据？ 通过判断 XHR 状态码可以判断数据是不是在传输，比如 LOADING 则目前正在返回对话内容，DONE 则结束 1234567xhr.onreadystatechange = function () &#123; if (xhr.readyState === xhr.LOADING) &#123; // 接收数据 &#125; else if (xhr.readyState === xhr.DONE) &#123; // 结束 &#125;&#125;; 问题在于如何跨语言在 JS 里接收到数据再传到 Java 里，Java 可以通过一些脚本引擎执行 JS，但是在这里并不适用 于是想到了 callback 的方式，构造一个 Java 对象传进去，编译成功，但是运行报错，不认识传的对象，这个也正常 还有别的方法吗，发现有一个 postMessage() 可以用来跨源异步通信，那么不就能满足我们的需求了吗 123window.addEventListener(&quot;message&quot;, function(data) &#123; console.log(data);&#125;)； 只是不知如何和 XHR 脚本结合起来 因为异步脚本执行要通过 callback 返回数据，而这个 callback 又不能设置在 XHR 发送阶段，因为要频繁 callback 返回数据，这样就会频繁发送请求，所以必须在新的方法里处理，而这个 postMessage() 又需要通过 addEventListener() 的方式获取，所以这里很多矛盾的地方 我也不是很清楚频繁 addEventListener 会发生什么，有尝试过一些判断，如果没有设置过再设置，不好使 同样也不清楚设置多个会不会接收到重复数据，于是代码里先 remove 再 add，不知道合不合理，这个是目前得到的最折中的方法，并且能实现想要的效果，只是异步脚本执行会频繁超时，导致报错，这个还没知道怎么解决（后期已解决这个问题） undetected_chromedriver这个库是如何做到不被检测出来的，它在启动的时候修改了 driver 的一些数据，在运行时可以看到会打印在 console 里： https://github.com/ultrafunkamsterdam/undetected-chromedriver/blob/master/undetected_chromedriver/__init__.py#L246 https://github.com/ultrafunkamsterdam/undetected-chromedriver/blob/master/undetected_chromedriver/patcher.py#L91-L99 https://github.com/ultrafunkamsterdam/undetected-chromedriver/blob/master/undetected_chromedriver/patcher.py#L222-L228 而在运行的时候，修改过的 driver 会放在 ~/.local/share/undetected_chromedriver 里，运行完会删除，可以趁这个时间复制出来供后续使用 123456789101112131415161718192021./undetected_chromedriver --helpUsage: ./undetected_chromedriver [OPTIONS]Options --port=PORT port to listen on --adb-port=PORT adb server port --log-path=FILE write server log to file instead of stderr, increases log level to INFO --log-level=LEVEL set log level: ALL, DEBUG, INFO, WARNING, SEVERE, OFF --verbose log verbosely (equivalent to --log-level=ALL) --silent log nothing (equivalent to --log-level=OFF) --append-log append log file instead of rewriting --replayable (experimental) log verbosely and don&#x27;t truncate long strings so that the log can be replayed. --version print the version number and exit --url-base base URL path prefix for commands, e.g. wd/url --readable-timestamp add readable timestamps to log --enable-chrome-logs show logs from the browser (overrides other logging options) --bidi-mapper-path custom bidi mapper path --disable-dev-shm-usage do not use /dev/shm (add this switch if seeing errors related to shared memory) --allowed-ips=LIST comma-separated allowlist of remote IP addresses which are allowed to connect to ChromeDriver --allowed-origins=LIST comma-separated allowlist of request origins which are allowed to connect to ChromeDriver. Using `*` to allow any host origin is dangerous! 在本地测试的时候可以使用 undetected_chromedriver --allowed-ips=&quot;&quot; --allowed-origins=&quot;*&quot; 来启动，公网要考虑风险 这样就能在 API 外再套一层这个来绕过 Cloudflare v2 验证了 网页版使用的时候，需要频繁刷新，尝试过写个定时器去主动刷新，效果是可以的，只是如果在对话响应处理的过程中刚好碰上自动刷新，对话就会戛然而止，于是改为了被动刷新 如果请求过来，先发一个 XHR 去看下是不是 200，如果是 403，则刷新网页拿新 Cookie，再去请求 API，效果也还行 （后期又改回了定时刷新，并且在对话中不刷新） 打包了一个 Docker 镜像：linweiyuan&#x2F;chatgpt-proxy-server，开箱即用 尝试过用 Alpine，硬是缺少一些库，于是用回熟悉的 Arch，只是最终镜像有点大，压缩后 413.19 MB，解压后 1.16GB Dockerfile 可过验证码 代码第三方 API: 基于 Java 实现：java-chatgpt-api 基于 Go 实现：go-chatgpt-api 第三方客户端： Java 图形化界面：ChatGPT-Swing Go 终端程序：go-chatgpt 视频（晚上卡顿版） const videojsid82efb550bb6d4758be0afafb0e9404f8 = videojs('videojs-id-82efb550-bb6d-4758-be0a-fafb0e9404f8', { html5: { hls: { overrideNative: true } } }); （白天流畅版） const videojsid9e2314ec8de44dabb80bfdc5c11c7685 = videojs('videojs-id-9e2314ec-8de4-4dab-b80b-fdc5c11c7685', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/categories/ChatGPT/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/tags/ChatGPT/"},{"name":"Selenium","slug":"Selenium","permalink":"https://linweiyuan.github.io/tags/Selenium/"},{"name":"Golang","slug":"Golang","permalink":"https://linweiyuan.github.io/tags/Golang/"},{"name":"Cloudflare","slug":"Cloudflare","permalink":"https://linweiyuan.github.io/tags/Cloudflare/"}]},{"title":"go-chatgpt","slug":"go-chatgpt","date":"2023-03-05T09:01:34.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2023/03/05/go-chatgpt.html","link":"","permalink":"https://linweiyuan.github.io/2023/03/05/go-chatgpt.html","excerpt":"","text":"弄了个终端版，只需 accessToken 即可使用，非常简洁 简洁到连异常处理都没有做，勉强能用：go-chatgpt","categories":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/categories/ChatGPT/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/tags/ChatGPT/"},{"name":"Golang","slug":"Golang","permalink":"https://linweiyuan.github.io/tags/Golang/"},{"name":"TUI","slug":"TUI","permalink":"https://linweiyuan.github.io/tags/TUI/"}]},{"title":"ChatGPT-Swing","slug":"ChatGPT-Swing","date":"2023-02-25T07:36:39.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2023/02/25/ChatGPT-Swing.html","link":"","permalink":"https://linweiyuan.github.io/2023/02/25/ChatGPT-Swing.html","excerpt":"","text":"由于官方关闭了用到的 API，部分内容已过期 新增了 API 切换支持，可以选择使用 API （API Key）还是 ChatGPT （Access Token） 支持查询当前免费额度 ChatGPT-Swing 是一个非官方的 GUI 程序，利用 Java Swing 技术实现，基于网页版 ChatGPT（3.5），而非公开的 GPT-3 API。利用这个程序，你可以做很多网页版可以做的事（Regenerate response 感觉没必要就没做），包括： 账号登录（谷歌账号和微软账号还没测试） accessToken 自动刷新（比如明天过期，今天打开程序就会尝试刷新） 对话新增与聊天（支持关联上下文） 删除单个对话（看请求参数其实是隐藏，但隐藏后你再访问这个 id 就会 404） 删除所有对话 重命名对话标题 消息反馈（点赞或点踩） 文本转语音（调用 Free TTS 的在线测试服务，每周对单个 IP 有字数限制，这个网站是支持很多语言的，程序里目前仅支持英语，写死了） 同时免除了烦人的 Cloudflare 验证，挂机后回来随时对话无需刷新网页 缺点就是非官方 API，随时失效，还可能有 Bug 项目依赖 下面是部分截图登录 程序一开始的设计是直接访问 ChatGPT 服务，这个选项就有用，因为登录的时候会检测当前国家或地区是否支持，登录完成后再调用其他 API 一般就不用了，通常都可以直连，所以这个代理选项只对登录接口有效，并且是本地代理，不是说设置了之后服务器就会用这个代理再去访问 ChatGPT 服务 后来用 Go 测试登录，发现，在我本地相同的网络环境下，如果 Kotlin 这边直接调用 ChatGPT 登录服务，整套流程包括拿 CSRF token 和一些重定向、用户名密码检测、最终拿 accessToken，需要 10 秒左右 神奇的事情发生了，利用 Go 去登录，仅需 5 秒左右，于是干脆起了个 Gin 服务，转发所有请求 这个不是瞎说的，直接登录 ChatGPT 的代码在早期的 commit 里，有兴趣的可以自行 checkout 测试 但这导致了一个问题，如果当前 IP 不在支持范围内，即使登录时开启代理也没用 但是我也没删除，就这样先留着了，因为还有一种潜在的场景就是，在你的本地环境下，确实需要代理才能更快地访问你的自建 API 服务，然后 API 服务将登录接口单独再经一层转发到受支持国家或地区服务器（脑回路比较不寻常就是了） 主界面的组件选择每次新建的对话，会自动调用接口生成标题，左边是一个树形组件（根节点隐藏了），跟着的节点是每个对话，其中显示的是对话标题。对话下面的是每次问答，其中问的问题会作为对话的子节点加入树中，中间区域则显示 ChatGPT 的响应信息 这部分 UI 经过了重构，一开始打算用 JList，类似网页版的效果，点击显示所有，然后中间用 JTextArea 直接追加就完了，但是请求和响应颜色一样，看瞎眼 接着中间区域又改成 JTextPane，以 HTML 的方式显示数据，加一些 css 来修改对话的背景色来区分自己的请求的 ChatGPT 的响应，也不好使，勉强能用 左边后来改成了 JTree，点击父节点显示整个对话内容，点击子节点就显示本次问答，测试完成差强人意 然后无意中发现了一个好用的库 RSyntaxTextArea，解决了代码高亮、折叠等问题，除了 &#39;s 这个符号偶尔错误解析自动换行，最终的效果就比较理想了，也就是现在的模样 点击父节点显示整个对话内容（关联上下文） 点击子节点显示本次请求响应 代码高亮 RSyntaxTextArea 内建支持列表 父节点右键菜单 刷新选中对话内容 重命名选中对话 删除选中对话 清空所有对话 子节点右键菜单 反馈（这里没有加文本反馈，网页版有，并且网页版如果点赞了再点踩是可以的，这里会报错） 文本转语音选中文本点击 TTS 按钮则可（这个有诸多限制，在文章一开始有写） 演示视频 const videojsidfb1b408461644321aec88c1cb610f334 = videojs('videojs-id-fb1b4084-6164-4321-aec8-8c1cb610f334', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/categories/ChatGPT/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://linweiyuan.github.io/tags/Kotlin/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/tags/ChatGPT/"},{"name":"Swing","slug":"Swing","permalink":"https://linweiyuan.github.io/tags/Swing/"}]},{"title":"jsoup1.15.4奇怪bug排查","slug":"jsoup1-15-4奇怪bug排查","date":"2023-02-22T10:54:55.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2023/02/22/jsoup1-15-4奇怪bug排查.html","link":"","permalink":"https://linweiyuan.github.io/2023/02/22/jsoup1-15-4%E5%A5%87%E6%80%AAbug%E6%8E%92%E6%9F%A5.html","excerpt":"","text":"官方团队很快就修复了https://github.com/jhy/jsoup/issues/1902 jsoup 是目前个人用过的简单易用轻量的很好的一个工具，特别是解析网页方面，爬虫、模拟登录等 目前有个项目也有用到，我是比较喜欢用新的版本的，所以当时就用了 1.15.3 最新，一直相安无事 昨天看见 pom.xml 报黄，于是升级至 1.15.4，好多 API 请求都正常 这里插句题外话，JDK 在源码级别不支持 PATCH 方法，比如 java.net.HttpURLConnection 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package java.net;...public abstract class HttpURLConnection extends URLConnection &#123;... /* valid HTTP methods */ private static final String[] methods = &#123; &quot;GET&quot;, &quot;POST&quot;, &quot;HEAD&quot;, &quot;OPTIONS&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;TRACE&quot; &#125;;... /** * Set the method for the URL request, one of: * &lt;UL&gt; * &lt;LI&gt;GET * &lt;LI&gt;POST * &lt;LI&gt;HEAD * &lt;LI&gt;OPTIONS * &lt;LI&gt;PUT * &lt;LI&gt;DELETE * &lt;LI&gt;TRACE * &lt;/UL&gt; are legal, subject to protocol restrictions. The default * method is GET. * * @param method the HTTP method * @throws ProtocolException if the method cannot be reset or if * the requested method isn&#x27;t valid for HTTP. * @throws SecurityException if a security manager is set and the * method is &quot;TRACE&quot;, but the &quot;allowHttpTrace&quot; * NetPermission is not granted. * @see #getRequestMethod() */ public void setRequestMethod(String method) throws ProtocolException &#123; if (connected) &#123; throw new ProtocolException(&quot;Can&#x27;t reset method: already connected&quot;); &#125; // This restriction will prevent people from using this class to // experiment w/ new HTTP methods using java. But it should // be placed for security - the request String could be // arbitrarily long. for (int i = 0; i &lt; methods.length; i++) &#123; if (methods[i].equals(method)) &#123; if (method.equals(&quot;TRACE&quot;)) &#123; @SuppressWarnings(&quot;removal&quot;) SecurityManager s = System.getSecurityManager(); if (s != null) &#123; s.checkPermission(new NetPermission(&quot;allowHttpTrace&quot;)); &#125; &#125; this.method = method; return; &#125; &#125; throw new ProtocolException(&quot;Invalid HTTP method: &quot; + method); &#125;&#125; 试过 X-Method-Override 也不好使，于是部分 PATCH 的接口改用 okhttp3 今天重新测试的时候，发现登录接口不好使了，因为登录是一条 Auth0 的链接，https://auth0.xxx.com/authorize?client_id=xxx&amp;scope=openid%20email%20profile，scope 里面的值是有空格分开的 ‘%’ 也会被转码 在 1.15.3 里面正常，在 1.15.4 里会把 %20 里面的 % 也重新编码，导致出现 %2520，服务器就报错了 获取不到 state，无法登录系统 回滚后一切正常","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"jsoup","slug":"jsoup","permalink":"https://linweiyuan.github.io/tags/jsoup/"}]},{"title":"ChatGPT如何教我写Python","slug":"ChatGPT如何教我写Python","date":"2023-02-21T16:30:34.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2023/02/21/ChatGPT如何教我写Python.html","link":"","permalink":"https://linweiyuan.github.io/2023/02/21/ChatGPT%E5%A6%82%E4%BD%95%E6%95%99%E6%88%91%E5%86%99Python.html","excerpt":"","text":"有时候并不是不会一样东西，只是不熟悉语法，比如广州去北京，大家都知道往北，但是需要一个导航才能去；比如英语口语，到嘴边了不知道怎么表达出来 ChatGPT 就是这样一个帮手 const videojsid1dfd98f237dc4953bf01bdf51b0e79a0 = videojs('videojs-id-1dfd98f2-37dc-4953-bf01-bdf51b0e79a0', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/categories/ChatGPT/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/tags/ChatGPT/"},{"name":"Python","slug":"Python","permalink":"https://linweiyuan.github.io/tags/Python/"},{"name":"Selenium","slug":"Selenium","permalink":"https://linweiyuan.github.io/tags/Selenium/"}]},{"title":"Unity练习时长两天半","slug":"Unity练习时长两天半","date":"2023-02-12T16:10:52.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2023/02/12/Unity练习时长两天半.html","link":"","permalink":"https://linweiyuan.github.io/2023/02/12/Unity%E7%BB%83%E4%B9%A0%E6%97%B6%E9%95%BF%E4%B8%A4%E5%A4%A9%E5%8D%8A.html","excerpt":"","text":"精神状态不用怀疑，很正常 const videojsid42125067d5c84cd09b8f9eecf94bed27 = videojs('videojs-id-42125067-d5c8-4cd0-9b8f-9eecf94bed27', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"Unity","slug":"Unity","permalink":"https://linweiyuan.github.io/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://linweiyuan.github.io/tags/Unity/"}]},{"title":"LMMS-原野追逐","slug":"LMMS-原野追逐","date":"2023-02-11T18:34:19.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2023/02/11/LMMS-原野追逐.html","link":"","permalink":"https://linweiyuan.github.io/2023/02/11/LMMS-%E5%8E%9F%E9%87%8E%E8%BF%BD%E9%80%90.html","excerpt":"","text":"const videojsidf299c74d9b3e47e6a0645207b63f06c1 = videojs('videojs-id-f299c74d-9b3e-47e6-a064-5207b63f06c1', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/categories/LMMS/"}],"tags":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/tags/LMMS/"},{"name":"原野追逐","slug":"原野追逐","permalink":"https://linweiyuan.github.io/tags/%E5%8E%9F%E9%87%8E%E8%BF%BD%E9%80%90/"},{"name":"Cornfield Chase","slug":"Cornfield-Chase","permalink":"https://linweiyuan.github.io/tags/Cornfield-Chase/"},{"name":"星际穿越","slug":"星际穿越","permalink":"https://linweiyuan.github.io/tags/%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A/"}]},{"title":"LMMS-云宫迅音","slug":"LMMS-云宫迅音","date":"2023-02-10T14:34:24.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2023/02/10/LMMS-云宫迅音.html","link":"","permalink":"https://linweiyuan.github.io/2023/02/10/LMMS-%E4%BA%91%E5%AE%AB%E8%BF%85%E9%9F%B3.html","excerpt":"","text":"const videojsidec0b2b8f4b014572940ecf6f53c56ca7 = videojs('videojs-id-ec0b2b8f-4b01-4572-940e-cf6f53c56ca7', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/categories/LMMS/"}],"tags":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/tags/LMMS/"},{"name":"云宫迅音","slug":"云宫迅音","permalink":"https://linweiyuan.github.io/tags/%E4%BA%91%E5%AE%AB%E8%BF%85%E9%9F%B3/"}]},{"title":"LMMS-一生所爱","slug":"LMMS-一生所爱","date":"2023-02-09T14:30:29.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2023/02/09/LMMS-一生所爱.html","link":"","permalink":"https://linweiyuan.github.io/2023/02/09/LMMS-%E4%B8%80%E7%94%9F%E6%89%80%E7%88%B1.html","excerpt":"","text":"const videojsidec3feb7652bf4d5c8da92580069e3c0d = videojs('videojs-id-ec3feb76-52bf-4d5c-8da9-2580069e3c0d', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/categories/LMMS/"}],"tags":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/tags/LMMS/"},{"name":"一生所爱","slug":"一生所爱","permalink":"https://linweiyuan.github.io/tags/%E4%B8%80%E7%94%9F%E6%89%80%E7%88%B1/"}]},{"title":"LMMS-神话","slug":"LMMS-神话","date":"2023-02-08T12:20:39.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2023/02/08/LMMS-神话.html","link":"","permalink":"https://linweiyuan.github.io/2023/02/08/LMMS-%E7%A5%9E%E8%AF%9D.html","excerpt":"","text":"const videojsidf309ab3888b5428e8c0545e12556ac57 = videojs('videojs-id-f309ab38-88b5-428e-8c05-45e12556ac57', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/categories/LMMS/"}],"tags":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/tags/LMMS/"},{"name":"神话","slug":"神话","permalink":"https://linweiyuan.github.io/tags/%E7%A5%9E%E8%AF%9D/"}]},{"title":"ChatGPT","slug":"ChatGPT","date":"2023-02-08T05:36:55.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2023/02/08/ChatGPT.html","link":"","permalink":"https://linweiyuan.github.io/2023/02/08/ChatGPT.html","excerpt":"","text":"以下文章内容是和 ChatGPT 对话出来的 介绍一下 ChatGPTChatGPT 是由 OpenAI 开发的一种大型语言模型。它是基于 Transformer 架构的，并且经过了大量的训练，以生成自然语言文本。ChatGPT 被设计用来进行对话，因此具有很高的语言理解能力和文本生成能力。它可以用来回答问题、生成文本、进行翻译等等。 继续ChatGPT 的训练数据来自互联网上的大量文本，因此它具有广泛的知识基础。在训练过程中，ChatGPT 学会了如何生成自然语言文本，并且可以理解上下文，因此它可以生成很多人类可以理解的文本。此外，ChatGPT 还具有非常高的语言处理速度，因此它可以在短时间内处理大量文本。总之，ChatGPT 是一个非常强大的语言模型，可以用来解决各种自然语言处理问题。 继续ChatGPT 的应用非常广泛，它可以用来做聊天机器人、问答系统、文本生成、翻译、情感分析等等。此外，由于它具有高效的语言处理能力，因此它还可以用来做自动文本摘要、自动文档分类等。在许多场景中，ChatGPT 可以作为一个自然语言处理的解决方案，以帮助人们解决各种语言处理问题。总之，ChatGPT 是一个非常有价值的工具，可以用来解决各种自然语言处理问题。 说多点除了以上提到的应用以外，ChatGPT 还可以用来做语音识别、文本标注、文本分类等等。它的语言生成能力也可以用来生成代码、生成音乐、生成图片等。此外，ChatGPT 还可以用来做数据分析、智能客服、商业智能等。由于它具有高效的语言处理能力和广泛的知识基础，因此它可以作为一个非常有用的工具，帮助人们解决各种语言处理问题。总的来说，ChatGPT 是一个非常强大的语言模型，具有广泛的应用前景。 可以用来干嘛ChatGPT 可以用来解决许多自然语言处理任务，包括但不限于： 聊天机器人：可以与用户进行自然语言交互，解答他们的问题。 问答系统：可以根据用户的问题生成相应的答案。 文本生成：可以根据给定的模板或者提示生成人类可以理解的文本。 翻译：可以将一种语言翻译为另一种语言。 情感分析：可以对文本进行情感分析，以确定文本是正面、负面或中性。 自动文本摘要：可以根据文本的主题和内容自动生成摘要。 文本分类：可以对文本进行分类，将它们归入不同的类别中。 数据分析：可以根据数据生成图表和报告。 智能客服：可以与客户进行自然语言交互，帮助他们解决问题。 商业智能：可以帮助企业做数据分析和决策支持。 总的来说，ChatGPT 可以用来解决大量的自然语言处理问题，并且因其快速、高效的语言处理能力而受到广泛的关注和应用。 会替换掉程序员吗不是的，ChatGPT 并不能替换程序员。虽然 ChatGPT 是一个强大的自然语言处理模型，但它并不能完全替代程序员的工作。程序员仍然需要创建、设计和实现应用程序。他们还需要构建并维护后台系统，提供安全性和数据隐私保护等功能。 此外，ChatGPT 只是一种工具，它需要由程序员使用并进行集成，以实现其全部功能。程序员仍然是必要的，因为他们需要定义如何使用 ChatGPT，以及如何将它与其他系统和工具进行集成，以实现实际应用程序。 总的来说，ChatGPT 可以与程序员合作，帮助他们解决自然语言处理问题，但它不能替代程序员的工作。 收费吗是的，使用 ChatGPT 是需要收费的。OpenAI 以 API 形式提供 ChatGPT，并对 API 调用收取计费。具体的计费标准和计费方式取决于你的使用情况，例如 API 调用的数量和频率。如果您对计费标准有兴趣，请前往 OpenAI 的官方网站查询详情。 底层实现原理是什么ChatGPT 的底层实现原理是基于 transformer 模型的预训练语言模型。 Transformer 模型是一种用于自然语言处理的神经网络模型，它的主要特点是通过注意力机制来关注输入中重要的单词和词组，以便于生成准确的预测。 在预训练阶段，ChatGPT 模型被训练在大量的文本数据上，以学习自然语言的语法和语义。在训练过程中，模型学习了如何生成合理的文本响应，如回答问题、生成摘要等。 在应用阶段，用户可以输入一个问题或请求，ChatGPT 模型将在其内部的语言表示中对输入进行编码，并生成对应的输出。 总的来说，ChatGPT 是一个通过大量数据预训练和深度学习技术实现的语言生成模型，它通过编码和生成语言来回答问题和生成文本内容。 会替换传统工作吗不一定会完全替代传统工作，但是 AI 技术，包括语言模型如 ChatGPT，确实可以自动完成一些传统工作中的任务，并以更高的效率和准确性完成这些任务。 例如，ChatGPT 可以帮助生成文本内容，比如文章摘要、新闻报道等，从而减少了人工工作量。同时，ChatGPT 还可以帮助自动回答问题，比如帮助客户服务代表解答客户问题等。 然而，ChatGPT 和其他 AI 技术仍需要由人类进行监督和管理，并且在某些情况下，人类仍然是不可替代的。因此，虽然 AI 技术可以帮助减少一些人工工作，但它不能完全替代人类。 会进化成天网吗不存在“天网”这个东西，它是电影《终结者 2：审判日》中的一个虚构概念。但是，如果您指的是是否存在 AI 变得过于强大并对人类造成威胁的风险，那么这是一个值得关注的问题。 目前，AI 技术仍需要由人类进行监督和管理，并且 AI 的行为受到人类的限制和控制。同时，在 AI 研究和开发的过程中，也需要遵守道德和伦理准则，以确保 AI 的安全和健康使用。 因此，ChatGPT 不会变得过于强大并对人类造成威胁。但是，我们仍需要警惕 AI 的风险，并努力确保 AI 的安全和健康使用。 会按下核弹发射按钮吗不会，因为 ChatGPT 是一种人工智能模型，它没有实际的动作能力。它仅仅是一种语言生成模型，可以根据输入的文本生成相应的输出，但它不具有控制实际设备的能力。 此外，与核武器有关的决策通常需要经过多层安全检查和严格的审查程序，并由政府军事人员和安全专家进行控制。因此，我们可以确信，ChatGPT 无法按下核弹发射按钮。 还有其他的省略掉了 总的来说，相比冷冰冰的搜索引擎，ChatGPT 更像一个平时生活中的人，问他问题总能比较有逻辑地精炼出解决的答案，当然不一定正确，这时如果提出疑问，他也会反思自己的答案有哪里出现不足，然后给出修改后的答案 缺点就是目前相对英文，中文提问回答较卡","categories":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/categories/ChatGPT/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/tags/ChatGPT/"}]},{"title":"Effective Java","slug":"Effective-Java","date":"2023-01-01T08:14:46.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2023/01/01/Effective-Java.html","link":"","permalink":"https://linweiyuan.github.io/2023/01/01/Effective-Java.html","excerpt":"","text":"目录，有改动 创建和销毁对象 考虑用静态工厂方法代替构造器 遇到多个构造器参数时考虑用构造器 用私有构造器或枚举类型强化 Singleton 属性 通过私有构造器强化不可实例化的能力 避免创建不必要的对象 消除过期的对象引用 避免使用终结方法 对于所有对象都通用的方法 重写 equals 时遵守通用约定 重写 equals 时记得重写 hashCode 始终要重写 toString 谨慎地重写 clone 考虑实现 Comparator 接口 类和接口 使类和成员的可访问性最小化 在公有类中访问 public 方法而非直接访问 public 属性 使可变性最小化 复合优先于继承 要么为继承而设计，并提供文档说明，要么就禁止继承 接口优先于抽象类 接口只用于定义类型 类层次优先于标签类 用函数对象表示策略 优先考虑静态成员类 泛型 请不要在新代码中使用原生态类型 消除非受检警告 集合优先于数组 优先考虑泛型 优先考虑泛型方法 利用有限制通配符来提升 API 的灵活性 优先考虑类型安全的异构容器 枚举和注解 用 enum 代替 int 常量 用实例域代替序数 用 EnumSet 代替位域 用 EnumMap 代替序数索引 用接口模拟可伸缩的枚举 注解优先于命名模式 坚持使用 Override 注解 用标记接口定义类型 方法 检查参数的有效性 必要时进行保护性拷贝 谨慎设计方法签名 慎用重载 慎用可变参数 返回零长度的数组或者集合，而不是 null 为所有导出的 API 元素编写文档注释 通用程序设计 将局部变量的作用域最小化 for-each 循环优先于传统的 for 循环 了解和使用类库 如果需要精确的答案，避免使用 float 和 double 基本类型优先于装箱基本类型 如果其他类型更适合，尽量避免使用字符串 当心字符串连接的性能 通过接口引用对象 接口优先于反射机制 谨慎地使用本地方法 谨慎地进行优化 遵守普遍接受的命名惯例 异常 只针对异常的情况才使用异常 对可恢复的情况使用受检异常，对编程错误使用运行时异常 避免不必要地使用受检的异常 优先使用标准的异常 抛出与抽象相对应的异常 每个方法抛出的异常都要有文档 在细节消息中包含能捕获失败的信息 努力使失败保持原子性 不要忽略异常 并发 同步访问共享的可变数据 避免过度同步 executor 和 task 优先于线程 并发工具优先于 wait 和 notify 线程安全性的文档化 慎用延迟初始化 不要依赖于线程调度器 避免使用线程组 序列化 谨慎地实现 Serializable 接口 考虑使用自定义的序列化形式 保护性地编写 readObject 方法 对于实例控制，枚举类型优先于 readResolve 考虑用序列化代理代替序列化实例","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"}]},{"title":"virt-manager安装Windows 11","slug":"virt-manager安装Windows-11","date":"2022-12-16T08:37:08.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2022/12/16/virt-manager安装Windows-11.html","link":"","permalink":"https://linweiyuan.github.io/2022/12/16/virt-manager%E5%AE%89%E8%A3%85Windows-11.html","excerpt":"","text":"用 virt manager 安装 Windows 需要注意的事项： 系统 CPU 和内存尽量设置大点 要选择 UEFI 方式启动 需要加个 TPM 模块，虚拟的即可 const videojsidfabddcf73a1a427a9c88b627e8a769b2 = videojs('videojs-id-fabddcf7-3a1a-427a-9c88-b627e8a769b2', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://linweiyuan.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"KVM","slug":"KVM","permalink":"https://linweiyuan.github.io/tags/KVM/"},{"name":"QEMU","slug":"QEMU","permalink":"https://linweiyuan.github.io/tags/QEMU/"}]},{"title":"橄榄镇与希望的大地商店物品修改（yuzu）","slug":"橄榄镇与希望的大地商店物品修改（yuzu）","date":"2022-12-10T13:12:56.000Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"2022/12/10/橄榄镇与希望的大地商店物品修改（yuzu）.html","link":"","permalink":"https://linweiyuan.github.io/2022/12/10/%E6%A9%84%E6%A6%84%E9%95%87%E4%B8%8E%E5%B8%8C%E6%9C%9B%E7%9A%84%E5%A4%A7%E5%9C%B0%E5%95%86%E5%BA%97%E7%89%A9%E5%93%81%E4%BF%AE%E6%94%B9%EF%BC%88yuzu%EF%BC%89.html","excerpt":"","text":"GitHub: https://github.com/linweiyuan/switch-olive-town-shop-hack 挖宝石本来就是看人品，耗时间，动不动还要 N 个，不能忍，写了个程序来修改商店物品数据 视频本来发在其他视频网站，但是后面审核太恶心，我删号了，所以没简介，但是字幕烧进去去不掉了 const videojsid8484c1288d454aaf8a9fa1f6dc33ef3a = videojs('videojs-id-8484c128-8d45-4aaf-8a9f-a1f6dc33ef3a', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"游戏","slug":"游戏","permalink":"https://linweiyuan.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"Switch","slug":"Switch","permalink":"https://linweiyuan.github.io/tags/Switch/"},{"name":"yuzu","slug":"yuzu","permalink":"https://linweiyuan.github.io/tags/yuzu/"},{"name":"橄榄镇与希望的大地","slug":"橄榄镇与希望的大地","permalink":"https://linweiyuan.github.io/tags/%E6%A9%84%E6%A6%84%E9%95%87%E4%B8%8E%E5%B8%8C%E6%9C%9B%E7%9A%84%E5%A4%A7%E5%9C%B0/"}]},{"title":"虚拟机显卡直通 (PCI passthrough via OVMF)","slug":"虚拟机显卡直通-PCI-passthrough-via-OVMF","date":"2022-11-25T02:23:36.000Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"2022/11/25/虚拟机显卡直通-PCI-passthrough-via-OVMF.html","link":"","permalink":"https://linweiyuan.github.io/2022/11/25/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%BE%E5%8D%A1%E7%9B%B4%E9%80%9A-PCI-passthrough-via-OVMF.html","excerpt":"","text":"虚拟机对显卡的支持一向并不是非常完美，比如 VirtualBox 虚拟机设置，显存部分一般最多拉到 128MB，是虚拟的，无法用物理机的显卡，哪怕这张显卡是闲置的 VMware 很久没用了，据我所知，也是不支持物理显卡（这里不考虑企业级软件） 而 KVM + QEMU 却可以通过 PCI passthrough 的方式将物理机的显卡直通给虚拟机用，非常厉害 前提准备下面所有操作都是基于 Arch Linux，其他系统未测试，未来也不会测试 因为本质上还是虚拟机，所以要确保 BIOS 设置好了开启虚拟化 接着就是要开启 IOMMU，这个也要硬件的支持 如果是 Intel 的 CPU，修改内核参数 intel_iommu=on iommu=pt 如果是 AMD 的 CPU，默认就有一些设置，因此只需加 iommu=pt（Yes？） 修改完内核参数要重新跑 sudo grub-mkconfig -o /boot/grub/grub.cfg，重启生效 然后就是要拿到硬件的一些 id，这些 id 将会作为硬件的唯一标识在直通的过程中被使用到（这个脚本可以在 Arch Wiki 找到） 12345678#!/bin/bashshopt -s nullglobfor g in $(find /sys/kernel/iommu_groups/* -maxdepth 0 -type d | sort -V); do echo &quot;IOMMU Group $&#123;g##*/&#125;:&quot; for d in $g/devices/*; do echo -e &quot;\\t$(lspci -nns $&#123;d##*/&#125;)&quot; done;done; PCI passthrough 的处理是通过将显卡从你的宿主机隔离出来，其中又有多种处理方式 多显卡如果你的电脑是多显卡，并且 Linux 系统没有独显需求，就可以使用这种方法 这种情况多数出现在笔记本，当然台式机也有，只是很多 CPU 型号都把核显砍了 如果有独显，CPU 里又已经有核显了，厂商会进行一些优化，平时用核显，但是当有专业需求的时候，走的就是独显；自己也可以通过 Optimus 或者 Bumblebee 来进行控制 我的笔记本之前只拿来写写 Java，就是用 nvidia-xrun 把整个独显都禁用掉，neofetch 也查不到，相当于不通电，这样来稍微省点电池消耗 如果宿主机跑的是 Linux，虚拟机跑的是 Windows，那就可以通过这种方式来进行设置 这种方法可以实现物理机和虚拟机同时存在，物理机显示用核显，因为都不用独显了，所以可以在物理机系统启动时就把显卡隔离出来，这个就需要修改 Linux 内核参数 将上面准备阶段拿到的 id，写进内核参数 vfio-pci.ids=xxx，也要重新生成 grub 配置，也是重启生效 接着修改 /etc/modprobe.d/vfio.conf 123MODULES=(... vfio_pci vfio vfio_iommu_type1 vfio_virqfd ...)...HOOKS=(... modconf ...) 修改完这个后也要重新生成 sudo mkinitcpio -p linux，同样是重启生效 然后多显卡的前提配置就完成了 单显卡单显卡有点特殊，物理机输出到显示器也要显卡，所以不能提前将其隔离 QEMU 提供了一个 hook 功能，当虚拟机执行到某个阶段时，可以执行一些特定的脚本 因此思路就有了 系统开机，正常使用显卡显示 开启虚拟机时，执行 hook，释放掉占用的资源，将显卡在物理机上隔离出来 关闭虚拟机时，执行 hook，重新把显卡模块启用，开启 DM 首先 id 要写在一个单独配置文件 /etc/modprobe.d/vfio.conf 里，这个起到的作用就是可以动态进行模块的加载 1options vfio-pci ids=xxx 接着要准备好 hook 脚本，路径是 /etc/libvirt/hooks/qemu 12345678910111213141516#!/bin/bashOBJECT=&quot;$1&quot;OPERATION=&quot;$2&quot;if [[ $OBJECT == &quot;win10&quot; ]]; then case &quot;$OPERATION&quot; in &quot;prepare&quot;) prepare.sh 2&gt;&amp;1 | tee -a /var/log/libvirt/hooks.log ;; &quot;release&quot;) release.sh 2&gt;&amp;1 | tee -a /var/log/libvirt/hooks.log ;; esacfi 这里的 win10 是虚拟机的名称 开启虚拟机的监听脚本 prepare.sh 123456789101112131415161718set -xsystemctl stop lightdmecho efi-framebuffer.0 &gt; /sys/bus/platform/drivers/efi-framebuffer/unbindmodprobe -r nvidia_drmmodprobe -r nvidia_modesetmodprobe -r nvidia_uvmmodprobe -r nvidiavirsh nodedev-detach pci_0000_xxxvirsh nodedev-detach pci_0000_xxxmodprobe vfio_pcimodprobe vfiomodprobe vfio_iommu_type1modprobe vfio_virqfd 其中的 pci_0000_xxx 是在查 id 的阶段拿到的，比如输出 106:00.0 VGA compatible controller [0300]: NVIDIA Corporation GA104 [GeForce RTX 3060 Ti] [10de:2486] (rev a1) 则 options vfio-pci ids=10de:2486，virsh nodedev-detach pci_0000_06_00_0 关闭虚拟机的监听脚本 release.sh，关闭其实就是一个反向的回滚操作 1234567891011121314151617set -xmodprobe -r vfio_pcimodprobe -r vfiomodprobe -r vfio_iommu_type1modprobe -r vfio_virqfdvirsh nodedev-reattach pci_0000_xxxecho efi-framebuffer.0 &gt; /sys/bus/platform/drivers/efi-framebuffer/bindmodprobe nvidia_drmmodprobe nvidia_modesetmodprobe nvidia_uvmmodprobe nvidiasystemctl start lightdm 这些脚本需要在安装完系统后再设置，或者先换别的名字，不然安装的时候就会被执行，然后黑屏 这个就是单显卡的前提配置 系统安装及测试多显卡进行系统安装时可以直接把显卡设置进去 单显卡则不可以，需要先安装系统，如果显卡设置进去，那物理机也要用，虚拟机也要用，就会卡住 平时 Windows 在系统安装完成后会自动在系统更新那里帮用户安装好显卡驱动，但是显卡直通这种方式最好是手动进行安装，Windows 不一定识别得出来，安装完驱动后，一切都和正常使用就没什么区别了 const videojsid0c72bf9f081748cca9d63e6bea220ab3 = videojs('videojs-id-0c72bf9f-0817-48cc-a9d6-3e6bea220ab3', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://linweiyuan.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"KVM","slug":"KVM","permalink":"https://linweiyuan.github.io/tags/KVM/"},{"name":"QEMU","slug":"QEMU","permalink":"https://linweiyuan.github.io/tags/QEMU/"},{"name":"Nvidia","slug":"Nvidia","permalink":"https://linweiyuan.github.io/tags/Nvidia/"},{"name":"VirtIO","slug":"VirtIO","permalink":"https://linweiyuan.github.io/tags/VirtIO/"}]},{"title":"分布式相关实践","slug":"分布式相关实践","date":"2022-11-05T06:21:07.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2022/11/05/分布式相关实践.html","link":"","permalink":"https://linweiyuan.github.io/2022/11/05/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%AE%9E%E8%B7%B5.html","excerpt":"","text":"分布式 IDID 在大部分场景下，都是用来区分一条记录，因此天然要求唯一性，并且根据业务需求，有的还要求趋势递增。在单节点的数据库环境下，可以利用数据库自身具备的自增特性，比如 Oracle 的 sequence，MySQL 的 auto_increment，Postgres 的 serial 等，但是在分布式集群环境下，各个数据库都有自己维护的一套自增 ID，因此可能出现多个数据库都是 ID &#x3D; 1 的情况，这样就有问题，因此就有了分布式 ID，要求全局唯一，并且具备高性能高可用。下面是几种方案（不是全部） 数据库自增 ID抛开事实不谈，如果仅仅说实现方式，这也是一种方法。还是利用数据库的自增 ID 解决，不同的是要在集群前面额外搞一个实例充当“工具库”的角色，API 先从这里拿到最新自增 ID，在插入数据的时候顺便把这个 ID 也一起提交 缺点也是很明显，并且非常的非主流，正经人谁这么搞 UUIDUUID 实现起来非常简单，并且使用得当的话基本不会重复 12String uuid = UUID.randomUUID().toString(); // 36String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); // 32 但是如果有需求说 ID 里面需要反映一些有意义的东西，比如订单号、时间戳等，这种方法就不适用 有好处吗？有。这种 UUID 的方式在某种程度上可以防止一些越权的操作，比如 ID &#x3D; 1 是普通用户能看，ID &#x3D; 2 是超管才能看，那么如果 API 权限验证没处理好，可能普通用户就能看到超管的东西 坏处比好处多得多，比如 MySQL 特殊的数据结构，ID 在叶子节点上往往会有一个排序的操作，如果用 UUID，则每新增一条记录，都有可能会使得数据重新排序，影响性能 雪花算法推特开源，通过多少位的时间戳 + 多少位的机器 ID + 多少位的序列号组成，详细的去看别人的文章 GitHub 上源码 snowflake-2010 在 10 年前就不更新了，除非手动调整机器时间，正常使用基本也不会重复国内大厂则有其他类似的实现，比如百度的 UidGenerator、滴滴的 Tinyid、美团的 Leaf 基于 Redis主要用了 Redis 的 INCRBY 指令 1INCRBY key increment Redis 由于自身的单线程特点（高版本有多线程，但是是用来做其他事情的），里面的操作具备原子性，因此可以利用这条指令，每次增加 1，则可完成分布式 ID 的自增，并且不重复 但是还是老话，凡是引入了其他中间件，都要考虑高可用问题，让它们不要挂。如果 ID 增长了，但没来得及刷盘 Redis 就挂掉了，下次起来时，可能 ID 就会重复。这个时候往往需要 RDB + AOF 配合使用，RDB 保证实例启动的速度，AOF 则确保数据的一致性；还有就是一主二从三哨兵那一套 分布式事务单机事务的实现方式，通常是先把事务自动提交设置为 false，编写一堆逻辑，完了后手动 commit 或者 rollback分布式事务主流的还是阿里的 Seata Seata 里面有三个核心概念： Transaction Manager（事务管理器）：主要用来管理全局事务，需要单独部署一个 seata-server 的服务（支持 Nacos、Eureka、Redis、ZooKeeper 等多种注册中心，一般情况下，阿里系的东西多是配合 Nacos 使用，毕竟一家的），并且创建好全局事务和分支事务对应的表 Resource Manager（资源管理器）：主要用来管理分支事务 Transaction Coordinator（事务协调者）：类似警匪片中的谈判专家，维护全局事务和分支事务的状态，当事务提交或回滚的时候进行协调 Seata 里面还有四种分布式事务解决方案： AT：Seata 默认模式，分阶段提交事务，但是在第一阶段就提交分支事务，那么回滚要怎么回滚呢？需要额外创建表，来记录数据修改前的状态，回滚时则进行和事务提交时相反的操作，达到最终一致；第一阶段无需锁定数据库资源，和下面的 XA 相比，性能好一点 XA：也是分阶段提交事务，第一阶段各个分支事务先准备，然后看结果返回就绪还是失败，如果就绪则在第二阶段提交事务，失败则回滚。这种模式，一般数据库都自带支持，所以实现起来比较简单，无需编写额外的代码或者建表；但是 XA 偏 CP，在第一阶段需要锁定数据库资源，强调强一致性，因此和上面的 AT 相比，性能较差，还牺牲了一定的可用性 TCC：同样是分阶段提交事务，分为 Try-Confirm-Cancel 三个阶段，需要额外的代码来处理对应业务逻辑。这样一来，在第一阶段就直接提交事务，性能比 XA 好，同时数据是通过代码来完成回滚的，无需建额外的表，比 AT 简单，并且由于事务都是由自己的代码来完成，对于不支持事务的存储引擎也可以使用。缺点就是需要自己额外写代码，并且考虑处理失败的情况，对人的要求就比较高了 SAGA：还是分阶段提交事务，一阶段直接提交事务，二阶段如果失败则通过代码来进行补偿操作，成功则什么都不做 分布式事务，其实用得真不多，最多就是万一发生问题，通过日志排查来进行人工手动补偿，也有可能是用户量太少了，或 CRUD 做多了 分布式锁锁一般是用来解决多线程或者说高并发环境下共享变量的安全问题当只有一个实例的时候，可以使用 synchronized 或者 ReentrantLock 等来进行加锁操作，但在多实例下，每个 JVM 进程都是独立的，单机锁就达不到想要的效果，因此大多都是需要借助第三方的力量，来提供一个全局加锁的功能 以最经典的抢票为例，多个人抢固定数量的票，如果处理得不得当，就会发生超卖的现象，是个人都提示抢到票，但实际上你的票并没有这么多，因为多线程下，总票数被频繁修改，没有安全保障 下面是常见的其中几种分布式锁解决方案 MySQL 单条 update 语句如果 JVM 存在多个，但是 MySQL 只有一个，这种算分布式吗？ 当它算。由于 MySQL 只有一个，而 MySQL 在处理更新语句的时候，会默认进行一个加锁的操作，因此可以利用这种特性来充当分布式锁，比如下面的伪代码（不考虑边界问题） 1update 表 set 票数 = 票数 - 1; 当这个表存在多个列，并且需要充当查询条件的时候，需要注意索引的设置，比如 1update 表 set 票数 = 票数 - 1 where 目的地 = xxx; 此时如果目的地没有添加索引，MySQL 触发的是表锁，整个表都不可用，但是如果在目的地上添加了索引，则触发的会是行锁，仅仅锁住当前目的地的数据，这样就提高了性能 当然要正确使用查询条件，如果使用“目的地 !&#x3D; xxx”，那就算添加了索引，也会触发表锁，因为索引会失效这种方式仅仅适用简单的业务逻辑，如果想在修改票数前后添加一些额外的处理，就不行了 MySQL select for update 语句和上面的类似，只是执行 select for update 锁住了所查记录后，还可以进行一些额外的操作，完了后再执行 update 语句，相对来说就会更加灵活 缺点在后面跟着，复杂操作更要注意加解锁的处理，防止死锁 MySQL 乐观锁乐观锁的实现思想基本都来源于 CAS（Compare And Swap），当实际的值与预期的值一致，才将旧值更新成新值，否则就自旋，也就是循环（期间可以设置短时间的 sleep，减少 CPU 的无效操作）。最常见的落地方案就是数据库表加多一个 version 字段 先把 version 查出来，最后执行更新操作的时候再判断现在的 version 值是否和开始查到的是否一致，如果不一致，那就是被别人改过了，那就重新再拿一遍，再修改 虽然一般都说加锁是重量级的操作，但是这种 CAS 虽然不用加锁，但是好多循环，也会占用无谓的 CPU 资源，有时性能反而不如悲观锁，所以实际使用最好自己测试一下 Redis 乐观锁主要利用 Redis 的 WATCH + MULTI + EXEC 指令实现 当 WATCH 了某个 key，开启 MULTI 后，其他线程如果修改了这个 key 的值，那么最后执行 EXEC 的时候就会返回 nil，成功则返回 OK 这样就实现了类似 version 的效果，执行失败，自旋，然后重新执行即可 redis-cli 里是这三条指令，那么对应到 Java 代码里会是简单的三条相加吗？ 1234String key = &quot;&quot;;redisTemplate.watch(key);redisTemplate.multi();redisTemplate.exec(); 不是。如果按照上面的用法会报 ERR EXEC without MULTI，明明有 multi()，但为什么还是报这个错？因为用法不对，正确的用法是这样 123456789String key = &quot;&quot;;redisTemplate.execute(new SessionCallback&lt;&gt;() &#123; @Override public Object execute(RedisOperations operations) throws DataAccessException &#123; operations.watch(key); operations.multi(); return operations.exec(); &#125;&#125;); Redis 分布式锁利用 Redis 的 SETNX + DEL 指令实现，SETNX 进行 key 的设置的时候，如果这个 key 不存在，才会被设置，因此可以充当加锁操作；而解锁就仅仅需要把前面设置的 key 进行删除即可 SETNX 设置出来的属于独占锁（排他锁），一旦加锁成功，但是由于某些原因 API 挂了，这就会导致整个服务不可用，因为要解锁就必须先经过获取锁的那一步，而现在由于已经设置了锁，那就没办法再得到锁，因此没办法释放。所以需要给锁设置一个过期自动删除的时间 利用 Redis 的 EXPIRE 指令可以对 key 设置超时时间，完成上面的需求 Redis 还提供了 SETNX + EXPIRE 的组合指令，比如设置一个 10 秒过期的 key 1SET key value EX 10 NX 其中 EX 表示秒，可换成 PX 表示毫秒；NX 表示不存在才设置，可换成 XX 表示存在才设置。由于是一条指令，因此具备原子性，对应到 Java 代码里则是 1redisTemplate.opsForValue().set(key, value, 10, TimeUnit.SECONDS); 此时解决了一个问题，但是出现了新的问题 举个例子，假如 API 里设置了 10 秒过期自动释放锁，但是业务逻辑执行完需要 15 秒，此时执行到第 10 秒的时候，锁自动释放掉了，第二个线程拿到锁，但是前面的线程还没执行完，继续执行 5 秒后执行完毕，手动释放锁，这个时候的锁已经是第二个线程拿到的了，自己加的锁被别人释放了，这就有问题，因为释放锁的时候仅仅是执行一个删除 key 的操作，才不管这个锁是谁的 1redisTemplate.delete(key); 因此，需要加上一些判断，让自己的锁只有自己才能删 可能有人会想到说，既然要确保不能删除别人的锁，那是否让 key 每个线程不同就可以了？我删除的是 set 的时候生成的 key，如果删除了一个不存在的 key，就会失败，等于没删除 这也是正常人的思维，但是问题在于，每个 key 都不一样，起不到加锁的作用。因此不能在 key 上动手，而可以将矛盾转移到 value 上，比如 12345678String key = &quot;&quot;;String value = UUID.randomUUID().toString();redisTemplate.opsForValue().set(key, value, 10, TimeUnit.SECONDS);if (value.equals(redisTemplate.opsForValue().get(key))) &#123; redisTemplate.delete(key);&#125; 这样就解决了自己加的锁只能自己删的问题 但是又引出了新的问题 当第一个线程进入 if 代码块，准备执行 delete(key) 的时候，刚好到了过期时间，key 被删了，刚好此时切到第二个线程拿到锁准备执行业务代码，刚好又切回第一个线程继续执行删除操作，就又造成了第二个线程的锁被第一个线程删掉。尽管通过 UUID 来确保了唯一性，但是进入 if 后，delete 操作还是只看 key，不管 UUID 原因在于，if 和 delete 操作不具备原子性，要解决这个问题，就需要借助 Redis 的 EVAL 指令来执行 lua 脚本 Redis 里面的操作具备原子性，因此 EVAL 指令具备原子性，因此执行 lua 脚本的操作也具备原子性，因此就算在脚本里写 N 行代码，还是具备原子性，因此可以在里面进行一些较为复杂的业务逻辑编写，因此可以把上面的判断搬进 lua 脚本里 123456789String lua = &quot;&quot;&quot; if redis.call(&#x27;GET&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;DEL&#x27;, KEYS[1]) else return 0 end &quot;&quot;&quot;;redisTemplate.execute(new DefaultRedisScript&lt;&gt;(lua, Boolean.class), List.of(key), value); 这样就确保了自己的 key 只有自己能删 但是还是有其他问题在 如果一个请求里面执行的业务逻辑获取了锁，但是需要调用别的方法执行另外的逻辑，这个方法里面也要先获得锁才能执行，但是前面的操作已经获取过一次锁，既然在前面已经获取了锁，方法还没执行完就不会释放，这个时候调用另一个方法，这个方法又需要先获取锁才能执行，就出现了死锁。因此，对于同一个请求，要允许它重复获得锁，需要做一个可重入的处理，类似 ReentrantLock 要实现可重入，就需要记下来获取锁的次数，每次获取到锁，次数 +1，随着方法的调用完毕出栈 -1，最后减到 0 删除 key，达到释放锁的效果。如果用上面的数据结构，因为 value 是 UUID，因此可以在后面拼一个次数，比如 UUID:1，这样也是一种方法。但是 Redis 其实提供了一种更加合适的数据结构 Hash，用 HSET + HEXISTS + HINCRBY 指令可完成类似于对象的存储（不是那种文件的对象存储） 因为需要提前判断 key 是否存在，不存在则进行设置，存在则需要判断当前的锁是不是自己的，如果是则更新获取锁次数，逻辑较为复杂，因此可以借助 lua 脚本来完成 加锁 12345678910String lua = &quot;&quot;&quot; if redis.call(&#x27;EXISTS&#x27;, KEYS[1]) == 0 or redis.call(&#x27;HEXISTS&#x27;, KEYS[1], ARGV[1]) == 1 then redis.call(&#x27;HINCRBY&#x27;, KEYS[1], ARGV[1], 1) return 1 else return 0 end &quot;&quot;&quot;;redisTemplate.execute(new DefaultRedisScript&lt;&gt;(lua, Boolean.class), List.of(key), value); 解锁则进行相反的操作，当锁次数为 0 后，表示全部方法出栈，删除 key，否则就只是次数变化，加负数就是减法操作 123456789101112String lua = &quot;&quot;&quot; if redis.call(&#x27;HEXISTS&#x27;, KEYS[1], ARGV[1]) == 0 then return nil elseif redis.call(&#x27;HINCRBY&#x27;, KEYS[1], ARGV[1], -1) == 0 then return redis.call(&#x27;DEL&#x27;, KEYS[1]) else return 0 end &quot;&quot;&quot;;redisTemplate.execute(new DefaultRedisScript&lt;&gt;(lua, Boolean.class), List.of(key), value); 这样就完成了可重入锁的设置 但是还有问题 由于设置了过期自动删除 key，因此可能出现业务还没执行完，就自动释放了锁，因此需要确保在代码的执行过程中，通过一些额外的操作来使这个 key 自动续期，达到永不过期的效果。在这个条件下，一旦业务没完成，就会一直自动续期，那么还需要设置过期时间吗？ 需要。设置过期时间只是一个兜底的方案，理想情况下会是代码里进行加锁、解锁的操作，万一有故障发生，才会走超时自动释放锁的流程，防止死锁，所以两者并不冲突，反而相辅相成 为了完成这个操作，需要定期去判断 Redis 中是否还存在这个 key，存在则更新 key 的 TTL，最简单的就是利用 JDK 的 Timer，比如每隔 5 秒去更新下过期时间 12345678910111213141516171819private void updateTTL() &#123; String lua = &quot;&quot;&quot; if redis.call(&#x27;HEXISTS&#x27;, KEYS[1], ARGV[1]) == 1 then return redis.call(&#x27;EXPIRE&#x27;, KEYS[1], 10) else return 0 end &quot;&quot;&quot;; new Timer().schedule(new TimerTask() &#123; @Override public void run() &#123; boolean success = Boolean.TRUE.equals(redisTemplate.execute(new DefaultRedisScript&lt;&gt;(lua, Boolean.class), List.of(key), value)); if (success) &#123; updateTTL(); &#125; &#125; &#125;, 5 * 1000); // 只设置 delay，没设置 period，因此只是一次性任务，无需再额外进行 cancel() 操作&#125; 获取锁成功时，调用这个方法开启定时任务，后面就只需要递归调用，当锁释放时，由于定时器里面返回 false，因此也会自动结束 可重入锁，则也需要加上更新过期时间的逻辑处理，比如 10 秒 12redis.call(&#x27;HINCRBY&#x27;, KEYS[1], ARGV[1], 1)redis.call(&#x27;EXPIRE&#x27;, KEYS[1], 10) 这样就完成了自动续期，基本上满足大部分业务需求 Redlock也直译成红锁，官方的一种 Redis 集群下的实现方式，文档：Distributed Locks with Redis 在集群的情况下，Redis 会分为主从节点，因为主从节点之间同步数据需要花费一定的时间，因此如果 API 在主节点中获取了锁，数据还没来得及同步到从节点，主节点挂了，哨兵机制会将从节点升级为主节点，如果 API 也是集群部署，则可能导致另一个实例能重新获取到新的锁，导致分布式锁失效 红锁的实现原理，简单来说就是，当获取锁的时候，从每个节点上都利用相同的 key 去获取，当超过 3 个以上节点获取锁成功（建议 5 个节点），才算成功。如果某个节点获取失败，则跳过，防止阻塞。另外再对在获取锁的过程中，和锁自动释放的时间进行一个处理，详细的话自己去看文档 Redisson别人封装好的，用起来比较简单 其实去看里面的代码，核心部分也是通过 lua 脚本，和上面的差不多，只不过会做了一些不太容易看懂的优化，性能会更好，还有一些公平锁非公平锁的处理，比如 123456789101112131415161718192021222324252627282930313233&lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&lt;T&gt; command) &#123; return evalWriteAsync(getRawName(), LongCodec.INSTANCE, command, &quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot; + &quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot; + &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; + &quot;return nil; &quot; + &quot;end; &quot; + &quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot; + &quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot; + &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; + &quot;return nil; &quot; + &quot;end; &quot; + &quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;, Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));&#125;protected RFuture&lt;Boolean&gt; unlockInnerAsync(long threadId) &#123; return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, &quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot; + &quot;return nil;&quot; + &quot;end; &quot; + &quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot; + &quot;if (counter &gt; 0) then &quot; + &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot; + &quot;return 0; &quot; + &quot;else &quot; + &quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot; + &quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot; + &quot;return 1; &quot; + &quot;end; &quot; + &quot;return nil;&quot;, Arrays.asList(getRawName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));&#125; 有比较丰富的中文文档：目录 ZooKeeperZooKeeper 的 ZNodes 在设计上来说就是不可重复的，并且 ZooKeeper 偏向 CP，强调数据的一致性； ZooKeeper 提供了监听节点的机制；ZooKeeper 可以创建临时顺序节点；上面种种特性加起来，也是很适合用来做分布式锁 当有请求要获取锁的时候，给它创建一个临时顺序节点，并且监听上一个节点，如果上一个节点没了，表明自己是最前上面的，表示获取锁成功，业务执行完毕后删除节点释放锁，这样下一个节点监听到，它就能获取锁，以此类推，直到所有请求处理完成 由于用了顺序节点，每个请求都会创建不同的节点，删除的时候就不会出现误删的情况 可重入锁的实现思想和其他的也类似，也是记录下线程（也就是当前请求）相关的东西，进行 +1、-1 的操作。线程隔离的东西就可以考虑使用 ThreadLocal 而临时节点天然防死锁，当创建一个临时节点时，如果 API 挂了，API 与 ZooKeeper 之间的连接就会断开，而 ZooKeeper 检测到连接断开，就会自动将临时节点删除 Curator别人封装好的 ZooKeeper 客户端 未完待续 相关链接：分布式相关理论","categories":[{"name":"架构设计","slug":"架构设计","permalink":"https://linweiyuan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"分布式ID","slug":"分布式ID","permalink":"https://linweiyuan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8FID/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://linweiyuan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"name":"分布式事务","slug":"分布式事务","permalink":"https://linweiyuan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"}]},{"title":"自定义starter处理异常和请求响应日志","slug":"自定义starter处理异常和请求响应日志","date":"2022-10-15T17:35:34.000Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"2022/10/15/自定义starter处理异常和请求响应日志.html","link":"","permalink":"https://linweiyuan.github.io/2022/10/15/%E8%87%AA%E5%AE%9A%E4%B9%89starter%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E5%92%8C%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%97%A5%E5%BF%97.html","excerpt":"","text":"GitHub: https://github.com/linweiyuan/logger-spring-boot-starter 准备git clone https://github.com/linweiyuan/logger-spring-boot-starter.git ./gradlew publishToMavenLocal（其实如果没有特殊的自定义构建脚本需求，感觉 maven 好很多，没有奇奇怪怪的问题） 依赖处理12345&lt;dependency&gt; &lt;groupId&gt;com.linweiyuan&lt;/groupId&gt; &lt;artifactId&gt;logger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt;&lt;/dependency&gt; 异常日志处理启动类（或者其他叫法）添加 @EnableExceptionLog 注解 如果使用 @EnableExceptionLog(allowOverride = true)，注解上的配置就会失效，以配置文件为准，可以方便的进行修改而无需重新编译 支持如下属性 123456789linweiyuan.logger.exception.border-color=#fffffflinweiyuan.logger.exception.border-background-color=#fffffflinweiyuan.logger.exception.border-blink=truelinweiyuan.logger.exception.text-color=#fffffflinweiyuan.logger.exception.text-background-color=#fffffflinweiyuan.logger.exception.text-bold=falselinweiyuan.logger.exception.text-italic=falselinweiyuan.logger.exception.text-blink=truelinweiyuan.logger.exception.empty-space-background-color=#ffffff 123456789101112linweiyuan: logger: exception: border-color: &quot;#ffffff&quot; border-background-color: &quot;#ffffff&quot; border-blink: true text-color: &quot;#ffffff&quot; text-background-color: &quot;#ffffff&quot; text-bold: false text-italic: false text-blink: true empty-space-background-color: &quot;#ffffff&quot; 如果使用 @EnableExceptionLog(showAll = true)，则会打印全部异常堆栈（默认是 false，也就是只打印注解所在类的包相关，Spring 一堆业务无关的不打印） 注解支持属性 12345678910111213@EnableExceptionLog( showAll = true, borderColor = &quot;#ffffff&quot;, borderBackgroundColor = &quot;#ffffff&quot;, borderBlink = true, textColor = &quot;#ffffff&quot;, textBackgroundColor = &quot;#ffffff&quot;, textBold = true, textItalic = true, textBlink = true, emptySpaceBackgroundColor = &quot;#ffffff&quot;, allowOverride = true) 请求响应日志这个不支持配置文件配置，只能在注解上进行 注解支持属性 q 123456789101112@EnableExceptionLog( borderColor = &quot;#ffffff&quot;, borderBackgroundColor = &quot;#ffffff&quot;, borderBlink = true, textColor = &quot;#ffffff&quot;, textBackgroundColor = &quot;#ffffff&quot;, textBold = true, textItalic = true, textBlink = true, emptySpaceBackgroundColor = &quot;#ffffff&quot;, useDefaultColor = true) 如果使用 @EnableExceptionLog(useDefaultColor = true)，则以下默认配置会生效 响应码 颜色 2xx 绿 4xx 黄 5xx 红 但是只有 API 返回的是 ResponseEntity 才会生效，试过用 HttpServletResponse，获取的响应码全是 200，可能还要再看看 const videojsidf7e0dbb56d2a4291b2c546501fe86df0 = videojs('videojs-id-f7e0dbb5-6d2a-4291-b2c5-46501fe86df0', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"Kotlin","slug":"程序设计/Kotlin","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://linweiyuan.github.io/tags/Kotlin/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://linweiyuan.github.io/tags/Spring-Boot/"},{"name":"Spring Boot Starter","slug":"Spring-Boot-Starter","permalink":"https://linweiyuan.github.io/tags/Spring-Boot-Starter/"}]},{"title":"Go+React实现一个基础的前后端分离问卷功能","slug":"Go-React实现一个基础的前后端分离问卷功能","date":"2022-10-05T04:13:39.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2022/10/05/Go-React实现一个基础的前后端分离问卷功能.html","link":"","permalink":"https://linweiyuan.github.io/2022/10/05/Go-React%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%97%AE%E5%8D%B7%E5%8A%9F%E8%83%BD.html","excerpt":"","text":"效果图 后端前期准备取一个随便点的名字 1234mkdir goquestionapicd goquestionapigit initgo mod init github.com/linweiyuan/goquestionapi 这里和数据库相关的操作会使用两个工具，migrate 和 sqlc，可以用 go 的方式安装，但这边习惯用 pacman，因为包升级好管理 12sudo pacman -S sqlcyay -S migrate sqlc 是一个代码生成工具，生成的代码中连接数据库的部分用的是 Golang 原生 sql 库，性能极高（官方是这样说的） 为什么不用 GORM，因为由于多年 Java 开发经验先入为主，看到 GORM 的 API 好多时候会觉得莫名其妙，尝试过几遍，都弃坑了，并且据说有性能问题 sqlc 可以通过编写简单的 SQL 语句，来自动生成模板代码，那么只需要关注具体的业务逻辑即可，并且可以通过 sqlc.arg() 的方式给占位符起别名，使用起来比较顺手 数据库用的是 Postgres 对于这种一个问题多个答案，一对多的结构，其实我自己比较喜欢用 JSON 字段 为什么不直接用 MongoDB？其实工作多年接触的项目，只用过一次，不是很熟悉 为什么不用 MySQL？ 1234CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS2057f98237b3 postgres 0.02% 28.57MiB / 15.49GiB 0.18% 3.03kB / 0B 0B / 43.4MB 725959b7d7133 mysql 0.27% 159.5MiB / 15.49GiB 1.01% 6.85kB / 0B 115kB / 259MB 39ef2ecd22745f mongo 0.30% 68.66MiB / 15.49GiB 0.43% 8.25kB / 0B 4.1kB / 1.29MB 33 如果开了 performance_schema 呢（默认是开） 12CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDSbb4ba1c34299 mysql 0.26% 383MiB / 15.49GiB 2.42% 2.5kB / 0B 115kB / 247MB 39 练手而已 目前所在公司，新项目也纷纷上 Postgres，不涉及到那些储存过程函数之类，转换下 database schema 概念，其实用起来都没什么区别 准备数据，数据是从网上拿的，主要是一些问题，然后对应的选项写死了分值，最后根据总分来判断性格（性格测试这东西我本人觉得极为扯淡，有些公司面试还要做，莫名其妙，如果我所在公司也要做，那我前面什么都没说，这个测试好得很，必须做） 数据准备好，就可以导入数据库，这里用的是 migrate，所以先准备第一版的 SQL sqlc 配置文件 123456789version: &quot;2&quot;sql: - engine: &quot;postgresql&quot; schema: &quot;sqlc/migration&quot; queries: &quot;sqlc/query&quot; gen: go: package: &quot;sqlc&quot; out: &quot;sqlc&quot; schema 是数据库建表、删表语句，queries 是业务 SQL 的编写地方，然后 package 是生成的 go 代码的包名，out 就是代码生成的文件夹 1migrate create -ext sql -dir sqlc/migration -seq init migrate 参数： -ext: 数据脚本扩展名（后缀名） -dir: 脚本文件所在地，配合上面 sqlc 的配置文件就是在 sqlc&#x2F;migration 里 -seq: 就是一个 sequence，自增 最后是文件名字 上面的命令就会生成 000001_init.down.sql 和 000001_init.up.sql 这两个文件，up 就是新改动，down 就是回滚，和别的数据库 migration 一样 首先需要先创建 schema，这里 schema 叫 question，表也叫 question（表则可以在 migration sql 里创建） 创建好 schema 之后 migrate 和 sqlc 才会好使，不然会有先有鸡还是先有蛋的问题 1CREATE SCHEMA question; 准备 up sql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255CREATE TABLE question ( id SERIAL PRIMARY KEY NOT NULL, title VARCHAR NOT NULL, answer JSON NOT NULL, score JSON NOT NULL );INSERT INTO question (title, answer, score)VALUES ( &#x27;你更喜欢吃那种水果&#x27;, &#x27;&#123; &quot;A&quot;: &quot;草莓&quot;, &quot;B&quot;: &quot;苹果&quot;, &quot;C&quot;: &quot;西瓜&quot;, &quot;D&quot;: &quot;菠萝&quot;, &quot;E&quot;: &quot;橘子&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 2, &quot;B&quot;: 3, &quot;C&quot;: 5, &quot;D&quot;: 10, &quot;E&quot;: 15&#125;&#x27; ), ( &#x27;你平时休闲经常去的地方&#x27;, &#x27;&#123; &quot;A&quot;: &quot;郊外&quot;, &quot;B&quot;: &quot;电影院&quot;, &quot;C&quot;: &quot;公园&quot;, &quot;D&quot;: &quot;商场&quot;, &quot;E&quot;: &quot;酒吧&quot;, &quot;F&quot;: &quot;练歌房&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 2, &quot;B&quot;: 3, &quot;C&quot;: 5, &quot;D&quot;: 10, &quot;E&quot;: 15, &quot;F&quot;: 20&#125;&#x27; ), ( &#x27;你认为容易吸引你的人是&#x27;, &#x27;&#123; &quot;A&quot;: &quot;有才气的人&quot;, &quot;B&quot;: &quot;依赖你的人&quot;, &quot;C&quot;: &quot;优雅的人&quot;, &quot;D&quot;: &quot;善良的人&quot;, &quot;E&quot;: &quot;性情豪放的人&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 2, &quot;B&quot;: 3, &quot;C&quot;: 5, &quot;D&quot;: 10, &quot;E&quot;: 15&#125;&#x27; ), ( &#x27;如果你可以成为一种动物，你希望自己是哪种&#x27;, &#x27;&#123; &quot;A&quot;: &quot;猫&quot;, &quot;B&quot;: &quot;马&quot;, &quot;C&quot;: &quot;大象&quot;, &quot;D&quot;: &quot;猴子&quot;, &quot;E&quot;: &quot;狗&quot;, &quot;F&quot;: &quot;狮子&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 2, &quot;B&quot;: 3, &quot;C&quot;: 5, &quot;D&quot;: 10, &quot;E&quot;: 15, &quot;F&quot;: 20&#125;&#x27; ), ( &#x27;天气很热，你更愿意选择什么方式解暑&#x27;, &#x27;&#123; &quot;A&quot;: &quot;游泳&quot;, &quot;B&quot;: &quot;喝冷饮&quot;, &quot;C&quot;: &quot;开空调&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 5, &quot;B&quot;: 10, &quot;C&quot;: 15&#125;&#x27; ), ( &#x27;如果必须与一个你讨厌的动物或昆虫在一起生活，你能容忍哪一个&#x27;, &#x27;&#123; &quot;A&quot;: &quot;蛇&quot;, &quot;B&quot;: &quot;猪&quot;, &quot;C&quot;: &quot;老鼠&quot;, &quot;D&quot;: &quot;苍蝇&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 2, &quot;B&quot;: 5, &quot;C&quot;: 10, &quot;D&quot;: 15&#125;&#x27; ), ( &#x27;你喜欢看哪类电影、电视剧&#x27;, &#x27;&#123; &quot;A&quot;: &quot;悬疑推理类&quot;, &quot;B&quot;: &quot;童话神话类&quot;, &quot;C&quot;: &quot;自然科学类&quot;, &quot;D&quot;: &quot;伦理道德类&quot;, &quot;E&quot;: &quot;战争枪战类&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 2, &quot;B&quot;: 3, &quot;C&quot;: 5, &quot;D&quot;: 10, &quot;E&quot;: 15&#125;&#x27; ), ( &#x27;以下哪个是你身边必带的物品&#x27;, &#x27;&#123; &quot;A&quot;: &quot;打火机&quot;, &quot;B&quot;: &quot;口红&quot;, &quot;C&quot;: &quot;记事本&quot;, &quot;D&quot;: &quot;纸巾&quot;, &quot;E&quot;: &quot;手机&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 2, &quot;B&quot;: 2, &quot;C&quot;: 3, &quot;D&quot;: 5, &quot;E&quot;: 10&#125;&#x27; ), ( &#x27;你出行时喜欢坐什么交通工具&#x27;, &#x27;&#123; &quot;A&quot;: &quot;火车&quot;, &quot;B&quot;: &quot;自行车&quot;, &quot;C&quot;: &quot;汽车&quot;, &quot;D&quot;: &quot;飞机&quot;, &quot;E&quot;: &quot;步行&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 2, &quot;B&quot;: 3, &quot;C&quot;: 5, &quot;D&quot;: 10, &quot;E&quot;: 15&#125;&#x27; ), ( &#x27;以下颜色你更喜欢哪种&#x27;, &#x27;&#123; &quot;A&quot;: &quot;紫&quot;, &quot;B&quot;: &quot;黑&quot;, &quot;C&quot;: &quot;蓝&quot;, &quot;D&quot;: &quot;白&quot;, &quot;E&quot;: &quot;黄&quot;, &quot;F&quot;: &quot;红&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 2, &quot;B&quot;: 3, &quot;C&quot;: 5, &quot;D&quot;: 8, &quot;E&quot;: 12, &quot;F&quot;: 15&#125;&#x27; ), ( &#x27;下列运动中挑选一个你最喜欢的（不一定擅长）&#x27;, &#x27;&#123; &quot;A&quot;: &quot;瑜珈&quot;, &quot;B&quot;: &quot;自行车&quot;, &quot;C&quot;: &quot;乒乓球&quot;, &quot;D&quot;: &quot;拳击&quot;, &quot;E&quot;: &quot;足球&quot;, &quot;F&quot;: &quot;蹦极&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 2, &quot;B&quot;: 3, &quot;C&quot;: 5, &quot;D&quot;: 8, &quot;E&quot;: 10, &quot;F&quot;: 15&#125;&#x27; ), ( &#x27;如果你拥有一座别墅，你认为它应当建立在哪里&#x27;, &#x27;&#123; &quot;A&quot;: &quot;湖边&quot;, &quot;B&quot;: &quot;草原&quot;, &quot;C&quot;: &quot;海边&quot;, &quot;D&quot;: &quot;森林&quot;, &quot;E&quot;: &quot;城中区&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 2, &quot;B&quot;: 3, &quot;C&quot;: 5, &quot;D&quot;: 10, &quot;E&quot;: 15&#125;&#x27; ), ( &#x27;你更喜欢以下哪种天气现象&#x27;, &#x27;&#123; &quot;A&quot;: &quot;雪&quot;, &quot;B&quot;: &quot;风&quot;, &quot;C&quot;: &quot;雨&quot;, &quot;D&quot;: &quot;雾&quot;, &quot;E&quot;: &quot;雷电&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 2, &quot;B&quot;: 3, &quot;C&quot;: 5, &quot;D&quot;: 10, &quot;E&quot;: 15&#125;&#x27; ), ( &#x27;你希望自己的窗口在一座30层大楼的第几层&#x27;, &#x27;&#123; &quot;A&quot;: &quot;七层&quot;, &quot;B&quot;: &quot;一层&quot;, &quot;C&quot;: &quot;二十三层&quot;, &quot;D&quot;: &quot;十八层&quot;, &quot;E&quot;: &quot;三十层&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 2, &quot;B&quot;: 3, &quot;C&quot;: 5, &quot;D&quot;: 10, &quot;E&quot;: 15&#125;&#x27; ), ( &#x27;你认为自己更喜欢在以下哪一个城市中生活&#x27;, &#x27;&#123; &quot;A&quot;: &quot;丽江&quot;, &quot;B&quot;: &quot;拉萨&quot;, &quot;C&quot;: &quot;昆明&quot;, &quot;D&quot;: &quot;西安&quot;, &quot;E&quot;: &quot;杭州&quot;, &quot;F&quot;: &quot;北京&quot;&#125;&#x27;, &#x27;&#123; &quot;A&quot;: 1, &quot;B&quot;: 3, &quot;C&quot;: 5, &quot;D&quot;: 8, &quot;E&quot;: 10, &quot;F&quot;: 15&#125;&#x27; ); 1migrate -path sqlc/migration -database &quot;postgresql://postgres:postgres@localhost:5432/postgres?sslmode=disable&amp;search_path=question&quot; -verbose up down sql 1DROP TABLE question; 同理 1migrate -path sqlc/migration -database &quot;postgresql://postgres:postgres@localhost:5432/postgres?sslmode=disable&amp;search_path=question&quot; -verbose down 接着就是编写获取问题列表的 SQL 123-- name: GetQuestions :manySELECT q.id, q.title, q.answer FROM question q ORDER BY q.id; 根据 sqlc 的规范，-- name: 方法名，这些空格都是必须的，如果返回一条数据就 :one，多条则 :many，如果只是增删，可以用 :exec 执行 sqlc generate 这样就会生成好几个 go 文件，其中生成的方法类似 123func (q *Queries) GetQuestions(ctx context.Context) ([]GetQuestionsRow, error) &#123; ...&#125; 但是每次都要输入这么长的命令，虽然可以键盘上下，但是有更好的方法，就是 Makefile 12345678910up: migrate -path sqlc/migration -database &quot;postgresql://postgres:postgres@localhost:5432/postgres?sslmode=disable&amp;search_path=question&quot; -verbose updown: migrate -path sqlc/migration -database &quot;postgresql://postgres:postgres@localhost:5432/postgres?sslmode=disable&amp;search_path=question&quot; -verbose downgen: sqlc generate.PHONY: up down gen .PHONY 的作用就是确保执行的是这里定义的命令，比如 Makefile 里定义个 ls，如果不加到 .PHONY 里，则执行的是系统的 ls 编写业务逻辑定义配置类，用到了 viper，有一个好处就是 AutomaticEnv() 能够将环境变量覆盖掉代码配置，这样在部署的时候非常方便，日志则用了 logrus，可以设置不同的级别，还有颜色输出，Java 过来表示很亲切 1234567891011121314151617181920212223242526272829303132333435363738394041424344package utilimport ( log &quot;github.com/sirupsen/logrus&quot; &quot;github.com/spf13/viper&quot;)const ( configFileName = &quot;app&quot; configFileSuffix = &quot;env&quot;)type Config struct &#123; ServerPort string `mapstructure:&quot;SERVER_PORT&quot;` DBDriver string `mapstructure:&quot;DB_DRIVER&quot;` DBSource string `mapstructure:&quot;DB_SOURCE&quot;` LogLevel string `mapstructure:&quot;LOG_LEVEL&quot;`&#125;func LoadConfig(path string) (config Config) &#123; viper.AddConfigPath(path) viper.SetConfigName(configFileName) viper.SetConfigType(configFileSuffix) viper.AutomaticEnv() if err := viper.ReadInConfig(); err != nil &#123; log.Fatalf(&quot;failed to load config file: [%v]&quot;, err) &#125; if err := viper.Unmarshal(&amp;config); err != nil &#123; log.Fatalf(&quot;failed to parse config file: [%v]&quot;, err) &#125; logLevel, err := log.ParseLevel(config.LogLevel) if err != nil &#123; log.Fatalf(&quot;failed to get log level: [%v]&quot;, err) &#125; log.SetLevel(logLevel) return&#125; 然后就可以开启调试了，可以 build 或者直接 run，或者用其他热加载的工具，这里用到了 gowatch 直接执行 gowatch 就可以将终端晾在一边了，和前端开发的体验没什么区别，Java 就要重启，没用过 JRebel 此时访问本地 8080 就能得到 404 的正确响应了 接着加一个 CORS 的中间件，这里不加，前端就要 proxy 123456789101112131415161718192021222324package middlewareimport ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot; log &quot;github.com/sirupsen/logrus&quot;)func CORS() gin.HandlerFunc &#123; return func(ctx *gin.Context) &#123; log.Debug(&quot;handle cors...&quot;) ctx.Writer.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;) ctx.Writer.Header().Set(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;) if ctx.Request.Method == http.MethodOptions &#123; ctx.AbortWithStatus(http.StatusNoContent) return &#125; ctx.Next() &#125;&#125; 给 server 加上 1server.Use(middleware.CORS()) API 1234567891011121314151617181920212223242526272829303132package apiimport ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot; &quot;github.com/linweiyuan/goquestionapi/sqlc&quot; log &quot;github.com/sirupsen/logrus&quot;)type QuestionAPI struct &#123; db *sqlc.Queries&#125;func NewQuestionAPI(db *sqlc.Queries) *QuestionAPI &#123; return &amp;QuestionAPI&#123;db&#125;&#125;func (api *QuestionAPI) GetQuestions(ctx *gin.Context) &#123; questions, err := api.db.GetQuestions(ctx) if err != nil &#123; log.Errorf(&quot;failed to get questions: [%v]&quot;, err) ctx.JSON(http.StatusInternalServerError, gin.H&#123; &quot;error&quot;: err.Error(), &#125;) return &#125; ctx.JSON(http.StatusOK, gin.H&#123; &quot;questions&quot;: questions, &#125;)&#125; 路由配置 12345678910111213141516171819package routerimport ( &quot;github.com/gin-gonic/gin&quot; &quot;github.com/linweiyuan/goquestionapi/api&quot;)type QuestionRouter struct &#123; api *api.QuestionAPI&#125;func NewQuestionRouter(api *api.QuestionAPI) *QuestionRouter &#123; return &amp;QuestionRouter&#123;api&#125;&#125;func (router *QuestionRouter) Setup(routerGroup *gin.RouterGroup) &#123; group := routerGroup.Group(&quot;/questions&quot;) group.GET(&quot;&quot;, router.api.GetQuestions)&#125; 给 server 加上，并且让其具有查询 db 的功能 123456789sqlDB, err := sql.Open(config.DBDriver, config.DBSource)if err != nil &#123; log.Fatalf(&quot;failed to connect to DB: [%v]&quot;, err)&#125;db := sqlc.New(sqlDB)rg := server.Group(&quot;/&quot;)router.NewQuestionRouter(api.NewQuestionAPI(db)).Setup(rg) 需要注意一点就是，要让 db 的驱动执行初始化动作 1import _ &quot;github.com/lib/pq&quot; 接着再访问 http://localhost:8080/questions，就能看到数据 12345678910111213141516171819202122232425262728&#123; &quot;questions&quot;: [ &#123; &quot;ID&quot;: 1, &quot;Title&quot;: &quot;你更喜欢吃那种水果&quot;, &quot;Answer&quot;: &#123; &quot;A&quot;: &quot;草莓&quot;, &quot;B&quot;: &quot;苹果&quot;, &quot;C&quot;: &quot;西瓜&quot;, &quot;D&quot;: &quot;菠萝&quot;, &quot;E&quot;: &quot;橘子&quot; &#125; &#125;, ... &#123; &quot;ID&quot;: 15, &quot;Title&quot;: &quot;你认为自己更喜欢在以下哪一个城市中生活&quot;, &quot;Answer&quot;: &#123; &quot;A&quot;: &quot;丽江&quot;, &quot;B&quot;: &quot;拉萨&quot;, &quot;C&quot;: &quot;昆明&quot;, &quot;D&quot;: &quot;西安&quot;, &quot;E&quot;: &quot;杭州&quot;, &quot;F&quot;: &quot;北京&quot; &#125; &#125; ]&#125; 但是 json 的 key 全部大写了，可以在 sqlc 上配置 emit_json_tags，修改后的配置 12345678910version: &quot;2&quot;sql: - engine: &quot;postgresql&quot; schema: &quot;sqlc/migration&quot; queries: &quot;sqlc/query&quot; gen: go: package: &quot;sqlc&quot; out: &quot;sqlc&quot; emit_json_tags: true 再重新跑一遍 make gen，再刷新页面，就能拿到小写的 key，比较符合习惯 12345678910111213141516171819202122232425262728&#123; &quot;questions&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;你更喜欢吃那种水果&quot;, &quot;answer&quot;: &#123; &quot;A&quot;: &quot;草莓&quot;, &quot;B&quot;: &quot;苹果&quot;, &quot;C&quot;: &quot;西瓜&quot;, &quot;D&quot;: &quot;菠萝&quot;, &quot;E&quot;: &quot;橘子&quot; &#125; &#125;, ... &#123; &quot;id&quot;: 15, &quot;title&quot;: &quot;你认为自己更喜欢在以下哪一个城市中生活&quot;, &quot;answer&quot;: &#123; &quot;A&quot;: &quot;丽江&quot;, &quot;B&quot;: &quot;拉萨&quot;, &quot;C&quot;: &quot;昆明&quot;, &quot;D&quot;: &quot;西安&quot;, &quot;E&quot;: &quot;杭州&quot;, &quot;F&quot;: &quot;北京&quot; &#125; &#125; ]&#125; 至此获取问题列表 API 完成，接着是答题然后计算分数 这里用到下面的数据结构进行提交，思路还是逐条拿分数出来再叠加，没有太多花里胡哨的 SQL 123456789&#123; &quot;answers&quot;: &#123; &quot;1&quot;: &quot;A&quot;, &quot;2&quot;: &quot;B&quot;, ... &quot;15&quot;: &quot;C&quot; &#125;&#125; 于是根据题目拿分数的 SQL 就会是 1234567-- name: GetQuestionScoreByID :oneSELECT ( q.score -&gt;&gt; sqlc.arg(answer) :: TEXT ) :: INT AS scoreFROM question qWHERE q.id = sqlc.arg(id); 这里可以用 $1，$2 等的占位符，不过用 sqlc.arg() 就会更加顾名思义一些 再执行 make gen，生成新代码 接着编写完答题 API （练手而已，没有太多封装） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253type answersRequest struct &#123; Answers json.RawMessage `json:&quot;answers&quot;`&#125;func (api *QuestionAPI) HandleAnswers(ctx *gin.Context) &#123; var req answersRequest err := ctx.ShouldBindJSON(&amp;req) if err != nil &#123; log.Errorf(&quot;failed to bind answers json: [%v]&quot;, err) ctx.JSON(http.StatusBadRequest, util.HandleError(err)) return &#125; totalScore := 0 questionAnswerMap := make(map[int]string) json.Unmarshal(req.Answers, &amp;questionAnswerMap) for questionID, answer := range questionAnswerMap &#123; getAnswerMappingParams := sqlc.GetQuestionScoreByIDParams&#123; Answer: answer, ID: int32(questionID), &#125; score, err := api.db.GetQuestionScoreByID(ctx, getAnswerMappingParams) if err != nil &#123; log.Errorf(&quot;failed to get answer score, questionID: [%d], answer: [%s]&quot;, questionID, answer) ctx.JSON(http.StatusInternalServerError, util.HandleError(err)) return &#125; totalScore += int(score) &#125; var result string switch &#123; case totalScore &gt;= 180: result = &quot;意志力强，头脑冷静，有较强的领导欲，事业心强，不达目的不罢休。外表和善，内心自傲，对有利于自己的人际关系比较看重，有时显得性格急噪，咄咄逼人，得理不饶人，不利于自己时顽强抗争，不轻易认输。思维理性，对爱情和婚姻的看法很现实，对金钱的欲望一般。&quot; case totalScore &gt;= 140 &amp;&amp; totalScore &lt; 179: result = &quot;聪明，性格活泼，人缘好，善于交朋友，心机较深。事业心强，渴望成功。思维较理性，崇尚爱情，但当爱情与婚姻发生冲突时会选择有利于自己的婚姻。金钱欲望强烈。&quot; case totalScore &gt;= 100 &amp;&amp; totalScore &lt; 139: result = &quot;爱幻想，思维较感性，以是否与自己投缘为标准来选择朋友。性格显得较孤傲，有时较急噪，有时优柔寡断。事业心较强，喜欢有创造性的工作，不喜欢按常规办事。性格倔强，言语犀利，不善于妥协。崇尚浪漫的爱情，但想法往往不切合实际。金钱欲望一般。&quot; case totalScore &gt;= 70 &amp;&amp; totalScore &lt; 99: result = &quot;好奇心强，喜欢冒险，人缘较好。事业心一般，对待工作，随遇而安，善于妥协。善于发现有趣的事情，但耐心较差，敢于冒险，但有时较胆小。渴望浪漫的爱情，但对婚姻的要求比较现实。不善理财。&quot; case totalScore &gt;= 40 &amp;&amp; totalScore &lt; 69: result = &quot;性情温良，重友谊，性格塌实稳重，但有时也比较狡黠。事业心一般，对本职工作能认真对待，但对自己专业以外事物没有太大兴趣，喜欢有规律的工作和生活，不喜欢冒险，家庭观念强，比较善于理财。&quot; default: result = &quot;散漫，爱玩，富于幻想。聪明机灵，待人热情，爱交朋友，但对朋友没有严格的选择标准。事业心较差，更善于享受生活，意志力和耐心都较差，我行我素。有较好的异性缘，但对爱情不够坚持认真，容易妥协。没有财产观念。&quot; &#125; ctx.JSON(http.StatusOK, gin.H&#123; &quot;totalScore&quot;: totalScore, &quot;result&quot;: result, &#125;)&#125; 配置下路由 1group.POST(&quot;&quot;, router.api.HandleAnswers) 简单测试能得到结果 1234&#123; &quot;result&quot;: &quot;散漫，爱玩，富于幻想。聪明机灵，待人热情，爱交朋友，但对朋友没有严格的选择标准。事业心较差，更善于享受生活，意志力和耐心都较差，我行我素。有较好的异性缘，但对爱情不够坚持认真，容易妥协。没有财产观念。&quot;, &quot;totalScore&quot;: 32&#125; 此时 API 就完成了，接着就是部署 部署如果按照其他语言，一般都是 FROM 一个官方的基础镜像，然后在上面再进行构建，这样就有第一种 12FROM FROM golang:alpine... 这样出来的镜像是很大的，因为 golang 的 alpine 镜像本身就很大了 12REPOSITORY TAG IMAGE ID CREATED SIZEgolang alpine 5dd973625d31 4 weeks ago 352MB 而由于 go 本身特点，可以编译出来一个摆脱其他束缚的二进制文件，因此可以直接上 alpine 123456FROM alpineWORKDIR /appCOPY goquestionapi .EXPOSE 8080CMD [ &quot;/app/goquestionapi&quot; ] 123CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build .docker build -t goquestionapi . 这样 build 出来的程序有 13M，还可以再优化下，-s 可以去掉符号表，-w 可以去掉调试信息 1CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=&quot;-w -s&quot; . 这样 build 出来的程序只有 8.5M 跑下镜像测试下 1docker run --rm -p 8080:8080 -e DB_SOURCE=&quot;postgresql://postgres:postgres@192.168.31.60:5432/postgres?sslmode=disable&amp;search_path=question&quot; -d goquestionapi 访问正常拿到数据 此时 docker 镜像大小为 14.4M 12REPOSITORY TAG IMAGE ID CREATED SIZEgoquestionapi latest 109360c6fafd 6 minutes ago 14.4MB 上面说了，由于 go 自身的特性，如果没有额外的需求，还可以用 scratch 镜像，只是这样就不能 sh 进去容器，如果有访问外网的需求，也会报 SSL 证书错误，又或者时区的问题，因为里面确实什么都没有 这个 scratch 感觉更像是一个概念，不是实际可以摸到的东西，因为如果像其他镜像那样 pull 的话，会报错 1234docker pull scratchUsing default tag: latestError response from daemon: &#x27;scratch&#x27; is a reserved name 这样 build 出来的镜像大小就又小了些 12REPOSITORY TAG IMAGE ID CREATED SIZEgoquestionapi latest 7ac80b2a1ad0 3 seconds ago 8.86MB 但是为了后续方便 sh 进去，还是习惯用 alpine，也不差那几兆硬盘 现如今都在谈 DevOps，谈云原生，一般 cicd 都在云端了，因此会有第二种，分阶段构建 这个时候就需要一个 go 环境，所以要利用 golang 镜像来做编译，完了再把编译出来的程序，再复制到基础的 alpine 镜像上 123456789101112FROM golang:alpine AS builderWORKDIR /appCOPY . .RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=&quot;-w -s&quot; .FROM alpineWORKDIR /appCOPY --from=builder /app/goquestionapi .COPY app.env .EXPOSE 8080CMD [ &quot;/app/goquestionapi&quot; ] 此时编译正常，镜像小，也能正常运行 docker build 的方式会产生很多 &lt;none&gt; 的没用的镜像，每次还要跑一大串命令，这有点不方便，因此可以用 Docker Compose 12345678910111213services: goquestionapi: container_name: goquestionapi image: goquestionapi ports: - 8080:8080 build: . environment: - TZ=Asia/Shanghai - GIN_MODE=release - DB_SOURCE=postgresql://postgres:postgres@192.168.31.60:5432/postgres?sslmode=disable&amp;search_path=question - LOG_LEVEL=info restart: unless-stopped 只要 docker-compose build 就可以把镜像 build 出来，并且可以灵活修改配置，命令不变，和 Makefile 的思想一样 还有一个好处就是没有 &lt;none&gt; 镜像，代码洁癖+强迫症患者表示很舒服 此时跑 docker-compose up，也能正常看到数据 以上是本地部署，线上大多是 Kubernetes 环境 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859apiVersion: apps/v1kind: Deploymentmetadata: name: goquestionapispec: selector: matchLabels: app: goquestionapi template: metadata: labels: app: goquestionapi spec: containers: - name: goquestionapi image: goquestionapi imagePullPolicy: IfNotPresent resources: limits: memory: &quot;20Mi&quot; cpu: &quot;500m&quot; ports: - containerPort: 8080 env: - name: GIN_MODE value: release - name: DB_SOURCE value: postgresql://postgres:postgres@postgres-postgresql.default.svc.cluster.local:5432/postgres?sslmode=disable&amp;search_path=question---apiVersion: v1kind: Servicemetadata: name: goquestionapispec: selector: app: goquestionapi ports: - port: 8080 targetPort: 8080---apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: goquestionapi labels: name: goquestionapi annotations: nginx.ingress.kubernetes.io/rewrite-target: /$2spec: rules: - http: paths: - pathType: Prefix path: &quot;/api(/|$)(.*)&quot; backend: service: name: goquestionapi port: number: 8080 由于我本地 K8s 环境是 kind，所以要把镜像 load 进去 1kind load docker-image goquestionapi 有两点需要注意，第一就是确保能拿到镜像，要么给个 tag 不用 latest 再通过加载镜像的方式，要么修改 imagePullPolicy 为 IfNotPresent 或者 Never，要么正确配置仓库地址，无论用 Docker Hub 还是自建 还有一点就是 postgres 要用 K8s 内部的连接，因为我的 postgres 是用 helm 安装的，所以可以通过 helm status postgres 查看到集群内部链接 apply 后访问 http://localhost/api/questions，也能正常看到数据 VSCode 或者 Goland 装好 Kubernetes 插件后，都能很方便直接 apply VSCode 的话，配置写在一起会有提示无法对比，只能对比单个的，但是单个的话，已经 apply 了的配置会自动带上时间之类的额外的东西，对比起来也不是很直接，所以这里还是写在一起 至此，API 部分完 前端前期准备利用 create-react-app 来创建 React 项目 1yarn create react-app reactquestionweb 接着集成第三方组件，axios 刚发布了 1.0.0 版本，会有兼容问题，因此还是用回老版本 0.27.2 版本 123yarn add antdyarn add axios@0.27.2yarn add use-axios-react 编写业务逻辑这里没什么好说的了，用函数式组件 + hook 完成网络请求、条件渲染，其他的就按照后端接口约定的参数提交 不会 CSS，所以没有太多华丽的辞藻显示在页面上 部署部署好多人都喜欢用 node 的镜像然后用 npm start，但其实我这边习惯用 nginx，除了 yarn build 会有优化外，你都 build 出来静态文件了，还要 node 干啥 Dockerfile 123456789FROM node:alpine AS builderWORKDIR /appCOPY . .RUN yarn &amp;&amp; yarn buildFROM nginx:alpineCOPY --from=builder /app/build /usr/share/nginx/htmlEXPOSE 80 compose.yaml 12345678services: reactquestionweb: container_name: reactquestionweb image: reactquestionweb ports: - 3000:80 build: . restart: unless-stopped k8s.yaml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051apiVersion: apps/v1kind: Deploymentmetadata: name: reactquestionwebspec: selector: matchLabels: app: reactquestionweb template: metadata: labels: app: reactquestionweb spec: containers: - name: reactquestionweb image: reactquestionweb resources: limits: memory: &quot;20Mi&quot; cpu: &quot;500m&quot; ports: - containerPort: 80---apiVersion: v1kind: Servicemetadata: name: reactquestionwebspec: selector: app: reactquestionweb ports: - port: 80 targetPort: 80---apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: reactquestionweb labels: name: reactquestionwebspec: rules: - http: paths: - pathType: Prefix path: &quot;/&quot; backend: service: name: reactquestionweb port: number: 80 然后访问 http://localhost，一切正常 到这里就完了，附上项目地址 API WEB 纯属抛砖玉玉，如果有不同的意见，以你的为准","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://linweiyuan.github.io/tags/Go/"},{"name":"React","slug":"React","permalink":"https://linweiyuan.github.io/tags/React/"},{"name":"sqlc","slug":"sqlc","permalink":"https://linweiyuan.github.io/tags/sqlc/"},{"name":"Postgres","slug":"Postgres","permalink":"https://linweiyuan.github.io/tags/Postgres/"},{"name":"Gin","slug":"Gin","permalink":"https://linweiyuan.github.io/tags/Gin/"},{"name":"Ant Design","slug":"Ant-Design","permalink":"https://linweiyuan.github.io/tags/Ant-Design/"}]},{"title":"LMMS-我和我的祖国","slug":"LMMS-我和我的祖国","date":"2022-10-02T06:34:34.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2022/10/02/LMMS-我和我的祖国.html","link":"","permalink":"https://linweiyuan.github.io/2022/10/02/LMMS-%E6%88%91%E5%92%8C%E6%88%91%E7%9A%84%E7%A5%96%E5%9B%BD.html","excerpt":"","text":"const videojsidfbbf3be7822c45b69d00270e2fc1ee2d = videojs('videojs-id-fbbf3be7-822c-45b6-9d00-270e2fc1ee2d', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/categories/LMMS/"}],"tags":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/tags/LMMS/"},{"name":"我和我的祖国","slug":"我和我的祖国","permalink":"https://linweiyuan.github.io/tags/%E6%88%91%E5%92%8C%E6%88%91%E7%9A%84%E7%A5%96%E5%9B%BD/"}]},{"title":"IntelliJ IDEA Conf 2022","slug":"IntelliJ-IDEA-Conf-2022","date":"2022-10-01T05:09:00.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2022/10/01/IntelliJ-IDEA-Conf-2022.html","link":"","permalink":"https://linweiyuan.github.io/2022/10/01/IntelliJ-IDEA-Conf-2022.html","excerpt":"","text":"看完了的 IntelliJ IDEA Conf 2022 (day 1) 和 IntelliJ IDEA Conf 2022 (day 2)写一下印象比较深的和观后感 day1Surviving Open Source, by Donald Raab介绍了这位老哥参与开源项目的心路历程 Let’s Set Sail With Fleet!, by Vitaly Bragilevsky（用了英文单引号，但是会自动变成了中文的，可能和配置有关） 这位老哥非常风趣幽默 在演示分布式计算器应用的加法功能时，2 + 3 = -1，5 + 6 = -1，评论区炸了锅，纷纷提出自己的解决方案 123456789​Add is disabled...​addition uses subtract microservice...​you&#x27;re subtracting...​Looks like &#x27;+&#x27; is mapped to &#x27;-&#x27; button...​you have minus in your java implementation 但其实是故意装作翻车的样子，节目效果罢了，实则是为了展示 Fleet 的远程协助功能（类似 IDEA 的 Code With Me） 1give them both an Oscar already 最后 QA 环节，当问到 Fleet 是不是为了替换 IDEA 而弄出来的时候，主持人挑了挑眉，然后老哥吞了下口水，也比较搞笑，感觉有点像送命题 以下是他的原话（自动生成的字幕有部分错误，这里做了调整和删了部分 uh 语气词） 1234567891011I think Fleet is not designed to replace IntelliJ IDEA.So what I&#x27;ve showed you here is an IDE for working with polyglot projects with stuff like that, but I don&#x27;t think that when you have a project in Java or in Kotlin or in one language that Fleet will be enough for your experience.So I believe from my point of view, it&#x27;s not official statement from JetBrains by the way by no means.So what I feel, for me like when I have this dedicated project in one language, it&#x27;s great to use IDEA or maybe CLI with all that stuff and that very powerful IDE, but if you want to do something quickly, to edit something, to check something, then Fleet is great.So it&#x27;s not a replacement as I see, it&#x27;s a very nice addition.So that&#x27;s what I think. 总的来说，Fleet 不是为了替换 IDEA 而弄出来的（求生欲拉满），只是作为一个补充，或者辅助工具 但是支持多语种，轻量级的特性，明眼人都看出来是对标 VSCode。。。 Should I Upgrade to Java 17?, by Nikhil Nanivadekar主要是做了一些 Benchmark，JDK 8，JDK 11，JDK 17，JDK 17 的数据总体来说比低版本的好看，性能更强，内存占用更低 然后介绍了 JDK8 以后的新特性 比如 var 类型推断，switch 支持枚举和表达式，空指针异常打印（一个对象比如 a.b().c().d() 报 NPE，之前很难看出是 a 还是 b() 还是 c() 返回 null，这里会直接打印出来出现 null 的地方，方便 debug），文本块，Instanceof 增强，Record，密封类 但我感觉他的 PPT 里提到的 JDK 版本是错的。。。 总的来说，JDK 17 已经 GA 一年多了，JDK19 也 GA 了，明年 JDK 21 LTS 也会 GA，还没升级的赶快升级 话是这么说，陈年老码谁升谁知道，只要 Spring Boot 不出个 log4j 级别的漏洞，那大环境下 JDK 8 还会存在很久，这个是我感觉的，如果有不同的想法或意见，以你的为准 新项目是可以用的，如果没用 JDK 11，也可以直接上 JDK 17 Spring 6，Spring Boot 3，也要 JDK 17 起步 说句题外话，如果你用过 Kotlin，会发现这些所谓新特性，在 Kotlin 刚出道的时候，基本上是自带的，Java 现在已经慢慢变成 Kotlin 的模样 🐶 此外，用来对标 Go 协程的 Java 虚拟线程，其实人家 Kotlin 也早就有协程和 Channel 的实现了，在 Docker、云原生等的 buff 加持下，Java 逐渐失去了跨平台的优势，所以搞了个 Spring Native 感觉作为 20 多年的老大哥，Java 起了个大早，赶了个晚集，在面对后辈异军突起的时候，危机感也挺强的，还是个人观点，有不同的以你的为准 Event Streaming and Processing Using Apache Pulsar, by Mary Grygleski没怎么了解过这个产品，没有对应的知识储备，讲得很清楚，听起来不是很明白，后面用到了再回头重看一遍 口音非常熟悉和亲切，不开字幕可以练下听力 Kubernetes Native Java, by Josh Long语速一如既往地快，不开字幕好多时候都跟不上 为什么要升级 JDK 17，他提供了一个很好的比喻（修复 bug 和去掉一些语气词） 123456789101112131415You know, for Spring Framework 6 as we mentioned, you can&#x27;t use Java 8 and Java 11 now, this is for good reason, they are terrible versions to use in production today, there is no situation which using Java 8 or 11, even ironically, is appropriate.Java 17 is technically superior to Java 8 in every conceivable way, it&#x27;s faster, more memory efficient, more observable, more secure, more robust, more syntax switch, more performant, more operations, friendly etc.It&#x27;s just a better piece of software in every conceivable way.It&#x27;s also morally superior to Java 8 in every conceivable way.You won&#x27;t like the look of despair and chagrin in your children&#x27;s faces when they find out that you&#x27;re using Java 8 in production.Don&#x27;t do it, be the change you want to see in the world, do the right thing.Java 17 is the right thing to do in 2022.My friends, I don&#x27;t think I need to go on about why Java 17 is an appropriate choice, or Java 17 or later is an appropriate choice, but just, if nothing else, just judging by the version number alone, I think it&#x27;s fair to say that Java 17 is more than twice as good as Java 8. 重点在最后一句话，好像没毛病 接着讲了自定义 banner 的改动，Spring Boot 3 不支持图片格式的自动转换了，但是纯文字不影响，主要是用的人少，也出于性能考虑 后面主要是 Spring Native 相关，如何通过自定义 actuator 接口让 K8s 的 Liveness 和 Readiness 感知，从而使应用保持健康状态 Spring Native 我也尝试过，build 的时候 CPU 和内存全部跑满，花费一分多钟打包 Docker 镜像，仅仅是一个 Hello World，但是启动确实很快，内存占用也很低（和 Spring Boot Jar 相比），但是要在云原生这块打得过 Go，还要再下点功夫，Go WEB 应用的内存占用 + 静态编译 + Docker 打包一套组合拳确实很舒服，有不同意见以你的为准 最后介绍了下 Graphql，这个很早就听过但其实没实际用过，心血来潮时再来研究一番，只是第一感觉就是数据的权限粒度问题，别的用户会不会访问到不应该看到的数据，后面用到再详细学习 day 2Idiomatic Kotlin, by Anton Arhipov主要是介绍了一些常见的用错的 Kotlin 写法，也不能说错，只是要怎样写才会更地道显得专业，好比英语母语者说东西喜欢中间加个 you know 或者 I mean，非母语者一般不会这样说，但是可能在口语中加上就会显得地道 作为有过多门编程经验的开发者，有时确实会先入为主，把之前用过的语言的写法用到新学语言上，能跑，但是就是显得不专业 好多编程语言要解决的问题一样，只是实现的过程不同，或者有自己的专有名词，比如做 WEB 开发，Spring 里的 AOP，在 Python 里面叫装饰器，在 Go 里叫中间件，不能说完全一致，只能说大部分要实现的功能都是相同的 做 Go 开发的时候，很容易将 Java 的面向对象的思维去做，遇到问题，什么都不说先创建一个类，但是 Go 不是完全面向对象，虽然可以实现面向对象，所以有时候开发前有必要好好过一遍官方文档，要怎么写才能更加 &quot;Gopher&quot; Stories of Building a Remote Development IDE, by Matt Ellis主要介绍了远程开发和实现这个功能的心路历程 这个远程开发是代码、系统资源等等全在云端，演示里是用 AWS，国外企业用 AWS 较多，目前我也还没尝试过，国内一兆小水管能干啥？ 远程开发会带来一个问题，调试的时候如何访问 localhost？解决方法是在服务器上进行端口转发，通过访问服务器的相关端口 还有介绍 Code With Me 的功能 这个实现远程开发的功能的架构，有点像 MMORPG Evolving JUnit 5, by Marc Philipp老实说，对 JUnit 的研究不多，所以对于视频的东西好多都是非常陌生，留下的印象也不深（是我个人问题，视频演示很好） Project Loom: Revolution in Concurrency or Obscure Implementation Detail?, by Tomasz Nurkiewicz其实很多概念都和其他语言的协程相似，Java 里叫虚拟线程，是一个开发中的功能，需要加参数才能尝试，JDK 19 1java --enable-preview 从用户线程讲到内核线程，在 Java 的早期版本中，JVM 自己实现了一套调度器，那时计算机还不是非常普及，一般是单核 CPU，但 Java 也能实现多线程的效果，这种是多对一的模型，也叫绿色线程，绿色线程并不依赖底层的操作系统，线程的调度都发生在用户空间 在多核的环境下，这种多对一的模型就不能发挥优势了，从实现的效果来说，绿色线程实现的是并发不是并行，因此出现第二种模型 多对多模型，一堆用户线程对应一堆内核线程，也是由 JVM 进行调度，用得不多 随着 JVM 和操作系统的日渐成熟以及计算机的发展，最后出现的是一对一模型，一个用户线程对应一个内核线程，而在一般情况下，Linux 系统会将线程看作进程（其他系统不是），所以线程的创建是比较耗费系统资源的（默认 1M） Java 里的虚拟线程，主要由三部分组成： Virtual thread：非常轻量的用户线程（相当于其他语言的协程、或者 Task） Carrier thread：JDK 19 前的 Java 线程，对应着一条内核线程，虚拟线程 pin 在这里进行处理 Continuation：一堆可以被暂停的代码，当在方法中暂停，再执行，不会从头执行方法，而是在暂停处接着执行（PPT 原文：A piece of code that can be paused, at almost no cost） 有种 IO 多路复用的感觉 虚拟线程和普通线程的用法基本一样，但是线程池可以免了，因为可以创建非常多的虚拟线程 1234567891011121314Thread t = Thread.startVirtualThread(() -&gt; &#123; System.out.println(&quot;Hello World&quot;);&#125;)Thread t = Thread .ofVirtual() .name(&quot;MyThread&quot;) .unstarted(() -&gt; task());ExecutorService es = Executors.newVirtualThreadPerTaskExecutor();ThreadFactory factory = Thread .ofVirtual() .factory(); JavaFX for Mobile Development, by Gail Anderson主要介绍 JavaFX 和 Gluon，但是已经偏了 WEB 这条路了，所以没有太认真听 刚学 Java 时倒是做过一些 GUI 应用，也写过 Android，最后还是回到了 WEB 找机会重新看一遍 最后附上原视频（科学）： day 1Agenda: 0:00 – Countdown0:53 – Introduction4:35 – Keynote: Surviving Open Source, by Donald Raab1:01:27 – Let’s Set Sail With Fleet!, by Vitaly Bragilevsky1:59:46 – Should I Upgrade to Java 17?, by Nikhil Nanivadekar3:01:06 – Event Streaming and Processing Using Apache Pulsar, by Mary Grygleski4:00:19 – Kubernetes Native Java, by Josh Long day 2Agenda: 0:00 – Countdown0:53 – Introduction5:49 – Idiomatic Kotlin, by Anton Arhipov1:03:12 – Wish You Were Here: Stories of Building a Remote Development IDE, by Matt Ellis2:01:22 – Evolving JUnit 5, by Marc Philipp3:01:18 – Project Loom: Revolution in Concurrency or Obscure Implementation Detail?, by Tomasz Nurkiewicz4:02:37 – JavaFX for Mobile Development, by Gail Anderson","categories":[{"name":"社区活动","slug":"社区活动","permalink":"https://linweiyuan.github.io/categories/%E7%A4%BE%E5%8C%BA%E6%B4%BB%E5%8A%A8/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://linweiyuan.github.io/tags/Kotlin/"},{"name":"IntelliJ IDEA Conf","slug":"IntelliJ-IDEA-Conf","permalink":"https://linweiyuan.github.io/tags/IntelliJ-IDEA-Conf/"}]},{"title":"Go实现Pod后台端口转发","slug":"Go实现Pod后台端口转发","date":"2022-09-27T18:39:50.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2022/09/27/Go实现Pod后台端口转发.html","link":"","permalink":"https://linweiyuan.github.io/2022/09/27/Go%E5%AE%9E%E7%8E%B0Pod%E5%90%8E%E5%8F%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html","excerpt":"","text":"GitHub: https://github.com/linweiyuan/goportforwarder 在 Kubernetes in docker (kind) 的环境下，没有找到好用的支持后台运行的端口转发方案，自己实现了个简单的 const videojsid8ad1ecceef8e4b16935c84e486b211a8 = videojs('videojs-id-8ad1ecce-ef8e-4b16-935c-84e486b211a8', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://linweiyuan.github.io/tags/Kubernetes/"},{"name":"Golang","slug":"Golang","permalink":"https://linweiyuan.github.io/tags/Golang/"},{"name":"Pod","slug":"Pod","permalink":"https://linweiyuan.github.io/tags/Pod/"}]},{"title":"Ingress配置pgAdmin需要注意的问题","slug":"Ingress配置pgAdmin需要注意的问题","date":"2022-09-23T17:32:34.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2022/09/23/Ingress配置pgAdmin需要注意的问题.html","link":"","permalink":"https://linweiyuan.github.io/2022/09/23/Ingress%E9%85%8D%E7%BD%AEpgAdmin%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"","text":"当使用 Docker 或者 Docker Compose 部署 pgAdmin 来方便本地开发访问使用的时候，是不需要额外注意的，因为通常都是直接暴露端口出去 但是基于 K8s 环境下部署的时候，需要稍微注意一点地方 K8s 集群准备K8s 的搭建方式多种多样，比如 k3d、kubeadm、kind 等，由于多年之前有裸装 Oracle 把系统搞烂的经历，对于一些软件的安装，我这边是比较谨慎的。况且后面接触了容器，能在里面跑就里面跑，什么两倍读写的问题不考虑，所以我使用的是 kind 来搭建集群 为了服务在容器外能访问，kind 创建 K8s 集群的时候还需要一些额外的配置 1234567891011121314151617181920kind: ClusterapiVersion: kind.x-k8s.io/v1alpha4networking: apiServerAddress: 127.0.0.1 apiServerPort: 6443nodes: - role: control-plane kubeadmConfigPatches: - | kind: InitConfiguration nodeRegistration: kubeletExtraArgs: node-labels: &quot;ingress-ready=true&quot; extraPortMappings: - containerPort: 80 hostPort: 80 protocol: TCP - containerPort: 443 hostPort: 443 protocol: TCP Ingress Controller 准备K8s 暴露服务的方式也多种多样，比如 NodePort、LoadBalancer、Ingress。由于 kind 的特殊性，整个 K8s 集群都跑在容器中，所以就算 NodePort 也是容器里的端口，所以这次主要讨论 Ingress，使用的是 Nginx 使用 Ingress，首先需要在集群中安装一个 Ingress Controller，然后通过 Ingress 来进行一些配置，当 apply 的时候，Ingress Controller 会自动更新 nginx.conf 并进行 reload 如果之前配置过 Nginx，其实类比起来是很像的，一个 Ingress Controller 相当于一个 Nginx，一个 Ingress 则好比 Nginx 的配置文件 当 Ingress Controller 准备好后，会以 NodePort 的方式暴露 80 和 443 端口 123NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEingress-nginx-controller NodePort 10.96.30.54 &lt;none&gt; 80:30860/TCP，443:31875/TCP 3d pgAdmin 准备为了简单起见，使用 helm 来安装 pgAdmin 1helm install pgadmin runix/pgadmin4 --set env.email=root@linweiyuan.com --set env.password=toor Ingress 准备配置好 Ingress 规则，因为想做到访问不同的 path 路由到不同的服务，所以这里用 &#x2F;pgAdmin 来设置 123456789101112131415apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: pgadmin-ingressspec: rules: - http: paths: - pathType: Prefix path: &quot;/pgAdmin&quot; backend: service: name: pgadmin-pgadmin4 port: number: 80 但是此时访问 http://localhost/pgAdmin 的时候，会返回 404 12Not Found The requested URL was not found on the server. If you entered the URLmanually please check your spelling and try again. pgAdmin 访问解决查看官方文档，会发现这么一句话 1If you wish to host pgAdmin under a subdirectory rather than on the root of the server, you must specify the location and set the X-Script-Name header which tells the pgAdmin container how to rewrite paths 就是说 Nginx 的配置里要加 X-Script-Name，但是在 K8s 里要怎么加？ 前面提过，其实无非是修改 Ingress 的配置，此时如果进入 Ingress Controller 的 pod 中查看配置文件，会发现当前配置 1234567bash-5.1$ hostnameingress-nginx-controller-65b4b4df7d-rhd2kbash-5.1$ cat -n nginx.conf | grep pgAdmin 297 location /pgAdmin/ &#123; 303 set $location_path &quot;/pgAdmin&quot;; 415 location = /pgAdmin &#123; 421 set $location_path &quot;/pgAdmin&quot;; 而根据 pgAdmin 官方文档的指引，需要把配置加到 location 下，回头查看 K8s 官方文档，发现其实是配置 nginx.ingress.kubernetes.io/configuration-snippet 因此配置文件进行修改，完整配置文件如下 123456789101112131415161718apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: pgadmin-ingress annotations: nginx.ingress.kubernetes.io/configuration-snippet: | proxy_set_header X-Script-Name /pgAdmin;spec: rules: - http: paths: - pathType: Prefix path: &quot;/pgAdmin&quot; backend: service: name: pgadmin-pgadmin4 port: number: 80 再 apply 12kaf pgadmin-ingress.yamlingress.networking.k8s.io/pgadmin-ingress configured 再查看 nginx.conf，已经生效了 1234567bash-5.1$ cat -n nginx.conf | grep pgAdmin 297 location /pgAdmin/ &#123; 303 set $location_path &quot;/pgAdmin&quot;; 409 proxy_set_header X-Script-Name /pgAdmin; 417 location = /pgAdmin &#123; 423 set $location_path &quot;/pgAdmin&quot;; 529 proxy_set_header X-Script-Name /pgAdmin; 此时再访问 http://localhost/pgAdmin 会自动跳转 http://localhost/pgAdmin/login?next=%2FpgAdmin%2F 用上面 helm 设置的用户名和密码即可登录进去，问题解决","categories":[{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"},{"name":"Kubernetes","slug":"容器技术/Kubernetes","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Kubernetes/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://linweiyuan.github.io/tags/Kubernetes/"},{"name":"pgAdmin","slug":"pgAdmin","permalink":"https://linweiyuan.github.io/tags/pgAdmin/"},{"name":"Ingress","slug":"Ingress","permalink":"https://linweiyuan.github.io/tags/Ingress/"}]},{"title":"利用 Github Actions 实现代码提交自动部署更新 Kubernetes","slug":"利用GithubActions实现代码提交自动部署更新Kubernetes","date":"2022-09-13T04:31:35.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2022/09/13/利用GithubActions实现代码提交自动部署更新Kubernetes.html","link":"","permalink":"https://linweiyuan.github.io/2022/09/13/%E5%88%A9%E7%94%A8GithubActions%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E6%9B%B4%E6%96%B0Kubernetes.html","excerpt":"","text":"GitHub: https://github.com/linweiyuan/github-actions-tests 可以换掉大部分 Jenkins + webhooks 的场景 const videojsid57e0d217ee634fe38f1ff08a7eea02fb = videojs('videojs-id-57e0d217-ee63-4fe3-8f1f-f08a7eea02fb', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"Github Actions","slug":"Github-Actions","permalink":"https://linweiyuan.github.io/categories/Github-Actions/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://linweiyuan.github.io/tags/Kubernetes/"},{"name":"Golang","slug":"Golang","permalink":"https://linweiyuan.github.io/tags/Golang/"},{"name":"Github Actions","slug":"Github-Actions","permalink":"https://linweiyuan.github.io/tags/Github-Actions/"}]},{"title":"Go 实现 i3bar 显示歌词","slug":"Go实现i3bar显示歌词","date":"2022-09-06T04:31:35.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2022/09/06/Go实现i3bar显示歌词.html","link":"","permalink":"https://linweiyuan.github.io/2022/09/06/Go%E5%AE%9E%E7%8E%B0i3bar%E6%98%BE%E7%A4%BA%E6%AD%8C%E8%AF%8D.html","excerpt":"","text":"GitHub: https://github.com/linweiyuan/goi3barlyric.git 限制较多，实验性质 const videojsidf231be9409394cbfbf6da09a4f15c953 = videojs('videojs-id-f231be94-0939-4cbf-bf6d-a09a4f15c953', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://linweiyuan.github.io/tags/Golang/"},{"name":"i3","slug":"i3","permalink":"https://linweiyuan.github.io/tags/i3/"},{"name":"i3bar","slug":"i3bar","permalink":"https://linweiyuan.github.io/tags/i3bar/"}]},{"title":"Docker 常用服务","slug":"Docker-常用服务","date":"2022-07-26T18:42:48.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2022/07/26/Docker-常用服务.html","link":"","permalink":"https://linweiyuan.github.io/2022/07/26/Docker-%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1.html","excerpt":"","text":"整理了下常用的 Docker 服务： https://github.com/linweiyuan/docker-services","categories":[{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linweiyuan.github.io/tags/Docker/"}]},{"title":"Docker 使用国内镜像源时遇到的坑","slug":"Docker-使用国内镜像源时遇到的坑","date":"2022-07-25T02:50:47.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2022/07/25/Docker-使用国内镜像源时遇到的坑.html","link":"","permalink":"https://linweiyuan.github.io/2022/07/25/Docker-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html","excerpt":"","text":"详见：https://github.com/ustclug/discussions/issues/396 “故从 2020 年 4 月起，从科大校外对 Docker Hub 镜像缓存的访问会被 302 重定向至其他国内 Docker Hub 镜像源” 可以看到是重定向到阿里云 https://docker.mirrors.ustc.edu.cn -&gt; https://ustc-edu-cn.mirror.aliyuncs.com 但是校外访问这个仓库已经是旧的了 替代品 直连 阿里云（广州或杭州，或自己账号）：https://registry.cn-guangzhou.aliyuncs.com 网易（容易连着连着自动断开）：https://hub-mirror.c.163.com","categories":[{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linweiyuan.github.io/tags/Docker/"}]},{"title":"30分钟从0到1搭建一个最基础的Rancher","slug":"30分钟从0到1搭建一个最基础的Rancher","date":"2022-06-04T04:31:35.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2022/06/04/30分钟从0到1搭建一个最基础的Rancher.html","link":"","permalink":"https://linweiyuan.github.io/2022/06/04/30%E5%88%86%E9%92%9F%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84Rancher.html","excerpt":"","text":"宿主机 Arch Linux，cgroup v2, 安装会报错，解决方案 -&gt; systemd.unified_cgroup_hierarchy&#x3D;0 简单起见，基于虚拟机 CentOS 7.9，一主两从rancher 管理机：192.168.31.240k8s 一主节点：192.168.31.250k8s 两从节点：192.168.31.251, 192.168.31.252 docker 私有仓库： distribution&#x2F;registry 内网 dns：dnsmasq const videojsid512bb3fb7c2d49bd8c278a332e80a638 = videojs('videojs-id-512bb3fb-7c2d-49bd-8c27-8a332e80a638', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"},{"name":"Rancher","slug":"Rancher","permalink":"https://linweiyuan.github.io/tags/Rancher/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://linweiyuan.github.io/tags/Kubernetes/"},{"name":"CentOS","slug":"CentOS","permalink":"https://linweiyuan.github.io/tags/CentOS/"}]},{"title":"分布式相关理论","slug":"分布式相关理论","date":"2022-05-22T09:42:15.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2022/05/22/分布式相关理论.html","link":"","permalink":"https://linweiyuan.github.io/2022/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html","excerpt":"","text":"CAP C：Consistency（一致性）访问分布式系统的任何一个节点，得到的数据都是一样的（需要进行数据同步） A：Availability（可用性）访问分布式系统中的任何一个健康节点，必须能得到响应，而不是超时或拒绝（需要确保网络畅通） P：Partition tolerance（分区容错性） 分区：分布式系统中部分节点由于发生网络故障或其他原因导致和其他节点失去连接，形成独立分区 容错：出现独立分区时，整个系统也要持续对外提供服务 在分布式系统中，网络是一个不确定的因素，但是发生网络故障的时候，服务还要持续对外提供服务，所以分区容错性不可避免 假如网络不佳，导致有节点故障掉线，此时接收到新的数据变更时： 如果要保证可用性，就不能等待网络恢复，那节点之间就会出现数据不一致的情况，因为数据同步需要时间 如果要保证一致性，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，在这个数据同步的过程中，服务暂时不可用 也就是说，在 P 一定出现的情况下，A 和 C 之间只能实现一个，要么 AP，要么 CP BASEBASE 是对 CAP 的一种扩展 Basically Available（基本可用）：当分布式系统出现故障时，允许丢失部分可用性，保证核心业务可用 Soft State（软状态）：在一定的时间内，允许出现数据不一致的状态 Eventually Consistent（最终一致性）：当软状态结束后，确保数据最终是一致的 相关链接：分布式相关实践","categories":[{"name":"架构设计","slug":"架构设计","permalink":"https://linweiyuan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"CAP","slug":"CAP","permalink":"https://linweiyuan.github.io/tags/CAP/"},{"name":"BASE","slug":"BASE","permalink":"https://linweiyuan.github.io/tags/BASE/"}]},{"title":"Java高并发核心编程卷1读书笔记","slug":"Java高并发核心编程卷1读书笔记","date":"2022-05-01T04:13:20.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2022/05/01/Java高并发核心编程卷1读书笔记.html","link":"","permalink":"https://linweiyuan.github.io/2022/05/01/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E5%8D%B71%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"Netty基本组件 Channel Reactor Handler Pipeline（双向链表） EventLoopGroup parentGroup: 负责新连接的监听和接收 childGroup：负责 IO 事件的轮询和分发如果不分开 parent 和 child,则会带来一个风险：新连接的接收被更加耗时的数据传输或业务处理所阻塞 ChannelOption 优点 API 使用起来相对简单，降低了开发门槛 对多种主流协议都有很好的支持（编解码功能） 支持自定义配置，通过 ChannelHandler 可以灵活地扩展通信框架 其他业界主流的 NIO 框架相比，Netty 的综合性能最优（谁出书都会说自己的好） 成熟稳定，Netty 修复了在 JDK NIO 中所有已发现的 bug（我也不知道有什么 bug） 有活跃的社区，版本迭代周期短，bug 修复及时 ZooKeeper核心优势就是解决了分布式环境的数据一致性问题，每时每刻访问 ZooKeeper 的树结构时，返回的数据都是一致的，不会引起脏读、幻读、不可重复读 脏读、幻读、不可重复读 脏读：一个事务中访问到了另一个事务未提交的数据 幻读：当两个完全相同的查询执行时，两次返回的结果集不一样，原因另一个事务新增或删除了第一个事务的结果集中的数据 不可重复读：在一个事务内根据同一个条件对数据进行多次查询，返回的结果不一致，原因是其他事务对数据进行了修改 不可重复读和幻读的区别： 不可重复读关心的是记录的更新操作，对同样的记录，再次读取数据发生变化 幻读关注的是记录的增删操作，条数发生了变化 高并发环境下的接入层网关不外乎完成以下工作： 鉴权 限流 反向代理 负载均衡 操作系统将内存划分为两部分，内核模块运行在内核空间，对应的进程处于内核态；用户程序运行在用户空间，对应的进程处于用户态 IO 读写： 上层应用通过操作系统的 read 系统调用，把数据从内核缓冲区复制到应用程序的进程缓冲区，通过操作系统的 write 系统调用，把数据从应用程序的进程缓冲区复制到操作系统的内核缓冲区 那么为什么要设置缓冲区呢？ 是为了减少设备之间的频繁物理交换，因为外部物理设备与内存和 CPU 相比，有着非常大的差距 四种主要的 IO 模型阻塞 IO 指的是，需要内核 IO 操作彻底完成后，才返回用户空间执行用户程序的操作指令，非阻塞则无需等待 同步指的是用户空间（进程或线程）是主动发起 IO 请求的一方，系统内核是被动接收方；异步 IO 则反过来 同步阻塞 IO：用户空间主动发起，需要等待内核 IO 操作彻底完成后，才返回到用户空间的 IO 操作 优点：应用程序开发非常简单，在阻塞等待数据的过程中，用户线程挂起，基本不会占用 CPU 资源 缺点：一般情况下会为每个连接配备一个独立的线程，高并发场景下，需要大量线程，内存和线程切换开销会非常大 同步非阻塞 IO：用户空间发起，不需要等待内核 IO 操作彻底完成，就可以立即返回用户空间去执行后续的指令（这个也叫 NIO，但是和 Java 里面的 NIO 有区别，Java 里的 NIO 指的是 NewIO，用的是 IO 多路复用模型），特点是需要不断进行轮询 优点：线程不会阻塞，实时性较好 缺点：需要不断轮询，占用 CPU 资源，效率低下 IO 多路复用：在 Linux 系统中，IO 多路复用的系统调用为 select&#x2F;epoll，通过该系统调用，一个用户进程（或线程）可以监视多个文件描述符，一旦某个文件描述符就绪（一般是指内核缓冲区可读&#x2F;可写），内核就能够将文件描述符的就绪状态返回给用户进程（或线程），用户空间就可以根据文件描述符的就绪状态进行对应的 IO 系统调用（Reactor） 优点：一个选择器查询线程可以同时处理成千上万的网络连接，不必创建大量的线程 缺点：select&#x2F;epoll 系统调用是阻塞的，属于同步 IO 异步 IO：指的是用户空间的线程变成被动接收者，而内核空间成为主动调用者；用户线程通过系统调用向内核注册某个 IO 操作，内核在这个 IO 操作完成后通知用户程序，用户程序执行后续的业务操作（回调） 优点：非阻塞 缺点：应用程序仅需要进行事件的注册和接收，其余的工作都留给了操作系统，也就是需要底层内核提供支持 连接极限值1ulimit -n 1000000（默认 1024） 1ulimit -SHn（S 软性极限值，超过警告；H 硬性极限值，超过报错） 如何彻底解除限制？ 编辑文件 /etc/security/limits.conf 12soft nofile 1000000hard nofile 1000000 Java NIO基本组件 Channel Buffer Selector OIO 和 NIO 的区别 OIO（Old IO） 面向流，NIO（New IO）面向缓存区 OIO 是阻塞的，NIO 非阻塞 OIO 没有 Selector 概念，NIO 有 NIO Buffer常用方法 allocate(int capacity)： 默认是写模式，从数组下标 0 开始，长度限制是 capacity put(int i)：写 i 进数组里，如果超过长度，则抛出 BufferOverflowException（可使用 remaining() 来判断剩余可写长度；如果是读模式，则抛出 ReadOnlyBufferException（可使用 isReadOnly() 来判断是否可写） filp()：读写模式转换 123456public Buffer flip() &#123; limit = position; position = 0; mark = -1; return this;&#125; get() rewind()：倒带 12345public Buffer rewind() &#123; position = 0; mark = -1; return this;&#125; flip() 和 rewind() 的区别就是 limit 参数 mark() 和 reset(): mark() 标记当前位置，当调用 reset() 的时候，回到标记的位置 clear() 123456public Buffer clear() &#123; position = 0; limit = capacity; mark = -1; return this;&#125; 使用 clear() 或者 compact() 可以将读模式改为写模式 生命周期allocate() -&gt; put() -&gt; flip() -&gt; get() -&gt; clear() &#x2F; compoact() -&gt; put() 申请内存的两种方式申请堆内存，读写效率较低，受到 GC 影响 1ByteBuffer.allocate() -&gt; java.nio.HeapByteBuffer 申请直接内存，读写效率高（少一次拷贝），不会受到 GC 影响，分配内存的时候效率低，使用不当可能造成内存泄漏 1ByteBuffer.allocateDirect() -&gt; java.nio.DirectByteBuffer NIO Channels常用 Channel FileChannel (FileInputStream() &#x2F; FileOutputStream()).geChannel(), ByteBuffer.flip(), channel.force(true), channel.close() transferTo(position, length, target)：零拷贝, 每次 2G 上限 ServerSocketChannel SocketChannel socketChannel.configureBlocking(true &#x2F; false)，默认是 blocking, 因为有个属性设置 nonBlocking 为 false DatagramChannael NIO Selector选择器的使命是处理 IO 的多路复用，完成通道的注册，监听，事件查询 选择器和通道的关系是监控和被监控的关系 IO 事件类型 SelectionKey.OP_READ SelectionKey.OP_WRITE SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey如何知道一个 Channel 是否能被监测？ 看这个 Channel 是否直接或间接继承 SelectableChannel，比如 FileChannel 就不是，而 SocketChannel 就是 注册到 Selector 的 Channel 必须是处于非阻塞模式下，因为 FileChannel 只有阻塞模式，不能切换到非阻塞模式，所以 FileChannel 不能和选择器一起使用 Selector.select() 本身是阻塞的，所以放在 while true 里不用担心 CPU 空转 Reactor 模式Reactor 模式由 Reactor 线程，Handlers 处理器两大角色组成 Reactor 线程：负责响应 IO 事件，并且分发到 Handlers 处理器 Handlers 处理器：非阻塞地执行业务逻辑处理 执行流程channel -&gt; selector -&gt; reactor -&gt; handler 优点 响应速度快，虽然同一 Reactor 线程本身是同步的，但是不会被单个连接的 IO 操作所阻塞 避免了多线程同步和线程之前频繁切换的开销 通过增加 Reactor 线程的个数，可以进行灵活扩展，充分利用 CPU 资源 缺点 每次引入新东西肯定是增加了原系统的复杂性 需要操作系统底层支持 IO 多路复用系统调用才可以 为什么在海量连接的情况下，线程池的方式不好使 线程的创建和销毁成本很高 线程本身占用较大内存，Java 线程栈内存分配 512K - 1M 线程切换的成本很高，因为需要保存上下文，如果线程切换的时间比线程本身执行所需要的时间还多，就是负优化 序列化与反序列化 数据结构大小：原则上，越小，效率越高 结构复杂度：越复杂，效率越低","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"Netty","slug":"Netty","permalink":"https://linweiyuan.github.io/tags/Netty/"},{"name":"NIO","slug":"NIO","permalink":"https://linweiyuan.github.io/tags/NIO/"}]},{"title":"Arch Linux简易安装脚本（i3, kde, deepin）","slug":"Arch-Linux简易安装脚本（i3-kde-deepin）","date":"2022-04-08T04:19:56.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2022/04/08/Arch-Linux简易安装脚本（i3-kde-deepin）.html","link":"","permalink":"https://linweiyuan.github.io/2022/04/08/Arch-Linux%E7%AE%80%E6%98%93%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%EF%BC%88i3-kde-deepin%EF%BC%89.html","excerpt":"","text":"GitHub：https://github.com/linweiyuan/archlinux-install-script todo: 异常判断，选项改 whiptail 包缓存：flexo 内网 dns：dnsmasq const videojsid54a7074714214e9a960f79c8e30b7e69 = videojs('videojs-id-54a70747-1421-4e9a-960f-79c8e30b7e69', { html5: { hls: { overrideNative: true } } });","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"}]},{"title":"关于JDK18的UTF-8","slug":"关于JDK18的UTF-8","date":"2022-03-24T07:07:34.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2022/03/24/关于JDK18的UTF-8.html","link":"","permalink":"https://linweiyuan.github.io/2022/03/24/%E5%85%B3%E4%BA%8EJDK18%E7%9A%84UTF-8.html","excerpt":"","text":"JEP 400: UTF-8 by DefaultJDK18 里有一项改进叫：JEP 400: UTF-8 by Default 其实是将默认字符集改为 UTF-8，只是 Charset.defaultCharset() 返回 UTF-8，在这之前的 JDK 版本中，返回的字符集根据操作系统的不同会不一样，有可能会导致乱码，可以看到这个方法的注释 123Returns the default charset of this Java virtual machine.The default charset is UTF-8, unless changed in an implementation specific manner. 之前的版本只有这一行 1Returns the default charset of this Java virtual machine. 所以并不是改了 String 的实现 JEP 254: Compact StringsJava 中的 String 默认采用 UTF-16 字符集，这其实是历史的包袱，为了要支持新版本的 Unicode，又要保证向后兼容，因为谁也想不到计算机的发展是如此迅猛，当时是足够用了 如今用了 UTF-16，可以存大部分辅助字符（Emoji 等）了，但是对于西方国家，日常的简单字母，有点浪费 因此 JDK9 进行了改动，将底层 char[] 改为 byte[]，并且在原有基础上加入了 Latin-1（ISO-8859-1）字符集，详细可以看这个 JEP：JEP 254: Compact Strings String(UTF-16 + Latin-1)，其中内部多了个字段 coder 1private final byte coder; 当无法用 Latin-1 表示的时候，才使用 UTF-16，减少了内存的浪费 所以 JEP 400 和 String 本身的实现关系不大","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"JDK18","slug":"JDK18","permalink":"https://linweiyuan.github.io/tags/JDK18/"}]},{"title":"ELK相关知识点","slug":"ELK相关知识点","date":"2022-03-04T09:19:10.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2022/03/04/ELK相关知识点.html","link":"","permalink":"https://linweiyuan.github.io/2022/03/04/ELK%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html","excerpt":"","text":"ELK何为 ELK，Elasticsearch + Logstach + Kibaba Elasticsearch：存储，计算，搜索数据 Logstash：数据抓取 Kibaba：数据可视化 倒排索引要说倒排索引，首先要从正向索引谈起，比如 MySQL MySQL 这类关系型数据库，如果搜索 ID，会直接走索引（索引设置得正确的前提下），一旦走了索引，查询起来是很快的，但是如果是模糊查询，就不一定了，需要逐行扫描，在索引设置得不好的情况下，需要全表扫描，数据量大的场景下效率非常低 倒排索引中有两个重要的概念： 文档（Document）：ES 里保存的数据，其中的每一条数据就是一个文档，类似数据库的一条记录 词条（Term）：对数据进行分词后得到的有意义的词语 倒排索引是对正向索引的一种特殊处理： 将文档数据利用分词算法，得到一堆的词条 ES 里保存的每行数据包括词条，词条所在文档 ID 等信息 因为词条具有唯一性，可以给词条创建索引 搜索流程： 发起搜索请求 分词得到词条 根据词条拿到 ES 里的文档 ID（这个 ID 会和 MySQL 里的 ID 同步） 根据 ID （去 MySQL）拿到具体数据 虽然需要查两遍，先查倒排索引，再查正向索引，但因为都走了索引，所以非常快，无需全表扫描 两者的关系如下表 MySQL Elasticsearch table index row document column field schema mapping sql dsl 两者不能比较，关注的领域不同，MySQL 擅长事务类型操作，可以确保数据的安全和一致性，ES 则擅长海量数据的搜索，分析，计算，实际上往往两者结合使用 IK 分词器 ik_smart：只能切分，粗粒度 ik_max_word：最细切分，细粒度 ES 搜索高亮 给文档中的关键字加一个标签 页面给这个标签设置 高亮 CSS ES 集群不管什么集群，集群无非解决几个问题 海量数据存储 单点故障 ES 通过对数据进行分片，存储到不同的节点中，将备份放到对方节点，完成互相备份，当集群中的某个节点挂掉后，会立即将挂掉的节点上的分片数据迁移到其他节点，确保数据安全 集群监控可以使用 Kibana 直接操作，或者 Cerebro","categories":[{"name":"ELK","slug":"ELK","permalink":"https://linweiyuan.github.io/categories/ELK/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://linweiyuan.github.io/tags/Elasticsearch/"},{"name":"Logstash","slug":"Logstash","permalink":"https://linweiyuan.github.io/tags/Logstash/"},{"name":"Kibana","slug":"Kibana","permalink":"https://linweiyuan.github.io/tags/Kibana/"}]},{"title":"RabbitMQ相关知识点","slug":"RabbitMQ相关知识点","date":"2022-02-17T08:54:15.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2022/02/17/RabbitMQ相关知识点.html","link":"","permalink":"https://linweiyuan.github.io/2022/02/17/RabbitMQ%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html","excerpt":"","text":"基本概念 publisher：生产者（建立连接 -&gt; 创建 channel -&gt; 声明队列 -&gt; 发送消息 -&gt; 关闭连接和 channel） consumer：消费者（建立连接 -&gt; 创建 channel -&gt; 声明队列 -&gt; 订阅消息） exchange：交换机，负责消息路由 Fanout Exchange：广播（所有绑定到该交换机的队列都能收到消息） Direct Exchange：路由（根据 routingKey 来发送到指定的队列） Topic Exchange： 主题（通过 routingKey 通配符来发送到指定的队列，#匹配一个或对个，*匹配一个） queue：队列，存储消息 基本消息队列 BasicQueue：一对一 工作消息队列 WorkQueue：一对多 virtualHost：虚拟主机，消息隔离 WorkQueue（TaskQueue）任务模型多个消费者绑定到一个队列，共同消费队列中的消息 默认是平均给每个消费者，如果考虑消费者的处理能力，需要设置 prefetch 属性，每次获取一条，消费一条再获取，达到能者多劳的目的 同一条消息只会被一个消费者处理 发布&#x2F;订阅模型对比 WorkQueue，多了一个 exchange 交换机 生产者发送消息不是发送到队列，而是发送至交换机 消费者订阅队列 exchange 只负责转发消息，不会对消息进行存储，如果没有正确配置队列或路由规则，消息就会丢失 如何保证消息可靠性要确保发送的消息至少被消费一次，需要从源头开始，生产者是否成功发送消息到交换机，交换机是否正常发送消息到队列，队列里的消息是否成功被消费者消费 RabbitMQ 提供了 publisher confirm 和 publish-return 机制来避免消息在发送的过程中丢失 publish-confirm 如果消息成功投递到交换机，返回 ack 如果消息未投递到交换机，返回 nack publish-return 如果消息投递到交换机了，但是没有路由到队列，返回 ack 及路由失败原因 考虑到 MQ 本身的稳定，可以分别将交换机，队列，消息都设置为持久化 如何解决消息堆积问题当发送消息超过了处理消息的速度，就会造成消息堆积，如果队列中的消息达到上限，那么最早受到的消息，可能就会变成死信，然后被丢弃 消息堆积的本质是消费者消费消息的速度跟不上，所以可以从下面几个方面来进行考虑 增加消费者个数，那么速度就成倍提高了 增加队列长度，可以暂存更多的消息","categories":[{"name":"消息队列","slug":"消息队列","permalink":"https://linweiyuan.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://linweiyuan.github.io/tags/RabbitMQ/"}]},{"title":"Redis相关知识点","slug":"Redis相关知识点","date":"2022-01-09T06:03:16.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2022/01/09/Redis相关知识点.html","link":"","permalink":"https://linweiyuan.github.io/2022/01/09/Redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html","excerpt":"","text":"Redis：Remote Dictionary Server 基于内存，速度非常快（因此受物理内存大小限制） 数据结构非常丰富（String， List， Hash， Set， SortedSet） 单线程，避免了线程切换和锁机制的性能消耗 可持久化（RDB + AOF） 支持发布订阅 支持 Lua 脚本 支持分布式锁 支持原子操作和事务 支持主从复制（Master-Slave）和高可用（Redis Sentinel）（3.0 版本以上） 支持管道（管道在这里类似于 batch，一次性发送多个命令，一次性返回所有结果，减少网络开销） 主要的五种数据结构及使用场景Redis 支持多种数据结构，常用的有 5 种 String：计数器，kv 存储，限流，分布式锁 List：当队列来使用（lpush + rpop 或者 rpush + lpop）；发红包（抢红包是入队，拆红包则是出队）；列表（朋友圈点赞，评论） Hash：kv，比如存一些标签信息，在保存用户信息等的场景，Hash 和 String 的不同点在于，String 要修改某个字段必须将整条用户完整信息取出来，再进行系列化反序列化操作，而 Hash 可以只对某个字段进行修改，节省了网络流量，不过 Hash 要比 String 占用多一点内存；购物车（用户 id，商品 id，商品数量）；存储对象 Set：好友、关注、粉丝、感兴趣的人的集合（sinter 获取交集，sismember 判断是否存在，scard 获取数量）；首页随机推荐展示（srandmember）；存储需要去重的场景，比如中奖，保证不会中两次 SortedSet：排行榜（因为有序） 单线程的 Redis 为什么这么快 Redis 是完全基于内存的，所以读写效率非常高，当然 Redis 存在持久化操作，但 Redis 的持久化操作是通过 fork 子进程和利用 Linux 系统的页缓存技术来完成，所以并不会影响 Redis 的性能 对于 Redis 来说，它的性能瓶颈主要在网络和 IO 上，而不在 CPU，多线程频繁进行上下文切换会带来额外的性能消耗，可能会造成负优化；Redis 高版本也支持多线程，但是主要是用来执行对一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程的阻塞时间，提高执行的效率 数据结构设计得合理高效 采用了非阻塞 IO 多路复用机制：IO 多路复用是利用 select、poll、epoll 可以同时监测多个流的 IO 事件的能力，在空闲的时候，会阻塞当前线程，当有 IO 事件发生时才唤醒来处理就绪的流，这样就避免了大量的无用操作 数据过期淘汰策略Redis 中数据过期淘汰策略采用的是定期删除 + 惰性删除 定期删除（activeExpireCycle）：Redis 后台有一个定时器来定时监视所有的 key，过期就删除。通过定期删除策略，可以保证过期的 key 最后都会被删掉，缺点就是每次都要都遍历 Redis 中的所有 key，非常消耗 CPU 资源，如果 key 过期了，但是定时器还没开始工作，这个过期的 key 就还能用 惰性删除（expireIfNeeded）：在使用 key 时，先判断 key 是否过期，如果过期则删除。这种方式也有缺点，就是虽然这个 key 过期了，但是一直没人用，那么它就会一直存在 Redis 中，造成浪费 因此 Redis 将这两种方式结合起来，定时随机抽取一些幸运 key 进行删除 这样没有缺点吗？ 有，如果某个 key 是天选之子，每次都抽不到，但是已经过期了，就会常驻内存 所以 Redis 还会有另外的机制来处理这种情况，就是内存淘汰 内存淘汰机制volatile：设置过期时间的 keyallkeys：全部 keylru：最近最少使用lfu：最近最不经常使用random：随机ttl：过期时间noeviction：永不过期 排列组合： volatile-lru allkeys-lru volatile-lfu allkeys-lfu volatile-random allkeys-random volatile-ttl noeviction 默认是永不过期，如果满了就会报 OOM Redis 和 Memcached 的区别 存储方式不同：Memcachedb 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部分存在硬盘上，这样能保证数据的持久性 数据类型支持：Memcached 对数据类型支持相对简单；Redis 有复杂的数据类型 为什么要使用 Redis 而不用 map&#x2F;guava 做缓存缓存分为本地缓存和分布式缓存 map 或者 guava 实现的是本地缓存，这种缓存是存在内存中的，一旦 JVM 挂了或手动停掉，数据就丢失了，本地缓存无法做到多实例共享，因为每个实例都有自己的一份，生命周期和 JVM 绑定 Redis 或者 Memcached 则称为分布式缓存，支持多实例共享，Redis 还支持数据持久化，宕机数据还在 Redis 三大经典问题缓存穿透查询一个数据库不存在的数据，因为数据库没有，所以不能将数据库值缓存起来，导致每次请求都直接去到数据库，这样会增加数据库压力，降低系统性能，Redis 形同虚设 解决方案： 缓存空值当请求的数据库不存在于 Redis 中也不存在于数据库时，设置一个默认空值，后续再进行查询时就直接返回，避免请求去到数据库，除此之外还需要对该数据设置一个合适的过期时间，不然后续这个 key 的数据在数据库有了，永远不能被查到 布隆过滤器在数据写入数据库的同时，将这个 ID 同步到布隆过滤器中，当请求的 ID 不存在布隆过滤器中，则说明该请求查询的数据一定没有在数据库中保存，就不要再去查数据库 原理：首先分配一块数组，里面的值全为 0，当存入元素时，采用 N 个哈希函数对该元素进行哈希计算，映射出来的位置全部设置为 1；当检查这个 key 是否存在时，也是同样的方法，如果得到的全为 1，则 key 存在；布隆过路器存的只是这个 key 计算出来的哈希值，并不是这个 key 本身，而哈希函数是会出现碰撞的，所以就算计算出来全是 1，也不能保证其实这个 key 存在，也就是会出现判断 key 存在，但实际不存在的的情况，存在误判；反之，当判断这个 key 不存在的时候，就一定不存在 对于恶意构造的请求 对参数进行校验，非法则拦截 拉黑 IP（治标不治本） 缓存击穿高并发流量，访问的这个数据是热点数据，请求的数据在数据库中存在，但是 Redis 存的那一份已经过期，后端需要从数据库加载数据并写到 Redis（单一热点数据、高并发、数据失效） 解决方案： 设置随即过期时间：让缓存数据慢慢过期 缓存预热：提前把热门数据存入 Redis，设置一个较大的过期时间 锁机制：当发现缓存失效时，需要先获取锁，成功后才执行数据库查询和写数据到缓存的操作，失败则说明当前有其他线程在对数据库进行操作，休眠一段时间再重试 缓存雪崩分两种情况 Redis 中大量数据同时失效，高并发场景下，大量的请求直接去到数据库，造成数据库压力激增，严重的话会搞挂数据库 解决方案： 设置随即过期时间，避免大量数据同时过期 对非核心业务的接口进行限流，避免过多请求直接被去到数据库 后台开启时任务，在缓存快要失效时及时更新缓存（具体问题具体分析） Redis 挂了，也会使请求全部去到数据库 解决方案： 将热点数据均匀分布在不同的节点上 服务熔断和限流 构建高可用集群 缓存击穿和缓存雪崩的最大区别就是单一热点数据失效，还是大量数据同时失效 总之把握前中后的原则去进行系统设计和考虑 故障之前，尽可能集群部署，放置单点故障发生了故障，对服务进行限流、降级操作，避免搞挂 MySQL修复了故障后，通过 Redis 持久化机制 RDB 和 AOF，恢复缓存数据 Redis 持久化 RDB（Redis Database Backup file）：Redis 快照文件，里面是一些二进制的数据，通过 save、bgsave 等命令进行保存，宕机恢复起来较快，文件体积也小，有压缩 AOF（Append Only File）：对 Redis 操作的每一条写命令都会记录起来，是纯文本，人可以看，故障恢复时，重新跑记录的命令，因为记录每一条命令，所以体积会较大 Redis 支持同时开启 RDB 和 AOF，在这种情况下，会优先利用 AOF 文件来恢复数据，因为 AOF 文件保存了每一条记录，相对来说数据完整性高一点 Redis 主从单节点 Redis 的并发能力有上限，搭建主从集群可以提高并发能力，实现读写分离只有 master 节点可以执行写操作，slave 节点只能执行读操作 主从同步主从同步分为全量同步和增量同步 全量同步当 slave 第一次连接到 master 时，会执行一次全量同步，这个时候 master 会将内存中的数据生成快照 RDB，并发送给 slave，后续通过发送保存在 repl_backlog 的命令给 slave 完成增量同步怎么知道是不是第一次连接？master 和 slave 都有一个 replication id，如果不一致，则是第一次同步，那么 slave 就会修改自己的 id 为 master 的 id如果 slave 断开太久，导致 offset 差太多，也要全量同步，offset 可以简单理解为 slave 和 master 的数据相差的量，详细的话记不清了，有个圆环什么的，如果在圆上走了一圈数据还没同步过去，那圆上的数据就会被覆盖，为了保证数据的一致性，就要全量同步 增量同步slave 把 offset 发给 master，master 去 repl_backlog 里查看，并发送 offset 之后的命令给 slave Redis Sentinel 哨兵机制Sentinel 是 Redis 的高可用解决方案，用来对 Redis 主从节点进行监控，发生故障时通过投票机制选举出新的 master，并将所有 slave 连接到新的 master 上 哨兵也是一个 Redis 服务器，运行的是 redis-sentinel 命令，而普通 redis 服务运行的则是 redis-server 命令 哨兵不提供数据服务，通常配置成单数，可以运行多个实例组成一个分布式系统 对于一些起监控作用的中间件，完成的事情无非就是下面几个： 监控：确保主从节点正常运行 通知：出现问题时发出通知 故障转移：选举新 master，将其他 slave 连接到新的 master 上","categories":[{"name":"数据库","slug":"数据库","permalink":"https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://linweiyuan.github.io/tags/Redis/"}]},{"title":"线程相关知识点","slug":"线程相关知识点","date":"2021-10-24T15:13:13.000Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"2021/10/24/线程相关知识点.html","link":"","permalink":"https://linweiyuan.github.io/2021/10/24/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html","excerpt":"","text":"基本概念 初始状态 new 可运行&#x2F;运行状态 runnable 休眠状态 blocked waiting timed_waiting 终止状态 terminated 线程的生命周期和状态 创建：new 就绪：start()，可运行，等待获取 CPU 的使用权 运行：执行 阻塞：放弃 CPU 使用权，sleep，wait（sleep 是 Thread 的，wait 是 Object 的） 死亡：执行完或异常退出 线程的 run() 和 start() 的区别start() 方法用于启动线程，run() 方法用于执行线程的运行时代码，run() 可以重复调用，而 start() 只能调用一次，如果直接调用线程的 run() 方法，相当于执行一个普通方法，不在整个线程的生命周期中 如何停止一个线程 使用 flag stop() interrupt() sleep(), wait(), join(), yield() sleep: Thread 类的静态方法，不依赖于 synchronized，一般用于当前线程休眠，会释放锁 wait: Object 类的普通方法，依赖于 synchronized，一般用于多线程之间的通信，不会释放锁，要使用 notify() 或者 notifyAll() 唤醒 yield: 执行后线程进入就绪状态，马上释放了 CPU 的执行权，但是保留了 CPU 的执行资格，可能在下次调度的时候再次获得执行权 join: 执行后线程进入阻塞状态，让 join 的线程先执行完或中断 notify() 和 notifyAll() 的区别notify() 随机唤醒一个线程，notifyAll() 唤醒所有的线程，当 notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，不成功则留在锁池等待锁释放后再次参与竞争 实现多线程的几种方式 继承 Thread 类（实际上 Thread implements Runnable） 实现 Runnable 接口 实现 Callable 接口（通过 FutureTask 包装器来创建） 通过线程池创建线程，使用线程池接口 ExecutorService 结合 Callable，Future 实现有返回值的多线程 runnable 有两个弊端（Callable 和 Runnable 的最大区别就是 Callable 可以有返回值）： 不能获取返回结果 不能抛出异常 守护线程守护线程是运行在后台的一种特殊进程，为所有非守护线程提供服务，比如 GC 线程就是特殊的守护线程 用法注意：thread.setDaemon(true) 必须在 thread.start() 之前设置，否则抛出异常 IllegalThreadStateException，因为不能把正在运行的常规线程设置为守护线程 ThreadLocalThreadLocal 不是多线程同步机制中的一种，而是一种解决思路，它解决的是多线程下成员变量的安全问题，不是共享变量的安全问题 线程同步机制是多个线程共享一个变量，而 ThreadLocal 是每个线程创建一个自己的单独变量副本，所以每个线程都可以独立地改变自己的变量副本，而不会影响到其他线程的变量副本 ThreadLocal 内部有一个非常重要的内部类：ThreadLocalMap，是真正实现线程隔离机制的关键，ThreadLocalMap 内部结构类似于 Map，由键值对 key 和 value 组成一个 entry，key 为 ThreadLocal 本身，value 是对应的线程变量副本（首先是 Thread，Thread 里面有 ThreadLocal.ThreadLocalMap，Map 的话存储的是 Entry 集合，每一个 Entry 的 key 为 ThreadLocal，value 为具体的值） 有两点需要注意 ThreadLocal 本身不存储值，它只是提供一个查找到值的 key ThreadLocal 包含在 Thread 中，不是 Thread 包含在 ThreadLocal 中 ThreadLocalMap 和 HashMap 的功能类似，但是实现上却有很大的不同： HashMap 的数据结构是数组 + 链表 ThreadLocalMap 的数据结构仅仅是数组 HashMap 是通过链地址法来解决哈希冲突，ThreadLocalMap 是通过开放地址法来解决哈希冲突（链地址：数组加链表，开放地址：寻找空的位置） HashMap 里面的 Entry 内部类的引用都是强引用，ThreadLocalMap 里面的 Entry 内部类中的 key 是弱引用，value 是强引用 1static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; 从源码可以看出 ThreadLocal.ThreadLocalMap.Entry 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用，也就是说，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候 key 会被清理掉，而 value 不会被清理，这样一来，ThreadLocalMap 中就会出现 key 的 null 的 Entry，假如不做任何措施的话，value 永远无法被 GC，这个时候就可能产生内存泄漏 如何避免内存泄漏？ 当一个变量不用的时候，要调用 remove() 删除掉（内部调用了 expungeStaleEntry()，将 value 设为 null，这样下一次垃圾回收时就会被彻底回收掉） CASCAS 全称 Compare And Swap，比较并交换，是一条 CPU 的并发原语 原语的执行必须是连续的，在执行的过程中不允许被中断，因此不会造成数据不一致的问题，具有原子性。CAS 是一种重要的同步思想，判断内存中的值是否和预期的值一样，如果是，则将内存中的值更新为新值，否则会不断重试，直到一致为止 ABA 问题 比较并交换的循环，存在一个时间差，而这个时间差可能带来意想不到的问题 比如两个线程 A 和 B 一开始都从主内存中拷贝了原值为 1 线程 A 执拿到值为 1 然后挂起 线程 B 修改值为 2，执行完毕 线程 B 觉得修改错误，把值重新设置为 1， 线程 A 被唤醒，比较发现内存中的值和预期的值一样，修改成功（但是不知道这个值已经被 B 修改过了） 尽管线程 A CAS 操作成功，但不代表没有问题，有的需求，只注重头和尾，只要首尾一致，就接受，但是有的需求，还看重过程，中间不能发生任何修改，这就引出了 AtomicStampedReference 原子引用 AtomicStampedReference 内部维护了一个版本号 stamp，在进行 CAS 操作的时候，不仅要比较当前值，还要比较版本号，只有两者都相等，才执行更新操作（有点类似乐观锁） 任何技术都不是完美的，CAS 也有自己的缺点，CAS 实际上是一种自旋锁 一直循环，开销比较大 只能保证一个变量的原子操作，多个变量依然要加锁 引出了 ABA 问题（AtomicStampedReference 可解决） CAS 的使用场景适合在一些并发量不高，线程竞争较少的情况，但是一旦线程冲突严重的情况，循环时间太长，会给 CPU 带来很大的开销 线程池如何创建线程池？JDK 中提供了创建线程池的类，Executors，但是一般不推荐 Executors 类只是个静态工厂，提供创建线程池的几个静态方法（内部屏蔽了线程池参数配置细节），而真正的线程池类是 ThreadPoolExecutor 123456789public ThreadPoolExecutor( int corePoolSize， int maximumPoolSize， long keepAliveTime， TimeUnit unit， BlockingQueue&lt;Runnable&gt; workQueue， ThreadFactory threadFactory， RejectedExecutionHandler handler) 核心参数： corePoolSize：核心线程数。如果等于 0，则任务执行完毕后，没有任务请求进入时，销毁线程池中的线程。如果大于 0，即使本地任务执行完毕，核心线程也不会被销毁。设置得过大会浪费系统资源，设置过小会导致线程频繁创建 maximumPoolSize：最大线程数。必须大于等于 1，且大于等于 corePoolSize。如果与 corePoolSize 相等，则线程池大小固定。如果大于 corePoolSize，则最多创建 maximumPoolSize 个线程执行任务 keepAliveTime：线程空闲时间。线程池中线程空闲时间达到 keepAliveTime 值时，线程会被销毁，直到剩下 corePoolSize 个线程为止。默认情况下，线程池的最大线程数大于 corePoolSize 时，keepAliveTime 才会起作用。如果 allowCoreThreadTimeOut 被设置为 true，即使线程池的最大线程数等于 corePoolSize，keepAliveTime 也会起作用（回收超时的核心线程） unit：TimeUnit 表示时间单位 workQueue：缓存队列。当请求线程数大于 corePoolSize 时，线程进入 BlockingQueue 阻塞队列 threadFactory：线程工厂。用来生产一组相同任务的线程。主要用于设置生成的线程名词前缀，是否为守护线程以及线程的优先级等。设置有意义的名称前缀可以很快知道线程是由哪个线程工厂创建的，方便调试 handler：执行拒绝策略对象。当任务数达到缓存上限时（即超过 workQueue 参数能存储的任务数），执行拒绝策略，相当于限流保护 上面复杂概念的简洁描述： 如果线程池当前状态不是 running，直接拒绝 如果 worker &lt; pool，创建新线程 如果 worker &gt;&#x3D; pool，queue 未满，将任务添加到 queue 如果 pool &lt;&#x3D; worker &lt; max，并且 queue 已满，开启新线程 如果 worker &gt; max，并且 queue 已满，拒绝策略（默认直接抛异常） 线程池种类 FixedThreadPool：固定长度的线程池，核心线程数等于最大线程数，不存在空闲线程，keepAliveTime 为 0，可以控制线程的最大并发数，超出的线程会放到队列中 SingleThreadExecutor：单线程线程池，核心线程数和最大线程数都是 1，它只会用唯一的线程来执行任务，相当于串行执行，超出的线程会放到队列中 CachedThreadPool：可缓存的线程池，核心线程数为 0，最大线程数为 Integer.MAX_VALUE，如果数据过多，它会不断地创建新的线程，存在 OOM 风险，keepAliveTime 为 60，工作线程处于空闲状态超过 keepAliveTime 会回收线程 WorkStealingPool：JDK 1.8 引入，核心是工作窃取，没怎么见人用过 ScheduledThreadPool：用于定时执行任务的线程池 禁止直接使用 Executors 创建线程池的原因（除 Executors.newWorkStealingPool 方法之外，其他方法都有 OOM 风险）： Executors.newCachedThreadPool 和 Executors.newScheduledThreadPool 两个方法最大线程数为 Integer.MAX_VALUE，如果线程数太多，会有 OOM 的风险 Executors.newSingleThreadPool 和 Executors.newFixedThreadPool 两个方法的 workQueue 参数为 LinkedBlockingQueue，容量为 Integer.MAX_VALUE，如果瞬间请求过大，导致队列中任务过多，会有 OOM 风险 线程池拒绝策略ThreadPoolExecutor 提供了四个公开的静态内部类： AbortPolicy：默认，丢弃任务并抛出 RejectedExecutionException DiscardPolicy：丢弃任务，但是不抛出异常（不推荐） DiscardOldestPolicy：丢弃队列中等待最久的任务，然后把当前的新任务加入到队列中 CallerRunsPolicy：调用任务的 run() 方法绕过线程池直接执行 如何自定义拒绝策略实现 RejectedExecutionHandler 接口或继承已有策略，重写 rejectedExecution() 方法 为什么要用线程池线程池，数据库连接池，HTTP 连接池等都属于池化技术，主要是为了减少每次获取资源的消耗，提高对资源的利用率。线程池提供了一种限制和管理资源（包括执行一个任务），每个线程池还维护一些基本统计信息例如已完成任务的数量 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗 提高相应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行 提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"Thread","slug":"Thread","permalink":"https://linweiyuan.github.io/tags/Thread/"}]},{"title":"JVM相关知识点","slug":"JVM相关知识点","date":"2021-10-01T13:53:27.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2021/10/01/JVM相关知识点.html","link":"","permalink":"https://linweiyuan.github.io/2021/10/01/JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html","excerpt":"","text":"程序计数器（Program Counter Register）程序计数器里面存放的是下一条 JVM 指令代码的执行地址，概念上有点类似数据库结果集遍历时的游标，不断指向下一条，物理上是通过寄存器实现的，寄存区在 CPU 上是非常快的单元 在 JVM 的规范中，每条线程都有自己的程序计数器，所以程序计数器是线程私有的，因为当发生线程切换的时候，需要知道切换回来后下一步应该执行什么操作，如果不是线程私有则会造成混乱 程序计数器是 JVM 中唯一不会存在 OOM 的区域，这一点是 JVM 规范上要求的 虚拟机栈说虚拟机栈之前先说栈，栈的特点就是先进后出或后进先出 虚拟机栈是线程运行时需要的内存空间，线程运行的目的是为了执行代码，代码由一个个方法组成，当线程运行的时候，每个方法需要的内存空间就是栈帧（参数，局部变量，返回地址），每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存，调用方法时入栈，执行完出栈，每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法（栈顶部），栈是有一定的深度的，当发生递归死循环时，一直有方法入栈但不出栈，导致栈溢出，抛出 java.lang.StackOverflowError IDEA debug 时左下角的 Frame 就是栈帧，比较直观，从上到下，右边还可以看到栈内的局部变量值 垃圾回收是否涉及栈内存不会 栈内存随着出栈就释放掉，垃圾回收主要用来回收堆内存 栈内存分配越大越好吗不是 -Xss size（比如-Xss1m，没有等号） Windows 下取决于虚拟内存的设置，其他主流操作系统上默认为 1024KB（1MB） 物理内存的大小是固定的，栈内存分配设置得越大，占用越多内存，由于栈是线程私有的，所以线程占用的内存就会变大，那么操作系统可以创建的总线程数就会变小 比如操作系统 10M 内存（只是举例），本来一个线程默认占用 1M 内存，那么可以创建 10 个线程，但设置-Xss2m 后，只能创建 5 个线程了 -Xss 设置得大，只会增加方法递归调用的次数，一般不会提升性能，就是不容易爆栈，但死循环递归该爆还得爆 方法内的局部变量是否线程安全是 每个线程都有私有的栈帧，里面会有各自独立的变量，互不干扰。线程安全问题出现在共享变量上，如果方法内局部变量没有逃离方法的作用范围，那么这个局部变量就是线程安全的 线上诊断方法通常都是十八般武艺配合着来用，包括但不限于： top 命令，查看 %CPU，配合 grep java ps H -eo pid,tid,%cpu(小写 cpu) | grep 进程号 jstack 进程 id，会列出所有线程，有线程号 nid（16 进制），printf ‘%x’ 10 进制 id jstack 查看是否出现死锁 本地方法栈native 地方法运行时所需要的空间，其他的每什么好说的了，不懂 堆通过 new 关键字创建的对象都会使用堆内存堆里面的对象是线程共享的，所以一般都需要考虑线程安全的问题，堆有垃圾回收机制，并且会发生内存溢出 java.lang.OutOfMemoryError: Java heap sapce JVM 参数常用的有两个，用于设置内存占用大小-Xms：堆的初始大小-Xmx：堆的最大占用 为什么一般都会将这两个参数设置成一样？因为当堆内存不足需要进行扩容的时候，会发生内存抖动，对程序运行的稳定性会有一定的影响 线上诊断方法包括但不限于： jps：查看系统中存在的 Java 进程 jmap：查看堆内存占用情况，jmap -head pid jconsole：图形界面的，多功能监测工具，可以连续监测（可测出是否发生死锁） jvisualvm：堆 dump 方法区线程共享，存放一些类的基本信息（类，类加载器，运行时常量池），逻辑上是堆的一部分，不同厂商有不同的实现 HotSpot 在 1.7 之前用永久代（堆），1.8 后用元空间（操作系统内存） 方法区是规范，永久代或者元空间是其中一种实现，方法区会发生内存溢出1.8 以前会导致永久代内存溢出：-XX:MaxPermSize=m（OutOfMemory：PermGen space）1.8 之后会导致元空间内存溢出：-XX:MaxMetaspaceSize=m（OutOfMemory：Metaspace） 字符串常量池，串池（StringTable）常量池：是一张表，维护类名，方法名，参数类型，字面量等信息 运行时常量池：当类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址 字符串常量池：字符串是日常开发中使用得非常多的类，池化技术某种程度上会有性能上的提升 如何判断字符串是在堆还是在串池中 12345public static void main(String[] args) &#123; String s1 = &quot;a&quot;; String s2 = &quot;b&quot;; String s3 = s1 + s2;&#125; javap -v x.class 查看二进制字节码（类基本信息，常量池，类方法定义，包含了虚拟机指令） 不同的 JDK 版本可以看到反编译出来的不一样 JDK 1.8 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576Classfile /home/linweiyuan/Temp/test/Test.class Last modified Sep 24, 2022; size 759 bytes MD5 checksum 1eeb9a3b24c5c4f6a213e62ca4ee1691 Compiled from &quot;Test.java&quot;public class Test minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #9.#18 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = String #19 // a #3 = String #20 // b #4 = Class #21 // java/lang/StringBuilder #5 = Methodref #4.#18 // java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V #6 = Methodref #4.#22 // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #7 = Methodref #4.#23 // java/lang/StringBuilder.toString:()Ljava/lang/String; #8 = Class #24 // Test #9 = Class #25 // java/lang/Object #10 = Utf8 &lt;init&gt; #11 = Utf8 ()V #12 = Utf8 Code #13 = Utf8 LineNumberTable #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 SourceFile #17 = Utf8 Test.java #18 = NameAndType #10:#11 // &quot;&lt;init&gt;&quot;:()V #19 = Utf8 a #20 = Utf8 b #21 = Utf8 java/lang/StringBuilder #22 = NameAndType #26:#27 // append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #23 = NameAndType #28:#29 // toString:()Ljava/lang/String; #24 = Utf8 Test #25 = Utf8 java/lang/Object #26 = Utf8 append #27 = Utf8 (Ljava/lang/String;)Ljava/lang/StringBuilder; #28 = Utf8 toString #29 = Utf8 ()Ljava/lang/String;&#123; public Test(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: ldc #2 // String a 2: astore_1 3: ldc #3 // String b 5: astore_2 6: new #4 // class java/lang/StringBuilder 9: dup 10: invokespecial #5 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V 13: aload_1 14: invokevirtual #6 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 17: aload_2 18: invokevirtual #6 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 21: invokevirtual #7 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 24: astore_3 25: return LineNumberTable: line 4: 0 line 5: 3 line 6: 6 line 7: 25&#125;SourceFile: &quot;Test.java&quot; JDK 9+，我这里用的是 JDK 17，但其实从 9 开始就变了，之前有试过，最近整理笔记，电脑上 JDK 9 已经没有了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788Classfile /home/linweiyuan/Temp/test/Test.class Last modified Sep 24, 2022; size 759 bytes SHA-256 checksum 1f929ea79bba2fa30f55910a61ea7627d430b3dff13f7bdb8cd275e901a0343d Compiled from &quot;Test.java&quot;public class Test minor version: 0 major version: 61 flags: (0x0021) ACC_PUBLIC, ACC_SUPER this_class: #15 // Test super_class: #2 // java/lang/Object interfaces: 0, fields: 0, methods: 2, attributes: 3Constant pool: #1 = Methodref #2.#3 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #4 // java/lang/Object #3 = NameAndType #5:#6 // &quot;&lt;init&gt;&quot;:()V #4 = Utf8 java/lang/Object #5 = Utf8 &lt;init&gt; #6 = Utf8 ()V #7 = String #8 // a #8 = Utf8 a #9 = String #10 // b #10 = Utf8 b #11 = InvokeDynamic #0:#12 // #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; #12 = NameAndType #13:#14 // makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; #13 = Utf8 makeConcatWithConstants #14 = Utf8 (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; #15 = Class #16 // Test #16 = Utf8 Test #17 = Utf8 Code #18 = Utf8 LineNumberTable #19 = Utf8 main #20 = Utf8 ([Ljava/lang/String;)V #21 = Utf8 SourceFile #22 = Utf8 Test.java #23 = Utf8 BootstrapMethods #24 = MethodHandle 6:#25 // REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite; #25 = Methodref #26.#27 // java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite; #26 = Class #28 // java/lang/invoke/StringConcatFactory #27 = NameAndType #13:#29 // makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite; #28 = Utf8 java/lang/invoke/StringConcatFactory #29 = Utf8 (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite; #30 = String #31 // \\u0001\\u0001 #31 = Utf8 \\u0001\\u0001 #32 = Utf8 InnerClasses #33 = Class #34 // java/lang/invoke/MethodHandles$Lookup #34 = Utf8 java/lang/invoke/MethodHandles$Lookup #35 = Class #36 // java/lang/invoke/MethodHandles #36 = Utf8 java/lang/invoke/MethodHandles #37 = Utf8 Lookup&#123; public Test(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: (0x0009) ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: ldc #7 // String a 2: astore_1 3: ldc #9 // String b 5: astore_2 6: aload_1 7: aload_2 8: invokedynamic #11, 0 // InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; 13: astore_3 14: return LineNumberTable: line 4: 0 line 5: 3 line 6: 6 line 7: 14&#125;SourceFile: &quot;Test.java&quot;BootstrapMethods: 0: #24 REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite; Method arguments: #30 \\u0001\\u0001InnerClasses: public static final #37= #33 of #35; // Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles 得出结论 1234567891011121314// JDK 1.8String s1 = &quot;a&quot;;String s2 = &quot;b&quot;;String s3 = s1 + s2; // new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString();// JDK 1.9 -&gt; StringConcatFactory.makeConcatWithConstants()String s1 = &quot;a&quot;;String s2 = &quot;b&quot;;String s3 = &quot;ab&quot;;String s4 = s1 + s2; // StringConcatFactory.makeConcatWithConstants()String s5 = &quot;a&quot; + &quot;b&quot;; // 编译期优化System.out.println(s3 == s4); // false，因为 s3 存在串池中，s4 是 new 出来的对象在堆中System.out.println(s3 == s5); // true，因为 ab 已经存在串池中了（s3），对于确定的字符串（不是变量），Java 会进行编译期优化 StringTable 特性 常量池中的字符串只是符号，第一次用到时才变为对象 利用串池的机制，可以避免重复创建字符串对象 字符串常量拼接的原理是编译期优化 用 intern() 可以主动把串池中还没有的字符串对象放入串池（尝试放入串池，有则不会放入，没有则放入，无论放入是否成功，返回的都是串池中的对象） 这里有一个要注意的地方，JDK 1.8 intern() 将自己放入串池（一个对象），JDK 1.6 把自己复制一份放进串池（两个对象） 12345String s = new String(&quot;a&quot;) + new String(&quot;b&quot;); // 此时 s 在堆中String s2 = s.intern(); // s 放入了串池，并且返回了串池中的对象 abSystem.out.println(s2 == &quot;ab&quot;); // true，因为 s2 就是串池中返回的对象，和串池中的对象 ab 相比，相等System.out.println(s == &quot;ab&quot;); // true, 因为串池中还没有，intern() 放入了后，s 此时在串池中 123456String x = &quot;ab&quot;; // 串池中已经有了 abString s = new String(&quot;a&quot;) + new String(&quot;b&quot;); // 此时 s 在堆中String s2 = s.intern(); // s 放入串池失败，因为已经有了，返回了串池中的对象 ab 给 s2，但是 s 还在堆中System.out.println(s2 == &quot;ab&quot;); // true，因为 s2 就是串池中返回的对象，和串池中的对象 ab 相比，相等System.out.println(s == &quot;ab&quot;); // false, 因为串池放入失败，s还在堆中 123456String s = new String(&quot;a&quot;) + new String(&quot;b&quot;); // 此时 s 在堆中System.out.println(s == &quot;ab&quot;); // false, ab 此时在串池中，s 在堆中String s2 = s.intern(); // s 放入串池失败，因为已经有了，返回了串池中的对象 ab 给 s2，但是 s 还在堆中System.out.println(s2 == &quot;ab&quot;); // true，因为 s2 就是串池中返回的对象，和串池中的对象 ab 相比，相等System.out.println(s == &quot;ab&quot;); // false, 因为串池放入失败，s 还在堆中 StringTable 位置 1.6：常量池的一部分，位于永久代中（永久代 Full GC 才会触发，字符串用的场景很多，但是好多都是可以回收的，内存占用太多会造成永久代内存不足）（PermGen space） 1.8：堆中的一部分（堆 Minor GC 就会触发）（Heap space） -XX:-UseFCOverheadLimit（+启用，-禁用，默认启用）：如果 98%的时间花在了垃圾回收上，但是只有 2% 的堆内存回收了，此时 JVM 直接抛出 OutOfMemoryError：GC overhead limit exceeded StringTable 性能调优StringTable 本质上是一个哈希表，哈希表性能与桶的个数有关 桶个数太大，元素分散，哈希碰撞机率减少，检索速度较快 桶个数太小，哈希碰撞机率增加，链表就会变长，查找速度就会降低 可以通过 JVM 参数调整桶的个数，-XX:StringTableSize&#x3D;12345（最小值 1009） 垃圾回收最快的 GC 是不发生 GC 如何判断对象是否能回收 引用计数法（有循环引用问题，A 引用 B，B 引用 A，都不会被回收，JVM 不是这种） 可达性分析算法（JVM 采用这种，GC Roots） 哪种可作为 Roots？(可以用 Eclipse Memory Analyzer 查看，jps -&gt; jmap -dump:format&#x3D;b,live,file&#x3D;m.bin pid) System Class（核心的类，Object, HashMap, String 等） Native Stack（操作系统方法执行时引用的 Java 对象） Thread（活动线程） Busy Monitor（被加锁的对象，回收了，就无法解锁） 四种引用 强引用（new，赋值，沿着 GC Roots 能找到，就不会被回收） 软引用（没有强引用时，发生垃圾回收，如果内存不足，再执行一次，被回收，可配合引用队列使用释放自身） SoftReference ReferenceQueue, new SoftReference(obj, queue) 当 obj 被回收时，进入队列 queue.poll() 获取自身，遍历 remove() 弱引用（没有强引用时，只要发生了垃圾回收，被回收，可配合引用队列使用释放自身） WeakReference 虚引用（必须配合引用队列使用，用于 NIO 中，由 Reference Handler 处理） PhantomReference 终结器引用（必须配合引用队列使用，finalize() 后进入队列，由 Finalizer 处理） 垃圾回收算法 标记清除：速度较快，容易产生内存碎片（空间不连续，数组放不下） 标记整理：速度较慢，没有内存碎片，标记 -&gt; 清除 -&gt; 整理（会移动对象，因此对象的引用地址会变，需要做额外的工作来更新） 复制：没有内存碎片，需要占用双倍内存空间，将内存分成大小相等的两块（from, to）发生垃圾回收时，交换位置 分代垃圾回收新生代（朝生夕死）： eden from to 垃圾回收过程（GC 都会 Stop The World，时间上新生代短一点，老年代长一点，暂停其他用户线程，让垃圾回收线程先执行完） 新对象默认存放在 eden 当空间不足时，触发 Minor GC 标记-清除-复制，把存活的复制到 to（注意不是到 from），寿命加 1 交换 from to 位置（谁是空的谁就是 to） 继续放对象 … eden 存活的复制到 to，寿命加 1 原来在 from 的移到存活后移到 to,寿命加 1 交换 from to 位置 … 寿命超过阈值（15，保存在对象头，4bit，最高 1111 -&gt; 15），晋升到老年代 如果老年代也放不下，先尝试 Minor GC, 内存还不够，触发 Full GC，再不够，抛出 OOM 大对象在新生代空间不够，但老年代空间够的情况下，直接晋升 相关 JVM 参数 参数 含义 -Xms 初始堆大小 -Xmx &#x2F; -XX:MaxHeapSize&#x3D;size 堆最大大小 -Xmn &#x2F; -XX:NewSize&#x3D;size, -XX:MaxNewSize&#x3D;size 新生代大小 -XX:InitialSurvivorRatio&#x3D;ratio, -XX:+UseAdaptiveSizePolicy 幸存区比例（动态） -XX:SurvivorRatio&#x3D;ratio 幸存区比例 -XX:MaxTenuringThreshold&#x3D;threshold 晋升阈值 -XX:+PrintTenuringDistribution 晋升详情 -XX:+PrintGCDetails -verbose:gc GC 详情 -XX:+ScavengeBeforeFullGC Full GC 前 Minor GC 线程内的 OOM 不会导致整个 JVM 挂掉 垃圾回收器 串行 单线程 适合堆内存较小，个人电脑，CPU 个数少（因为是单线程） -XX:+UseSerialGC&#x3D;Serial+SerialOld 吞吐量优先（1.8 默认） 多线程 适合堆内存较大，多核 CPU 让单位时间内，STW 的时间最短 -XX:+UseParallelGC -XX:+UseParallelOldGC -XX:+UseAdaptiveSizePolicy -XX:GCTimeRatio&#x3D;99 (1 &#x2F; 1 + ratio, 默认 99，0.01，100 分钟内只能一分钟用于垃圾回收，因为上一行配置了动态调整，所以一般会自动增加堆的大小，大小增加了，就能放更多的东西，垃圾回收的次数就会降低，吞吐量就会提高，一般设置 19) -XX:MaxGCPauseMillis&#x3D;200（毫秒，和上面的配置冲突，只能取折中，因为堆增大了，虽然 GC 次数减少，但单次的时间会增加） -XX:ParallelGCThreads&#x3D;n 响应时间优先 多线程 适合堆内存较大，多核 CPU 尽可能让单次 STW 的时间最短 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC SerialOld -XX:ParallelGCThreads&#x3D;n -XX:ConcGCThreads&#x3D;n -XX:CMSInitiatingOccupancyFraction&#x3D;percent -XX:+CMSScavengeBeforeRemark 如何区分吞吐量优先和响应时间优先？ 吞吐量优先：比如，每次花费 0.2 秒，一小时两次，共 0.4 秒，垃圾回收时间占比越低，吞吐量越高 响应时间优先：比如，每次只需 0.1 秒，但可能一小时发生了 5 次，共 0.5 秒 G1（Garbage First，JDK 9 默认，废弃 CMS） 同时注重吞吐量和低延迟，默认的暂停目标是 200ms 超大堆内存，将堆划分成多个大小相等的 Region 整体上是标记-整理，两个区域之间是复制 -XX:+UseG1GZ -XX:G1HeapRegionSize&#x3D;size -XX:MaxGCPauseMillis&#x3D;ms","categories":[{"name":"JVM","slug":"JVM","permalink":"https://linweiyuan.github.io/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://linweiyuan.github.io/tags/JVM/"}]},{"title":"Spring相关知识点","slug":"Spring相关知识点","date":"2021-07-04T13:25:16.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2021/07/04/Spring相关知识点.html","link":"","permalink":"https://linweiyuan.github.io/2021/07/04/Spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html","excerpt":"","text":"组成 aop beans context core jdbc test web 生命周期分为四个阶段 实例化 属性赋值 初始化 销毁 123456789doCreateBean() &#123; // InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation createBeanInstance() // 实例化 // InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation populateBean() // 属性赋值 // BeanPostProcessor.postProcessBeforeInitialization initializeBean() // 初始化 // BeanPostProcessor.postProcessAfterInitialization&#125; Aware 都是在初始化阶段之前调用的 设计模式 单例：Bean 默认为单例模式 工厂：BeanFactory 就是简单工厂模式的体现，用来创建对象的实例 代理：Spring 的 AOP 功能用到了 JDK 的动态代理和 CGLIB 的字节码生成技术 模板方法：用来解决代码重复的问题，比如 RestTemplate，JpaTemplate 观察者：当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被强制更新，比如 ApplicationListener 事务传播行为指的是当多个事务同时存在的时候，Spring 如何处理这些事务的行为 propagation： required：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，最常用 requires_new：无论当前存不存在事务，都创建新事务 supports：如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行 not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 never：以非事务方式执行，如果当前存在事务，则抛出异常 nested：如果当前存在事务，则在嵌套事务中执行，如果当前没有事务，则按 required 属性执行 mandatory：如果当前存在事务，就加入，不存在则抛出异常 隔离级别 isolation_default isolation_read_uncommitted isolation_read_committed isolation_repeatable_read isolation_serializable Bean 的作用域 singleton：bean 在每个 Spring IoC 容器中只有一个实例 prototype：一个 bean 的定义可以有多个实例 request：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效 session：在一个 http session 中，一个 bean 定义对应一个实例，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效 global-session：在一个全局的 http session 中，一个 bean 定义对应一个实例，该作用域仅在基 web 的 Spring ApplicationContext 情形下有效 默认是 singleton，使用 prototype 作用域需要慎重的考虑，因为频繁创建和销毁 bean 会带来很大的性能开销 单例 bean 是线程安全的吗不是，Spring 框架中的单例 bean 不是线程安全的 Spring 中的 bean 默认是单例模式，Spring 框架并没有对单例 bean 进行多线程的封装处理 实际上大部分时候 Spring bean 是无状态的（比如 dao），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view mode 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把 singleton 改成 prototype 这样请求 bean 相当于 new bean，就可以保证线程安全 有状态就是有数据存储功能 无状态就是不会保存数据 那 Spring 如何处理线程并发问题的？ 在一般情况下，只有无状态的 bean 才可以在多线程环境下共享，在 Spring 中，绝大部分 bean 都可以声明为 singleton 作用域，因为 Spring 对一些 bean 中非线程安全状态采用 ThreadLocal 进行处理，解决线程安全问题 ThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题，同步机制采用了时间换空间的方法，仅提供一份变量，不同的线程在访问前需要先获得锁，没获得锁的线程则需要排队 而 ThreadLocal 采用了空间换时间的方式，ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突，因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了，ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal 常用注解 @Component：将 Java 类标记为 bean，是任何 Spring 管理组件的通用型，Spring 的组件扫描机制扫描并用 IoC 容器进行管理 @Controller：将类标记为 Spring Web MVC 控制器，会自动导入到 IoC 容器中 @Service：基本和 @Component 一样，只是用在 service 层的话，会更好地见名知意 @Repository：除了具有 @Component 的作用外，还具有额外的作用，可以将未经检查的异常转换为 Spring DataAccessException @Autowired 和 @Resource 的区别 官方标准 @Resource：JSR250，按名称或类型注入，不支持 @Primary @Inject：JSR330，默认按类型注入，配合 @Qualifier 可实现按名称注入，配合@Primary 可选择优先注入 @Autowired：Spring 自己的实现，默认按类型注入，配合 @Qualifier 可实现按名称注入，配合 @Primary 可选择优先注入 事务隔离级别除了 MySQL 四种事务隔离级别外，多了个默认，就是数据库是什么就是什么 isolation_default isolation_read_uncommitted isolation_read_committed isolation_repeatable_read isolation_serializable IoC 容器IoC 就是控制反转，它把传统的有程序代码直接 new 的对象的调用权交给 Spring 容器，通过容器来实现对象组件的装配和管理，所谓的控制反转就是对组件对象控制权的转移，从程序代码本身转移到了外部容器 Spring IoC 负责创建对象，管理对象，装配对象，配置对象，并且管理这些对象的整个生命周期 IoC 有什么作用？ 管理对象的创建和依赖关系的维护，对象的创建并不是一件简单的事，在对象管理比较复杂时，如果依赖关系需要程序代码来维护，比较痛苦 解耦，由容器去维护具体的对象 托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的 循环依赖A 有 B，B 有 ABean 的创建过程： 获取 bean 定义 通过反射创建原始对象 填充属性（这一步就是依赖注入） 完成对象的创建放到一级缓存 A 创建的时候，通过 bean 的定义创建了一个原始对象，然后将 lambda 表达式放到三级缓存中，接着进行属性的填充，填充的时候发现 B 还没有，于是按照同样的方式来创建 B，等到 B 进行属性注入的时候，分别从一级，二级，三级缓存里面找 A，最后在三级缓存里面找到，于是将 A 放到二级缓存中，并从三级缓存中删除 A，此时的 A 是一个对象并未完成初始化好的对象，但是已经创建出来了，那么 B 属性注入成功，就放到一级缓存中，接着回到 A 的属性注入，注入完成 B 后，A 也完成了创建，就放到一级缓存中，并从二级缓存中删掉 A 为什么需要三级缓存来解决循环依赖？ 如果是普通的对象，用一级缓存就可以，但是 Spring 的对象很多都是动态代理增强的，三级缓存里存的是一个 lambda 表达式，根据对象是否有动态代理的需求，进行包装返回，这时的对象是未完成初始化的，如果不放到二级缓存直接放到一级缓存，一级缓存里会出现既有初始化完成的 bean，又有未初始化完成的，管理起来就可能会出现不可预知的错误，也不符合单一职责原则。在缓存 bean 的过程中，三个级别的缓存都是互斥的，最终都会只保留一份完成初始化的 bean，放到一级缓存里 SpringMVC 工作流程 用户发送请求到前端控制器 DispatcherServlet DispatcherServlet 收到请求后，调用 HandlerMapping 处理器映射器请求获取 Handler HandlerMapping 根据请求 url 找到具体的处理器，生成处理器对象及处理器拦截器，返回给 DispatcherServlet DispatcherServlet 调用 HandlerAdapter 处理器适配器 HandlerAdapter 经过适配调用具体处理器 Handler，也叫后端控制器 Handler 执行完成，返回 ModelAndView HandlerAdapter 将 Handler 执行结构 ModelAndView 返回给 DispatcherServlet DispatcherServlet 将 ModelAndView 传给 ViewResolver 视图解析器进行解析 ViewResolver 解析后返回具体 View DispatcherServlet 对 View 进行渲染视图，即将模型数据填充至视图中 DispatcherServlet 响应用户 解决跨域跨域可以在前端通过 JSONP 来解决，但是 JSNOP 只可以发送 GET 请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此推荐在后端通过 CORS Cross-Origin Resource Sharing 来解决跨域问题，Spring Boot 中可以通过实现 WebMvcConfigurer 接口，然后重写 addCordMappings 方法来解决跨域问题","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://linweiyuan.github.io/tags/Spring-Boot/"},{"name":"Spring","slug":"Spring","permalink":"https://linweiyuan.github.io/tags/Spring/"}]},{"title":"MySQL事务","slug":"MySQL事务","date":"2021-06-28T15:08:02.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2021/06/28/MySQL事务.html","link":"","permalink":"https://linweiyuan.github.io/2021/06/28/MySQL%E4%BA%8B%E5%8A%A1.html","excerpt":"","text":"ACID事务，首先要了解 ACID A 原子性原子性体现在回滚上面，如果 SQL 执行出错，要把之前的状态恢复，那怎么知道恢复什么呢，把之前的状态保存在 undo log 里，出错则会执行相反的操作 C 一致性事务执行完毕后，数据库的完整性约束并没有被破坏，主要是通过原子性 + 隔离性 + 持久性来保证 I 隔离性写写操作是通过锁解决，写读操作是基于 MVCC D 持久性指的是事务一旦提交，对数据库的改变就是永久性的 MySQL 为了提高效率，会有一个 buffer，每次写到 buffer 中，再定期将 buffer 中的数据刷新到硬盘上，这就会有一个问题，如果 buffer 还没来得及刷盘，MySQL 宕机了，数据就会丢失，因此，引入了 redo log，当数据库的数据进行增删改的时候，先将 本次操作记录到 redo log 中，再写 buffer，这样如果宕机了，还有 redo log 来恢复数据，这样就保证了持久性 为什么 redo log 写数据要比 buffer 写数据库快？ 因为 buffer 写盘是随机 IO，redo log 是追加的模式，是顺序 IO，效率就高，并且 buffer 持久化数据是以数据页 page 为单位的，默认是 16K，就是说一个数据页上的小小修改都要把整个数据页写入，redo log 只需要写入真正需要的部分，无效的 IO 就大大减少了，效率就提高了 读未提交：脏读，不可重复读，幻读都有可能出现 读已提交：避免脏读，可能出现不可重复读和幻读 重复读：避免脏读和不可重复读，可能出现幻读 串行化：全部避免，性能差 脏读: 一个事务修改了数据还没提交，另一个事务读到了旧数据 不可重复读: 一个事务多次读同一数据，间隔间，另一个事务把数据改了，导致两次读取结果不一样 幻读: 一个事务对全表数据进行修改，另一个事务往表中新增数据，修改完成后莫名其妙出现了没有修改到的数据 MySQL 的 InnoDB 默认是 RR，为什么可以解决幻读？ 因为默认开启了间隙锁，这样就防止了两次 select 之间，有另外的事务进行增删操作","categories":[{"name":"数据库","slug":"数据库","permalink":"https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://linweiyuan.github.io/tags/MySQL/"}]},{"title":"MySQL锁","slug":"MySQL锁","date":"2021-06-25T15:03:53.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2021/06/25/MySQL锁.html","link":"","permalink":"https://linweiyuan.github.io/2021/06/25/MySQL%E9%94%81.html","excerpt":"","text":"行锁update 的时候行级锁，如果未 commit，另一个事务会尝试拿锁，超时则报错 表锁索引失效，行锁会升级为表锁，比如 update 的时候有 or，这样就算在一个事务中 update id &#x3D; 1 or id &#x3D; 2，另一个事务要 update id &#x3D; 3，也会阻塞，一旦发生表锁，并发度是比较低的，所以要避免索引失效 间隙锁一般发生在范围查询里面，把整个范围加锁，如果要在这个范围内插入新数据，也会阻塞，性能影响也是比较大的 1show status like &#x27;innodb_row_lock%&#x27;; 可以看到一些锁相关数据","categories":[{"name":"数据库","slug":"数据库","permalink":"https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://linweiyuan.github.io/tags/MySQL/"}]},{"title":"MySQL索引相关","slug":"MySQL索引相关","date":"2021-06-18T14:04:59.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2021/06/18/MySQL索引相关.html","link":"","permalink":"https://linweiyuan.github.io/2021/06/18/MySQL%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3.html","excerpt":"","text":"B+ 树要了解索引，首先要了解 MySQL 的 B+树数据结构 为什么是 B+ 树？ 和 B 树相比，多了箭头，称为叶子节点，其实就是一个单向链表，进行了排序，解决了回旋查找的问题 非叶子节点只存 key，叶子节点既存 key 又存 value（数据地址） 聚簇索引聚簇索引就是把数据和索引放在一个文件里面，叶子节点保存行数据，数据按照索引的顺序来进行存储，也就是说索引项的顺序和表中记录的物理顺序一致，InnoDB 中，在聚簇索引之上创建的索引称为辅助索引，比如复合索引，前缀索引，唯一索引等 聚簇索引是一个概念，默认实现是是主键 如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替 如果没有唯一非空的索引，InnoDB 会在内部生成一个名为 GEN_CLUST_INDEX 的隐式的聚簇索引 在数据（索引）文件中，非叶子节点保存的是主键，叶子节点保存的是真实数据，因为只有一个文件 辅助索引中，非叶子节点保存的是字段的值（排序），叶子节点保存的是该条记录的主键 ID 值 所以，如果是主键索引，只需查一次，一定程度上会比 MyISAM 快，但是辅助索引要查到 ID 再到主键索引查数据，要查两次，一定程度上会比 MyISAN 慢 为什么不能 select *，要尽可能使用覆盖索引？ 如果是查单个字段，在这个字段上建立了索引，只需查一次就能拿到该字段数据，如果 select *，那就要查到 ID，再根据 ID 来查询全部，查两次 非聚簇索引将数据和索引分开存储，表数据存储顺序和索引顺序无关 在索引文件中，非叶子节点保存的是主键，叶子节点保存的是主键和数据在数据文件中的地址 索引设计原则 尽量在只需要查询到的字段上加索引（where） 基数小的字段不加索引（出现重复的越多越不加， 唯一才能查询快） 如果字符串太长但是前面不重复， 使用短索引（根据前面几个字符就能确定唯一） 不要过度使用索引， 占用磁盘空间， 更新操作影响性能 建立索引的字段， 尽量不要有 null（not null + 默认值） like 查询中前导模糊查询不能命中索引（like ‘%a%’ 不走索引，like ‘a%’ 走） 如果字段是字符串， 查询时用整形， 索引失效 复合索引（最左原则， 查询条件如果不包含第一个字段， 索引失效） sql 查询 cpu 开销：or &gt; in &gt; union or 查询如果前面的条件有索引， 后面没有， 索引失效 否定查询索引失效（!&#x3D;， &lt;&gt;， not in， not exists， not like） 用 explain 来分析 sql 性能 索引失效原理针对联合索引的情况，数据保存的时候，是有顺序的，两个字段 a 和 b，先按 a 排序，在 a 相同的情况下按 b 排序，所以如果直接查 b，是无序的，因此不走索引，要全表扫描，范围查找，模糊查询也是这个道理 索引优化 最左前缀法则：如果建立的是复合索引，索引的顺序要按照建立时的顺序，即从左到右（和 B+ 树的数据结构有关），比如 abc，在这种情况下： abc：有效 ac：a 有效 c 无效 bc：bc 都无效 c：无效 不要对索引进行如下处理： 计算：如加减乘除，不等，is null， is not null， or 函数：如 sum()， round()等 类型转换：如 id &#x3D; ‘1’，本来是数字写成了字符串 索引不要放在范围查找的右边 减少 select * 的使用 like 模糊查询：只留右边的百分号，那是否两个百分号没得优化呢，也不是，可以使用覆盖索引，所谓覆盖索引就是 select 查询的字段和 where 里的字段是一致的，也会走索引 order by 优化，避免出现 Using filesort 文件内排序，所谓 filesort，就是说它没有按照索引本身来进行排序，而是在外面开辟了一块内存，把数据复制进去进行排序，这样内存就会被多占用一份空间，而内存是比较宝贵的资源，比较影响性能 其实也可以考虑不在 MySQL 里排序，而在代码里进行排序","categories":[{"name":"数据库","slug":"数据库","permalink":"https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://linweiyuan.github.io/tags/MySQL/"}]},{"title":"MySQL存储引擎","slug":"MySQL存储引擎","date":"2021-05-20T14:03:11.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2021/05/20/MySQL存储引擎.html","link":"","permalink":"https://linweiyuan.github.io/2021/05/20/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html","excerpt":"","text":"InnoDB 和 MyISAM 的区别 InnoDB 支持事务，MyISAM 不支持，这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一 InnoDB 支持外键，MyISAM 不支持，对一个包含外键的 InnoDB 表转为 MyISAM 会失败 InnoDB 是聚集索引（聚簇索引），MyISAM 是非聚集索引 InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁，这也是默认存储引擎改变的重要原因之一 MyISAM 在硬盘上存储为三个文件 .frm：表的定义 .myd：数据文件 .myi：索引文件 InnoDB 是两个文件（没有专门保存数据的文件） .frm：表的定义 .ibd：数据和索引文件，数据也会保存在叶子节点中 全文索引都支持","categories":[{"name":"数据库","slug":"数据库","permalink":"https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://linweiyuan.github.io/tags/MySQL/"}]},{"title":"MVCC","slug":"MVCC","date":"2021-05-15T13:57:08.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2021/05/15/MVCC.html","link":"","permalink":"https://linweiyuan.github.io/2021/05/15/MVCC.html","excerpt":"","text":"MVCCMulti Version Concurrency Control 多版本并发控制 什么是 MySQL InnoDB 下的当前读和快照读？ 快照读：一般的 select 都是快照读（事务级别不是串行化），基于 MVCC 实现，既然如此，读到的数据就不一定是当前最新的数据，有可能是之前历史版本的数据 当前读：读取的数据是当前最新的版本，会对数据进行加锁，防止其他事务修改，属于悲观锁 selet in share mode（共享锁） select for udate（排他锁） update， insert， delete（排他锁） 串行化事务隔离级别 MVCC 是怎么实现的？ 表中一行数据包含数据本身，事务 ID（自增）和回滚指针 undo log 版本链 readview creator_id：表示生成该 readview 的事务的事务 id m_ids： 表示在生成 readview 时当前系统中活跃的读写事务的事务 id 列表，活跃指的就是还没 commit min_trx_id：表示在生成 readview 时当前系统中活跃的读写事务中的最小事务 id，也就是 m_ids 最小值，第 0 个元素 max_trx_id：表示生成 readview 时系统中应该分配给下一个事务的 id（和 min 不同，max 不是 m_ids 最后一个，而是下一个） trx_id 是数据库中数据的 trx_id trx_id &#x3D;&#x3D; creator_trx_id：可以正常访问，场景可能是 update 了后，马上开始 select trx_id &lt; min_trx_id：可以访问，表示 trx_id 已经是提交的了 trx_id &gt; max_trx_id：不可以访问，已经超出版本链了 min_trx_id &lt;&#x3D; trx_id &lt;&#x3D; max_trx_id：如果 trx_id 在 m_ids 里，不可以访问，不在则可以","categories":[{"name":"数据库","slug":"数据库","permalink":"https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://linweiyuan.github.io/tags/MySQL/"},{"name":"MVCC","slug":"MVCC","permalink":"https://linweiyuan.github.io/tags/MVCC/"}]},{"title":"List, Set, Map相关知识点","slug":"List-Set-Map相关知识点","date":"2021-04-30T13:47:24.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2021/04/30/List-Set-Map相关知识点.html","link":"","permalink":"https://linweiyuan.github.io/2021/04/30/List-Set-Map%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html","excerpt":"","text":"HashMap 和 HashTable 的区别线程安全HashMap 是非线程安全的，HashTable 是线程安全的，HashTable 内部的方法基本都经过 synchronized 修饰，HashMap 有线程安全版本的实现 ConcurrentHashMap 效率因为线程安全的问题，HashMap 要比 HashTable 效率高一些，HashTable 基本已经被淘汰了 null 的支持HashMap 中可以将 null 设为 key（hashCode 为 0）,但是只允许有一个，value 为 null 可以有多个 HashTable 中 key 或 value 任何一个 null 都会有 NullPointerException（value 如果判断是 null 直接抛出 NPE，key 没有判断，但是 key 如果为 null,key.hashCode()就会报 NPE）(ConcurrentHashMap 无论 key 还是 value 为 null，都会主动抛 NPE) 初始容量和扩容创建时如果不指定容量初始值，HashTable 默认的初始大小为 11，每次扩容，容量变为原来的 2n + 1；HashMap 的默认初始化大小为 16,每次扩容，容量变为原来的两倍 如果指定了初始值，HashTable 会直接用这个值，HashMap 会用 tableSizeFor()方法将其扩充为 2 的幂次方 底层数据结构JDK 1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）并且数组长度大于 64,会将链表转为红黑树，以减少搜索时间，当红黑树节点低于 6 时，转回链表 HashTable 没有这样的机制 HashMap 和 HashSet 的区别HashSet 底层就是基于 HashMap 来实现的，HashSet 执行 add(xxx)的时候，把 xxx 作为 key 放到 map 里，key 对应的 value 是一个无意义 new Object()，因为 map 中的 key 是唯一的，所以 set 存的元素不能重复 HashMap JDK1.7 和 JDK1.8 的区别 JDK 1.7 之前是数组加链表，JDK 1.8 后也属数组加链表，如果哈希冲突严重则转换为红黑树 JDK 1.7 头插法（先将原位置的数据移到后一位，再插入数据到该位置），JDK 1.8 尾插法（直接插入到链表尾部&#x2F;红黑树），尾插法能解决并发下的死循环问题 HashMap 加载因子为什么不能是 0.5 或者 1.0，而是 0.75 如果是 1.0，只有当 HashMap 满了才会扩容，哈希计算出来的结果很难说刚好落在每一个空的位置上，所以发生扩容的时候，很大程度上 HashMap 已经发生了多次哈希冲突了，如果 HashMap 变成了链表或者红黑树，则对元素操作的时间就会增加，运行效率就会降低，影响性能，属于时间换空间 如果是 0.5，当 HashMap 放了一半元素时则扩容，但是每次当一半的时候就扩容，则至少有一半的空间是永远用不到，造成了内存的浪费，相对地，哈希冲突概率减少，元素操作时间也会减少，属于空间换时间 HashMap 源码的注释，0.75 是一个平衡点 1As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur. HashMap 扩容流程流程： 判断当前容量大小是否为空，如果为空（未设置容量初始值），则把容量扩充为 16 获取 key 的 hashCode，对 hashCode 进行扰动处理，计算出元素的下标 根据下标判断有无 hash 碰撞，如果没有，则直接放入桶中 如果发生碰撞，比较两个 key 是否相等，相等则将新值覆盖旧值，不相等则以链表的形式插入到尾部 如果插入后链表的长度超过了阈值 8，并且数组长度大于 64，则将链表转换为红黑树 插入成功后，如果元素个数达到了阈值（初始容量 * 负载因子），则进行扩容操作 扩容成功后，对元素的下标进行重新计算 ArrayList 和 LinkedList 的区别ArrayList基于动态数组，连续内存存储，随机访问（下标）快，增删满（因为长度固定，扩容需要复制原数组） LinkedList基于链表，存储在分散的内存中，增删快，查询慢，需要逐一遍历。遍历时候用迭代器，如果用 fori，每次都要 list.get(i)，重新进行遍历，性能消耗极大（可以用增强性 for 循环 forEach，内部实现也是迭代器） ArrayList 和 Vector 的区别相同点 两个类都继承了相同的类，实现了相同的接口 底层都属 Object 数组 默认的初始化长度都是 10 不同点 Vector 使用了 synchronized 来实现线程同步，是线程安全的，而 ArrayList 不是线程安全的 扩容的时候，ArrayList 扩容成原来的 1.5 倍，Vector 扩容成 2 倍 List 和 Set 的区别List有序，按对象进入的顺序来保存，可重复，允许多个 null 元素，可以使用迭代器遍历，或者下标的方式 Set无序，不可重复，最多一个 null 元素，只能用迭代器遍历 为什么 Set 最多只能放一个 null 元素？ 以用得比较多的 HashSet 为例，内部的添加元素方法 add 方法的实现是这样的 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 其中的 map 就是一个 HashMap 1private transient HashMap&lt;E,Object&gt; map; map 的 value PRESENT 是一个空对象 1private static final Object PRESENT = new Object(); 所以在 HashSet 中添加元素，其实最终是执行了 HashMap 的 put 方法，把这个元素当作一个 key 存进去，value 则是空对象 HashMap 的 put 方法会对 key 进行一个 hash 计算，算出来 hashCode 确定存放的位置，而当 key 是 null 的时候，hashCode 会是 0，所以如果在 HashSet 中添加了多个 null，全部都是会放到 HashMap 中 hashCode 为 0 的位置 12345678public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 所以这就是为什么 HashSet 的元素不可重复，或者只能放一个 null HashSet 存储的元素是否有序无序 HashSet 是 Set 的一个实现类，底层是基于 HashMap 实现的，HashSet 存储的元素对应 HashMap 的 key，因为 HashMap 不能存储重复的 key，所以 HashSet 不能存储重复元素 由于 HashMap 的 key 是基于 hashCode 的，所以 HashSet 中存储的对象是无序的 HashSet 没有提供 get 方法，只能通过 Iterator 迭代器获取数据 有一种情况是 HashSet 中存放的是纯数字，因为子类一般会重写父类的方法，hashCode() 是 Object 的，Integer 在实现的时候，把当前 int 值直接当作 hashCode 返回，所以遍历起来造成一种有序的假象 集合快速失败机制首先要说明为什么 Java 集合遍历，不是集合类实现 Iterator，而是返回它的迭代器对象？ 因为如果是集合本身去实现，那么可能你访问的是别人遍历的数据 而每次返回新的迭代器，遍历数据时就会互不影响，做到隔离性和独立性（forEach 循环的底层实现就是迭代器） 集合本身有一个 modCount 属性用来保存集合增删操作的次数，因为迭代器是集合的成员内部类，所以可以随时访问集合的成员属性，所以当获取到集合的迭代器的时候，比如当前 modCount 是 3，next() 的时候判断，获取到的 3 和集合当前的 3 还是一样，则正常执行，否则报错 throw new ConcurrentModificationException() 那有没有办法可以解决这个问题呢？ CopyOnWriteArrayList，增删元素时，创建新数组，复制原数组，写的时候加锁，写在新数组，读的时候不加锁，读在旧数组（适用于读多写少，数据量不大的场景）","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"}]},{"title":"Java锁相关知识点","slug":"Java锁相关知识点","date":"2021-03-12T05:07:40.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2021/03/12/Java锁相关知识点.html","link":"","permalink":"https://linweiyuan.github.io/2021/03/12/Java%E9%94%81%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html","excerpt":"","text":"synchronizedsynchronized 有三种使用方式： 作用于普通方法：锁的是当前类实例对象 作用于静态方法：锁的是当前类的 class 对象 作用于代码块：锁的是括号里面的对象 当一个线程访问同步代码块时，需要获得锁才能执行里面的代码，反过来，当退出同步代码块或者发生异常的时候要释放锁，通过 javap -v 进行代码的反编译可以看到是通过 monitorexter 和 monitorexit 指令实现的，当 monitor 被线程持有后，就处于锁定状态，也就是上锁了 12345678910111213141516171819202122232425262728293031323334353637public void test(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: aload_0 1: dup 2: astore_1 3: monitorenter 4: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 7: ldc #3 // String Test 9: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 12: aload_1 13: monitorexit 14: goto 22 17: astore_2 18: aload_1 19: monitorexit 20: aload_2 21: athrow 22: return Exception table: from to target type 4 14 17 any 17 20 17 any LineNumberTable: line 4: 0 line 5: 4 line 6: 12 line 7: 22 StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 17 locals = [ class Test, class java/lang/Object ] stack = [ class java/lang/Throwable ] frame_type = 250 /* chop */ offset_delta = 4 当一个线程进入了一个对象的 synchronized 方法后，其他线程是否可以进入这个对象的其他方法？ 需要分情况讨论： 如果这个方法是 synchronized 修饰的，不能，除非上面释放锁，如果没有加 synchronized，则可以进入 如果这个方法内部有调用 wait() 方法，wait() 会释放锁（sleep() 不会），则可以进入其他 synchronized 方法 如果其他方法是静态方法，可以进入，因为静态方法锁的是当前类的 class 对象，非静态的方法锁的是当前类建出来的对象，不是用一个东西 synchronized 和 ReentrantLock 的区别 synchronized ReentrantLock 是关键字，是 JVM 层面的实现，通过操作对象头中 mark word 来加锁 是类，是 JDK 层面的实现，通过 Unsafe 类的 park 方法来加锁，这是两者的本质区别 自动释放锁 要手动释放 是非公平锁 可以设置 不能获取锁状态 可以获取锁的状态，并且可以设置等待时间来避免死锁 可以锁方法或者代码快 只能锁代码块 volatile具有三个特性： 保证可见性：程序中定义的共享变量存在主内存，每个线程中的变量是在工作内存中操作的，当一个线程 A 修改了主内存中的一个共享变量，这个时候线程 B 是不知道这个变量已经被修改了，因为线程之间的工作内存是互相不可见的，那么这个时候 volatile 的作用就是让线程 A 和 B 都可以感知到对方对共享变量的修改，当线程 A 更新了共享变量，会将数据写回主内存中，而线程 B 每次去读共享变量时去主内存中读取，这样就保证了线程之间的可见性。这种保证可见性的机制是内存屏障（memory barrier）： Load Barrier：读屏障 Store Barrier：写屏障 内存屏障有两个作用： 禁止屏障两侧的指令重排序优化 强制把缓存中的脏数据写回主内存，并让缓存中的数据失效（这不就是 MySQL 和 Redis 那一套） 不保证复合操作的原子性：所谓原子性，就是说一个操作不可被分割，要么全部执行，要么全部不执行。Java 只保证了基本数据类型的变量和赋值操作是原子性的（在 32 位的 JDK 环境下，对 64 位数据的读取不是原子性操作） 禁止指令重排序（有序性）：有序性指程序执行的顺序按照代码的先后顺序执行。一般来说，处理器为了提高程序运行效率，可能会对输入的代码进行优化，它不保证程序中每个语句的执行先后顺序同代码中的数据一直，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。要进行重排序，需要满足两个条件： 在单线程环境下，程序运行的结果不能改变 如果数据存在依赖关系，不允许重排序 volatile 的使用场景： 双重检测单例 立 flag synchronized 和 volatile 的区别 volatile synchronized 只能修饰变量 可以修饰类、方法、代码快 仅能实现变量的修改可见性，不能保证原子性 可以保证变量的修改可见性和原子性 不会造成线程的阻塞 可能会造成线程的阻塞","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"Netty","slug":"Netty","permalink":"https://linweiyuan.github.io/tags/Netty/"},{"name":"NIO","slug":"NIO","permalink":"https://linweiyuan.github.io/tags/NIO/"}]},{"title":"String, StringBuffer, StringBuilder","slug":"String-StringBuffer-StringBuilder","date":"2020-12-28T13:17:54.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2020/12/28/String-StringBuffer-StringBuilder.html","link":"","permalink":"https://linweiyuan.github.io/2020/12/28/String-StringBuffer-StringBuilder.html","excerpt":"","text":"String 是 final 的，每次操作都会产生新的 String StringBuffer 和 StringBuilder 都是在原对象基础上操作 StringBuffer 线程安全（内部采用 synchronized 来实现），StringBuilder 线程不安全 性能：StringBuilder &gt; StringBuffer &gt; String 优先使用 StringBuilder，多线程共享变量时使用 StringBuffer","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"}]},{"title":"hashCode()和equals()","slug":"hashCode-和equals","date":"2020-12-25T12:04:41.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2020/12/25/hashCode-和equals.html","link":"","permalink":"https://linweiyuan.github.io/2020/12/25/hashCode-%E5%92%8Cequals.html","excerpt":"","text":"以 HashSet 为例，因为 hash 算法相对来说比较高效，如果两个对象 hashCode 不一样，则这两个对象是不同的对象，省去了遍历 set 逐个对此是否相同 如果两个对象相等，则 hashCode 一样，调用 equals 对比为 true 但是反过来如果两个对象的 hashCode 相等，这两个对象则不一定相同（hash 冲突），需要再通过 equals 进一步判断 如果重写了 equals，也要重写 hashCode，因为有可能出现两个对象内容相等但是地址不相同的情况，存放也会造成重复 因此: hashCode() 用来在最快时间内判断两个对象是否相等，并定位索引位置，但可能出现误差，用来保证效率 equals() 用来保证可靠","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"}]},{"title":"Final修饰符","slug":"Final修饰符","date":"2020-12-20T13:16:07.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2020/12/20/Final修饰符.html","link":"","permalink":"https://linweiyuan.github.io/2020/12/20/Final%E4%BF%AE%E9%A5%B0%E7%AC%A6.html","excerpt":"","text":"修饰类：不可继承 修饰方法：不可重写，但可重载 修饰变量：一旦被赋值则不能再更改（数组不能再赋值，但是里面的值是可变的） 为什么内部类和匿名内部类只能访问局部 final 变量？当外部类的方法结束时，外部类的局部变量理应销毁了，但是内部类可能还存在（比如线程还在跑），此时内部类访问外部类的变量，就会出现矛盾，这个变量不存在，所以就要把外部类的变量复制一份到内部类，给它使用，但是，不能让这个变量在内部类中被修改后，影响到外部类，可能会出现问题，所以只能是 final 或者可以用另一种方法，利用原子类的 CAS 特性来设置变量值","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"}]},{"title":"==和equals","slug":"==和equals","date":"2020-11-03T13:13:34.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2020/11/03/==和equals.html","link":"","permalink":"https://linweiyuan.github.io/2020/11/03/==%E5%92%8Cequals.html","excerpt":"","text":"&#x3D;&#x3D; 对比的是栈中的值 如果是基本数据类型，栈中存变量值；如果是引用类型，栈中存的是堆中内存对象的地址 Object 的 equals 也是用 &#x3D;&#x3D; 对比 123public boolean equals(Object obj) &#123; return (this == obj);&#125; String 继承 Object，为什么 String 的 equals 能对比到实际的值？ 因为 String 的 equals 重写了，首先判断栈中地址是否相等，不想等则进一步判断字符串内容 12345678910111213public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String aString = (String)anObject; if (coder() == aString.coder()) &#123; return isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); &#125; &#125; return false;&#125;","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"}]},{"title":"分布式Session的几种实现方式","slug":"分布式Session的几种实现方式","date":"2020-10-01T09:01:37.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2020/10/01/分布式Session的几种实现方式.html","link":"","permalink":"https://linweiyuan.github.io/2020/10/01/%E5%88%86%E5%B8%83%E5%BC%8FSession%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html","excerpt":"","text":"包括但不限于： 粘性 Session每次请求都会转发到指定的机器，比如 Nginx 的 ip_hash，将用户和机器绑定起来，造成单机的效果，实现起来较为简单，只需加一些额外的配置 但是这种方式有一定的局限性，一旦当前服务器发生故障，用户会被转发到其他服务器上，Session 信息就会丢失 Session 复制这种方式需要服务器的支持，每当 Session 发生改变，该节点就会自动将 Session 内容广播给其他节点 因此对服务器的带宽有一定的占用，如果数据量过多，可能会对请求的响应造成一定的影响 Session 共享可以将 Session 信息存入 Redis 缺点就是每次引入第三方中间件，都要考虑可靠性问题，挂了怎么办 Session 持久化到数据库持久化 Session 有一个好处就是当服务器发生故障的时候，Session 不会丢失 缺点就是给数据库造成了额外的负担 Cookie将数据放在 Cookie 里，实现起来也比较简单 只是数据放在浏览器里是不安全的，不能放敏感数据","categories":[{"name":"架构设计","slug":"架构设计","permalink":"https://linweiyuan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://linweiyuan.github.io/tags/Redis/"},{"name":"Session","slug":"Session","permalink":"https://linweiyuan.github.io/tags/Session/"},{"name":"Cookie","slug":"Cookie","permalink":"https://linweiyuan.github.io/tags/Cookie/"}]},{"title":"如何生成分布式系统全局唯一ID","slug":"如何生成分布式系统全局唯一ID","date":"2020-09-10T08:43:10.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2020/09/10/如何生成分布式系统全局唯一ID.html","link":"","permalink":"https://linweiyuan.github.io/2020/09/10/%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID.html","excerpt":"","text":"方案有很多，包括但不限于以下几种 UUIDRedis利用 INCR 命令，INCR 命令是一个原子操作，Redis 又是单线程 MongoDB利用 ObjectId，ObjectId 由 4 部分组成（时间戳，机器标识符，进程 ID，自增计数器） 只能说重复的概率可以忽略不计 ZooKeeper可以利用 ZooKeeper 的顺序节点来完成，当创建顺序节点时，ZooKeeper 会根据创建的时间顺序，在节点名称后面添加 10 位的顺序编号 Snowflake推特的雪花算法，趋势递增，一般不会重复，除非修改系统时间","categories":[{"name":"架构设计","slug":"架构设计","permalink":"https://linweiyuan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://linweiyuan.github.io/tags/Redis/"},{"name":"UUID","slug":"UUID","permalink":"https://linweiyuan.github.io/tags/UUID/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://linweiyuan.github.io/tags/MongoDB/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://linweiyuan.github.io/tags/ZooKeeper/"},{"name":"Snowflake","slug":"Snowflake","permalink":"https://linweiyuan.github.io/tags/Snowflake/"}]},{"title":"Kotlin动态代理","slug":"Kotlin动态代理","date":"2020-08-27T19:59:12.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2020/08/27/Kotlin动态代理.html","link":"","permalink":"https://linweiyuan.github.io/2020/08/27/Kotlin%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html","excerpt":"","text":"1method!!.invoke(obj, *(args ?: emptyArray())) 相比之下Java的方式 1method.invoke(obj, args);","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://linweiyuan.github.io/tags/Kotlin/"}]},{"title":"JDK1.8新特性","slug":"JDK1-8新特性","date":"2020-07-14T08:35:31.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2020/07/14/JDK1-8新特性.html","link":"","permalink":"https://linweiyuan.github.io/2020/07/14/JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7.html","excerpt":"","text":"其实这个时间点还来谈 JDK 1.8 的新特性是有点不合时宜的，毕竟 JDK 都出到几了，但是在大环境下（国内，国外不知道），只要 Spring 不出致命漏洞，JDK 1.8 在 2026 年之前还是主流，毕竟谁没事去重构老系统，新系统开发可遇不可求 函数式编程 &#x2F; lambda比如获取最小值的实现方式之前，啰嗦 12345678int[] a = &#123;0, 1, 2, 3, -1, -2, 10&#125;;int min = Integer.MAX_VALUE;for (int i : a) &#123; if (i &lt; min) &#123; min = i; &#125;&#125;System.out.println(min); 之后 1System.out.println(IntStream.of(a).min().getAsInt()); 函数接口1@FunctionalInterface 只能有一个待实现的方法（可有很多默认方法） 函数式编程可链式调用 接口 输入参数 返回类型 说明 Predicate T boolean 断言 Consumer T 无 消费一个数据 Function&lt;T, R&gt; T R 输入 T 输出 R 的函数 Supplier 无 T 提供一个数据 UnaryOperator T T 一元函数（输入输出类型相同） BiFunction&lt;T, U, R&gt; (T, U) R 2 个输入相同的函数 BinaryOperator (T, T) T 二元函数（输入输出类型相同） 基本数据类型的演变 Predicate -&gt; IntPredicate，其他的类似 方法引用非静态方法，使用对象的实例来引用 使用类名来访问，因为 JDK 自带了第一个参数在方法里，内容是 this（不显示），所以用 BiFunction 1Consumer&lt;String&gt; consumer = System.out::println; 构造函数的方法引用 Java 是值传递 类型推断变量引用JDK 1.8 之前，匿名函数内部访问外部的变量，外部变量要为 final；lambda 则可不写 final（但变量不能改，否则编译出错） Stream 流编程 外部迭代：fori 内部迭代：并行流","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"}]},{"title":"缓存和数据库一致性的保障方案","slug":"缓存和数据库一致性的保障方案","date":"2020-06-07T08:02:32.000Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"2020/06/07/缓存和数据库一致性的保障方案.html","link":"","permalink":"https://linweiyuan.github.io/2020/06/07/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E4%BF%9D%E9%9A%9C%E6%96%B9%E6%A1%88.html","excerpt":"","text":"业界流行的有下面几种，不能说孰优孰劣，只能具体问题具体分析，软件开发没有银弹 同步删除同步删除说明了是同步，所以流程的处理就是一步一步来，先更新数据库的数据，再对缓存进行删除 没有问题吗？ 假如并发场景下，有两条线程，一条线程查询了数据库，还没来得及写缓存，但是另一条线程更新了这条数据库记录，并完成了写缓存操作，这时原来的线程再回过头来写缓存，就会有脏数据 又假如本来是应该在 API 里进行数据的更新的，但是有人直接连上数据库进行 update，这样数据库的数据是被删掉了，但是在 API 的层面并不知道，所以缓存中的数据还是旧的 再加入同步删除过程中发生异常了，也会存在脏数据问题 延时双删延时双删顾名思义就是延时 + 双删，先删一次缓存，接着更新数据库，休眠毫秒级的时间，再删一次缓存 没有问题吗？ 到底要休眠多久，这个要看具体的业务需求 数据库主从架构下，写主库，数据同步到从库需要一定的时间，不能保证强一致性，万一双删后数据还没同步完成，此时有请求过来了，就缓存了旧数据 监听 binlog监听 binlog 其实解决了同步删除的场景下，通过 API 外操作数据库的问题 比如用 Canal，只要你更新数据库，无论你是正常请求 API 更新，还是直接连数据库，都能监听到，然后就能对缓存进行删除 没有问题吗？ 和消息队列一样，解耦了，吞吐量提高了，但是严重依赖第三方中间件，Canal 挂了怎么办","categories":[{"name":"架构设计","slug":"架构设计","permalink":"https://linweiyuan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://linweiyuan.github.io/tags/Redis/"},{"name":"MySQL","slug":"MySQL","permalink":"https://linweiyuan.github.io/tags/MySQL/"}]},{"title":"Spring Boot事务什么时候会失效","slug":"Spring-Boot事务什么时候会失效","date":"2020-05-01T03:58:34.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2020/05/01/Spring-Boot事务什么时候会失效.html","link":"","permalink":"https://linweiyuan.github.io/2020/05/01/Spring-Boot%E4%BA%8B%E5%8A%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88.html","excerpt":"","text":"Spring Boot 的事务管理是依赖 AOP 的，AOP 又与反射和动态代理关系密不可分，所以，有下面几种方式，包括 Spring 本身，数据库本身的配置是否合理 bean 对象没有被 Spring 容器管理 方法的访问修饰符不是 public 自身调用 数据源没有配置事务管理器 数据库不支持事务 异常被捕获 异常类型错误或者配置错误","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://linweiyuan.github.io/tags/Spring-Boot/"}]},{"title":"微信开发的坑","slug":"微信开发的坑","date":"2020-04-27T08:12:13.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2020/04/27/微信开发的坑.html","link":"","permalink":"https://linweiyuan.github.io/2020/04/27/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%9A%84%E5%9D%91.html","excerpt":"","text":"参数部分xml, 部分json 接口校验首次校验接口SHA-1参数值字典序, 其他接口MD5参数值key, value字典序 微信支付企业付款: 参数mch_appid, mchid, 旁边签名算法链接的示例整个appid, mch_id支付验收指引 就是sandbox 参数又变成mch_id 不能输入随意金额","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://linweiyuan.github.io/tags/Kotlin/"},{"name":"WeChatPay","slug":"WeChatPay","permalink":"https://linweiyuan.github.io/tags/WeChatPay/"}]},{"title":"Spring Boot跨域配置","slug":"Spring-Boot跨域配置","date":"2020-03-13T07:54:05.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2020/03/13/Spring-Boot跨域配置.html","link":"","permalink":"https://linweiyuan.github.io/2020/03/13/Spring-Boot%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE.html","excerpt":"","text":"前后端跨域问题解决方案多种多样，前端可以通过中间件解决，因为跨域发生在浏览器的 XHR 中，普通的 HTTP 请求是正常的 另一种是在网关那里进行配置，比如利用 Nginx 做反向代理或者负载均衡，可以在 Nginx 上面配置对应的响应头 如果要在 API 的层面进行配置，Spring Boot 提供了多种方式，下面是其中一种 1234567891011@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;) .maxAge(3600); &#125;&#125;","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://linweiyuan.github.io/tags/Spring-Boot/"},{"name":"CORS","slug":"CORS","permalink":"https://linweiyuan.github.io/tags/CORS/"}]},{"title":"Docker相关知识点","slug":"Docker相关知识点","date":"2020-02-12T06:44:54.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2020/02/12/Docker相关知识点.html","link":"","permalink":"https://linweiyuan.github.io/2020/02/12/Docker%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.html","excerpt":"","text":"容器和虚拟机的比较 特性 容器 虚拟机 启动速度 秒级 分钟级 性能 接近原生 较弱 内存代价 很小 较多 硬盘使用 一般为 MB 一般为 GB 运行密度 单机支持上千个容器 一般几十个 隔离性 完全隔离 完全隔离 迁移性 优秀 一般 镜像自身是只读的，容器从镜像启动的时候，会在镜像的最上层创建一个可写层 Dockerfiledockerfile 一般格式 12345678FROMENVRUNADD（自动解压）COPY（不自动解压）EXPOSECMDENTRYPOINT .dockerignore 忽略 build 的内容 基础镜像 alpineapk –update add –no-cache 这样可以大幅度减少构建出来的 docker 镜像的大小 神秘镜像 scratch其实这个镜像你去拉是会报错的，更多的是一种类似约定的东西，告诉 Docker，这个就是一个空的东西 1FROM scratch 基本概念docker 本质上是一个 C&#x2F;S 架构 docker 服务端 unix://var/run/docker.socket 如果要以端口的方式暴露，则需要修改执行命令，设置地址和端口，比如 docker daemon -H 0.0.0.0:1234 客户端如果要连接不同的服务端，也需要额外指定，比如 docker -H tcp://127.0.0.1:1234 version 命令 ip addr show docker0 能看到 docker 网卡的相关信息 docker registry 可以配置 hooks 通知（pull or push） docker 第三方安全检测工具： docker -&gt; docker bench CoreOS -&gt; clair 容器里的网络 eth0 &lt;-&gt; docker0 网桥上的 vethXXX（veth pair，当数据包发送到一个接口时另外一个接口也可以接收到相同的数据包） docker 的 link 主要是添加一个所连接容器的主机名到容器内的&#x2F;etc&#x2F;hosts 文件中 查看 docker 网络信息 docker network ls docker 网络分三种：null、host、bridge etcd简单: RESTful 接口安全: 基于 HTTPS快速: 支持每秒 1000 个写操作可靠: 基于 Raft 算法 节点个数推荐为奇数个，最少为 3 个 越多节点能提供更多的冗余性，但会带来写数据性能的下降 Docker Swarmdocker swarm 也支持调度，亲和性这些 k8s 的概念 KubernetesPod 为什么不能通过 IP 访问？ 因为 Pod 随时可能会发生故障，重启后可能会被调度到其他节点上，IP 地址就会改变 通过 Service 来访问，Service 被创建后，会自动分配一个 Cluster IP，基于 kube-proxy 实现 kube-proxy 维护节点上的网络规则，作用是使发往 Service 的流量（ClusterIP + 端口）负载均衡到正确的后端 Pod Label 主要是用来分类资源，比如 name&#x3D;nginx，release&#x3D;alpha|beta，有长度限制 Annotation 则主要是给对象增加更丰富的描述信息，可以是任意的，数据量可以很大，可以包含结构化或非结构化数据 Namespace类似于租户的概念，同一个命名空间的资源不允许重名，但不同命名空间下则允许 default: 资源未指定命名空间的情况下，默认属于该命名空间 kube-system：由 Kubernetes 自身创建的资源属于该命名空间下 hyperkube：提供所有的 k8s 组件支持 etcd：提供数据库存储 pause：一个轻量级的基础设施容器，用于为每个 Pod 提前创建命名空间，其他什么也不做 PodPod 的创建流程 kubectl 命令发起一个创建 Pod 的请求去到 kube-apiserver kube-apiserver 完成基本的验证和授权操作，把 Pod 的相关信息写入 etcd kube-scheduler 定时请求 kube-apiserver，确定 Pod 要调度的位置 kube-apiserver 写 etcd kube-apiserver 将信息发给 kubelet 完成 Pod 的创建 kube-controller-manager 定时请求 kube-apiserver，看 Pod 是否挂掉 各个组件及其作用 名称 作用 etcd 记录所有节点和资源的状态 kube-apiserver 接收来自客户端和其他组件的请求，更新 etcd 中的数据 kube-scheduler 负责具体的资源调度工作 kube-controller-manager 提供控制器服务，监视集群的状态，一但不满足状态则采取操作，让状态恢复正常 kubelet 负责干活 kube-proxy 网络转发（默认轮询）","categories":[{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://linweiyuan.github.io/tags/Kubernetes/"},{"name":"Docker","slug":"Docker","permalink":"https://linweiyuan.github.io/tags/Docker/"}]},{"title":"某站程序和文件上传漏洞","slug":"某站程序和文件上传漏洞","date":"2020-01-25T06:44:43.000Z","updated":"2023-05-20T01:12:21.108Z","comments":true,"path":"2020/01/25/某站程序和文件上传漏洞.html","link":"","permalink":"https://linweiyuan.github.io/2020/01/25/%E6%9F%90%E7%AB%99%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.html","excerpt":"","text":"利用程序漏洞成功以 admin 身份登录后台, 数据泄露 任意文件类型上传, jspx 小 shell Windows 操作系统 数据库配置泄露","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://linweiyuan.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://linweiyuan.github.io/tags/Windows/"},{"name":"Vulnerability","slug":"Vulnerability","permalink":"https://linweiyuan.github.io/tags/Vulnerability/"},{"name":"JSPX","slug":"JSPX","permalink":"https://linweiyuan.github.io/tags/JSPX/"}]},{"title":"Anko放弃维护","slug":"Anko放弃维护","date":"2019-12-02T13:13:54.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2019/12/02/Anko放弃维护.html","link":"","permalink":"https://linweiyuan.github.io/2019/12/02/Anko%E6%94%BE%E5%BC%83%E7%BB%B4%E6%8A%A4.html","excerpt":"","text":"用Anko写过一个Android应用 -&gt; 怪物猎人金手指 for Android, 最喜欢的就是doAsync和uiThread, 今天升级下依赖, 发现提示Anko is deprecated, 并且给出了一个说明 -&gt; Discontinuing Anko 截止目前15.4k的Star, 这个项目确实很好, 真是令人惋惜 希望Ktor能持续发展","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://linweiyuan.github.io/tags/Kotlin/"},{"name":"Anko","slug":"Anko","permalink":"https://linweiyuan.github.io/tags/Anko/"}]},{"title":"某站XSS漏洞","slug":"某站XSS漏洞","date":"2019-11-11T07:28:35.000Z","updated":"2023-05-20T01:12:21.104Z","comments":true,"path":"2019/11/11/某站XSS漏洞.html","link":"","permalink":"https://linweiyuan.github.io/2019/11/11/%E6%9F%90%E7%AB%99XSS%E6%BC%8F%E6%B4%9E.html","excerpt":"","text":"插入任意 JS 脚本 JS 脚本加载","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://linweiyuan.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"https://linweiyuan.github.io/tags/Vulnerability/"},{"name":"XSS","slug":"XSS","permalink":"https://linweiyuan.github.io/tags/XSS/"},{"name":"JSPX","slug":"JSPX","permalink":"https://linweiyuan.github.io/tags/JSPX/"}]},{"title":"PyPI加速","slug":"PyPI加速","date":"2019-10-06T01:47:06.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/10/06/PyPI加速.html","link":"","permalink":"https://linweiyuan.github.io/2019/10/06/PyPI%E5%8A%A0%E9%80%9F.html","excerpt":"","text":"12[global]index-url = https://mirrors.tuna.tsinghua.edu.cn/pypi/simple","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://linweiyuan.github.io/tags/Python/"},{"name":"pip","slug":"pip","permalink":"https://linweiyuan.github.io/tags/pip/"}]},{"title":"Java单例设计模式","slug":"Java单例设计模式","date":"2019-09-24T02:21:34.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/09/24/Java单例设计模式.html","link":"","permalink":"https://linweiyuan.github.io/2019/09/24/Java%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html","excerpt":"","text":"Java 实现单例设计模式的部分例子，并不是全部 普通饿汉式何为饿汉，就是很饿了，要马上能吃到东西（实例先初始化好，要用时就直接拿来用） 123456789101112package singleton;public class Singleton &#123; private static final Singleton INSTANCE = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return INSTANCE; &#125;&#125; 这种方式就能实现单例了吗？测试下 1234public static void main(String[] args) &#123; System.out.println(Singleton.getInstance()); System.out.println(Singleton.getInstance());&#125; 输出相同的地址，确实能实现 12singleton.Singleton@6bf2d08esingleton.Singleton@6bf2d08e 从上面输出可以看到是实现了的，但是有潜在的问题 12345678910public static void main(String[] args) throws Exception &#123; System.out.println(Singleton.getInstance()); Constructor&lt;?&gt;[] declaredConstructors = Singleton.class.getDeclaredConstructors(); for (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123; declaredConstructor.setAccessible(true); Object obj = declaredConstructor.newInstance(); System.out.println(obj); &#125;&#125; 这样就会得到两个不同的对象 12singleton.Singleton@6bf2d08esingleton.Singleton@1b701da1 如何解决？ 要实现单例，核心有两点： 私有化构造方法，不能让别人 new 提供获取实例的方法 上面的代码就是把原来 private 的构造方法设为 public，然后 new 了下，那知道了这一点，就可以在构造方法那里对应地进行处理 我都饿汉了，实例早就有了，你还来 new，抛个异常给你 12345private Singleton() &#123; if (INSTANCE != null) &#123; throw new RuntimeException(&quot;!&quot;); &#125;&#125; 再来测试下 12singleton.Singleton@6bf2d08eException in thread &quot;main&quot; java.lang.reflect.InvocationTargetException 再已经有一个实例的情况下，再通过反射来 new，就会得到一个异常 但是，没有其他的问题了吗？再来测试下 12345678910public static void main(String[] args) throws Exception &#123; System.out.println(Singleton.getInstance()); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(Singleton.getInstance()); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); Object obj = ois.readObject(); System.out.println(obj);&#125; 涉及到了流的操作，单例类需要实现 Serializable 接口 结果如下 12singleton.Singleton@5eb5c224singleton.Singleton@5ae9a829 又得到了两个不同的实例 如何解决？ 123private Object readResolve() &#123; return INSTANCE;&#125; 再次查看输出结果 12singleton.Singleton@5eb5c224singleton.Singleton@5eb5c224 解决了，但是为什么 readResolve() 能解决序列化导致两个对象的问题，这个就要稍微看点 JDK 源码（JDK 1.8） 首先从测试代码的 readObject() 入手（删掉不重点关注或者说看不懂的代码，看源码真的要深入每一行吗？你要这么说，那最核心的都是 native 方法） 1Object obj = ois.readObject(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class: java.io.ObjectInputStreampublic final Object readObject() throws IOException, ClassNotFoundException &#123; return readObject(Object.class);&#125;private final Object readObject(Class&lt;?&gt; type) throws IOException, ClassNotFoundException&#123; ... Object obj = readObject0(type, false); return obj; ...&#125;private Object readObject0(Class&lt;?&gt; type, boolean unshared) throws IOException &#123; ... case TC_OBJECT: if (type == String.class) &#123; throw new ClassCastException(&quot;Cannot cast an object to java.lang.String&quot;); &#125; return checkResolve(readOrdinaryObject(unshared)); ...&#125;private Object readOrdinaryObject(boolean unshared) throws IOException&#123; if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; // 检查是否有 readResolve 方法 desc.hasReadResolveMethod()) &#123; // 如果有 readResolve 方法，则返回这个方法返回的对象 Object rep = desc.invokeReadResolve(obj); if (unshared &amp;&amp; rep.getClass().isArray()) &#123; rep = cloneArray(rep); &#125; if (rep != obj) &#123; // Filter the replacement object if (rep != null) &#123; if (rep.getClass().isArray()) &#123; filterCheck(rep.getClass(), Array.getLength(rep)); &#125; else &#123; filterCheck(rep.getClass(), -1); &#125; &#125; handles.setObject(passHandle, obj = rep); &#125; &#125; return obj;&#125; 123456789101112131415161718192021class: java.io.ObjectStreamClassboolean hasReadResolveMethod() &#123; requireInitialized(); return (readResolveMethod != null);&#125;private ObjectStreamClass(final Class&lt;?&gt; cl) &#123; ... if (serializable) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; readResolveMethod = getInheritableMethod( cl, &quot;readResolve&quot;, null, Object.class); return null; &#125; &#125;); &#125; ...&#125; 上面就是为什么 readResolve() 能防止反序列化出来不同的对象 但是这样，就能实现单例了吗？再来测试下别的 12345678public static void main(String[] args) throws Exception &#123; System.out.println(Singleton.getInstance()); Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); field.setAccessible(true); Unsafe unsafe = (Unsafe) field.get(null); System.out.println(unsafe.allocateInstance(Singleton.class));&#125; 12singleton.Singleton@2a139a55singleton.Singleton@6d06d69c 这样又能得到两个对象了，因为是比较底层的 Unsafe 类，所以预防不了 那么有没有其他方法，有，就是枚举饿汉 枚举类饿汉式123public enum Singleton1 &#123; INSTANCE;&#125; 测试反射破坏单例 12345678public static void main(String[] args) throws Exception &#123; System.out.println(Singleton.INSTANCE); Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor(); constructor.setAccessible(true); Object obj = constructor.newInstance(); System.out.println(obj);&#125; 得到了一个异常 java.lang.NoSuchMethodException，通过 javap 编译出来的 class 文件，可以看到类的结构 123456public final class singleton.Singleton extends java.lang.Enum&lt;singleton.Singleton&gt; &#123; public static final singleton.Singleton INSTANCE; public static singleton.Singleton[] values(); public static singleton.Singleton valueOf(java.lang.String); static &#123;&#125;;&#125; 里面确实没有无参构造方法，再看继承的 java.lang.Enum 类 123456789public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; ... protected Enum(String name, int ordinal) &#123; this.name = name; this.ordinal = ordinal; &#125; ...&#125; protected 能被继承，所以枚举类里是有带参的构造方法的，如果调用带参的构造方法，会发生什么 12345678public static void main(String[] args) throws Exception &#123; System.out.println(Singleton.INSTANCE); Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor(String.class, int.class); constructor.setAccessible(true); Object obj = constructor.newInstance(); System.out.println(obj);&#125; 12INSTANCEException in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects 可以调用，但是报错了，看回反射的源码，可以看到里面做了一个判断 123456789101112class: java.lang.reflect.Constructor@CallerSensitivepublic T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123; ... if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;); ...&#125; 所以枚举饿汉，是在 JDK 的层面进行了防反射 再试试反序列化 12345678910public static void main(String[] args) throws Exception &#123; System.out.println(Singleton.INSTANCE); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(Singleton.INSTANCE); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); Object obj = ois.readObject(); System.out.println(obj);&#125; 12INSTANCEINSTANCE 得到的是相同的对象，要了解原因，需要从序列化看起 1oos.writeObject(Singleton.INSTANCE); 123456789101112131415161718192021222324252627282930313233class: java.io.ObjectOutputStreampublic final void writeObject(Object obj) throws IOException &#123; ... try &#123; writeObject0(obj, false); &#125; catch (IOException ex) &#123; if (depth == 0) &#123; writeFatalException(ex); &#125; throw ex; &#125;&#125;private void writeObject0(Object obj, boolean unshared) throws IOException&#123; ... else if (obj instanceof Enum) &#123; writeEnum((Enum&lt;?&gt;) obj, desc, unshared); &#125; ...&#125;private void writeEnum(Enum&lt;?&gt; en, ObjectStreamClass desc, boolean unshared) throws IOException&#123; ... // 其实序列化就是存枚举类对象的 name writeString(en.name(), false);&#125; 再看反序列化，大部分代码和上面普通类的反序列化相同，这里重点列出不同的 12345678910111213141516171819202122232425262728293031323334class: java.io.ObjectInputStreamprivate Object readObject0(Class&lt;?&gt; type, boolean unshared) throws IOException &#123; ... case TC_ENUM: if (type == String.class) &#123; throw new ClassCastException(&quot;Cannot cast an enum to java.lang.String&quot;); &#125; return checkResolve(readEnum(unshared)); ...&#125;private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException &#123; ... Enum&lt;?&gt; result = null; ... // 核心是这行 Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name); result = en; ... return result;&#125;public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) &#123; // 直接根据 name 拿回枚举类实例，对应上面存的 name，拿到的就是同一个 T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException(&quot;Name is null&quot;); throw new IllegalArgumentException( &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name);&#125; 所以枚举饿汉也是在 JDK 的层面进行了防反序列化 那么 Unsafe 又怎么样 12345678public static void main(String[] args) throws Exception &#123; System.out.println(Singleton.INSTANCE); Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); field.setAccessible(true); Unsafe unsafe = (Unsafe) field.get(null); System.out.println(unsafe.allocateInstance(Singleton.class));&#125; 12INSTANCEnull 返回了一个 null，因为这个是 native 方法，具体实现的代码看不懂，这里只放出 Java 这边的代码 123456class: sun.misc.Unsafe/** Allocate an instance but do not run any constructor. Initializes the class if it has not yet been. */public native Object allocateInstance(Class&lt;?&gt; cls) throws InstantiationException; 所以也可以说，枚举饿汉也能防 Unsafe 普通懒汉式懒汉就是没有这么饿，但是很懒，因为懒，所以我不提前给你准备好东西，你催我的时候我再来准备，下面的代码都能实现单例，结果就不放了 12345678910public class Singleton &#123; private static Singleton INSTANCE = null; public static Singleton getInstance() &#123; if (INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; return INSTANCE; &#125;&#125; 这种方法有个问题，因为 INSTANCE 其实是一个共享变量，共享变量在多线程的环境下就会有资源竞争的问题，所以可能两个线程都会判断 INSTANCE 是 null，所以创建了两个对象 既然这样，那无脑 synchronized 就完了 12345678910public class Singleton &#123; private static Singleton INSTANCE = null; public synchronized static Singleton getInstance() &#123; if (INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; return INSTANCE; &#125;&#125; 可以是可以，但是锁的粒度太大了，并发量很大的情况下性能会有影响（大部分场景下这些都是空话套话），所以要将锁细化 123456789101112public class Singleton &#123; private static Singleton INSTANCE = null; public static Singleton getInstance() &#123; if (INSTANCE == null) &#123; synchronized (Singleton.class) &#123; INSTANCE = new Singleton(); &#125; &#125; return INSTANCE; &#125;&#125; 这样一来，只有 INSTANCE 是 null 的时候才会加锁，性能就会大大提升 但是也会有一个问题，理想情况下是请求一个接着一个来，第一个来了，null，初始化，后面的直接 return，但是在多线程环境下，也会存在两个线程都判断是 null，所以都进去了 if 代码块，虽然只有一个线程能进入 synchronized 代码块，但是一个线程 new 了，就释放锁了，第二个线程还是会 new，这样就会有两个实例 如何解决？在 synchronized 块里再判断一次 1234567891011121314public class Singleton &#123; private static Singleton INSTANCE = null; public static Singleton getInstance() &#123; if (INSTANCE == null) &#123; synchronized (Singleton.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 这样虽然有多个线程判断 INSTANCE 是 null，从而进入 if 代码块，但是只能有一个线程能进入 synchronized 块进行 new 对象，虽然 new 完了别的线程还能进入，但进入后再判断，就不会再 new 了 看似解决了，但是这种方式在 JVM 层面有一个问题 new 对象的时候一般会包括但不限于以下几个步骤： 分配内存空间 变量初始化 返回内存地址（赋值） 但是 JVM 会进行一些优化，江湖人称指令重排序，就是可能会先赋值了再初始化变量，这样以来在多线程的环境下就会得到一个未初始化的对象，那用起来会就有奇怪的问题，为了禁止这个负优化（单例场景下是负优化），需要用 volatile 关键字 volatile 通过增加内存屏障的方式，禁止指令重排序，除此之外，还可以手动增加内存屏障，通过 Unsafe 类的一些 fence 相关的方法（这个不常用，除非是很底层的代码），volatile 还保证可见性，详细的东西可能单独谈比较合适 其他注意的点和饿汉式相同 内部类懒汉式内部类是类加载的时候就初始化，类加载是线程安全的，其他注意的点也和上面的类似 123456789101112public class Singleton &#123; private Singleton() &#123; &#125; private static final class InstanceHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getInstance() &#123; return InstanceHolder.INSTANCE; &#125;&#125; 最后总结：大家都说用枚举类单例好","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"}]},{"title":"VirtualBox压缩虚拟硬盘","slug":"VirtualBox压缩虚拟硬盘","date":"2019-08-06T14:16:22.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/08/06/VirtualBox压缩虚拟硬盘.html","link":"","permalink":"https://linweiyuan.github.io/2019/08/06/VirtualBox%E5%8E%8B%E7%BC%A9%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98.html","excerpt":"","text":"Linux12sudo dd if=/dev/zero of=/empty bs=1Msudo rm -f /empty Windows下载 -&gt; Sysinternals Suite 1sdelete –z C: 关机执行 1vboxmanage modifyhd xxx.vdi --compact 提示 10%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://linweiyuan.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"VirtualBox","slug":"VirtualBox","permalink":"https://linweiyuan.github.io/tags/VirtualBox/"}]},{"title":"Android License","slug":"Android-License","date":"2019-07-26T14:39:22.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2019/07/26/Android-License.html","link":"","permalink":"https://linweiyuan.github.io/2019/07/26/Android-License.html","excerpt":"","text":"Android 开发中提示License for package xxx not accepted. 1yes | sdkmanager --licenses","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://linweiyuan.github.io/tags/Android/"}]},{"title":"减少MySQL内存占用","slug":"减少MySQL内存占用","date":"2019-07-21T10:07:49.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2019/07/21/减少MySQL内存占用.html","link":"","permalink":"https://linweiyuan.github.io/2019/07/21/%E5%87%8F%E5%B0%91MySQL%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8.html","excerpt":"","text":"MySQL 高版本默认开启performance_schema -&gt; Performance Schema Startup Configuration 用 Docker 启动一个 MySQL 容器, 开启的情况下启动完成占用内存接近 400M 关闭配置 12[mysqld]performance_schema=OFF 重启 MySQL 占用内存 100M 左右","categories":[{"name":"数据库","slug":"数据库","permalink":"https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://linweiyuan.github.io/tags/MySQL/"}]},{"title":"i3status显示网速","slug":"i3status显示网速","date":"2019-07-20T05:23:24.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/07/20/i3status显示网速.html","link":"","permalink":"https://linweiyuan.github.io/2019/07/20/i3status%E6%98%BE%E7%A4%BA%E7%BD%91%E9%80%9F.html","excerpt":"","text":"下载脚本 -&gt; net-speed.sh, 修改bar执行程序路径指向脚本 123bar &#123; status_command exec net-speed.sh&#125; 修改成好看的格式 1echo &quot;$&#123;rate&#125;| $&#123;line&#125;&quot; || exit 1 重新加载 i3 配置文件","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"},{"name":"i3","slug":"i3","permalink":"https://linweiyuan.github.io/tags/i3/"},{"name":"i3status","slug":"i3status","permalink":"https://linweiyuan.github.io/tags/i3status/"}]},{"title":"Linux和Windows共享硬盘挂载问题解决方案","slug":"Linux和Windows共享硬盘挂载问题解决方案","date":"2019-07-02T12:25:01.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/07/02/Linux和Windows共享硬盘挂载问题解决方案.html","link":"","permalink":"https://linweiyuan.github.io/2019/07/02/Linux%E5%92%8CWindows%E5%85%B1%E4%BA%AB%E7%A1%AC%E7%9B%98%E6%8C%82%E8%BD%BD%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html","excerpt":"","text":"双系统 Linux + Windows 10, Windows 下有 NTFS 格式 1T 硬盘(比如 D 盘), Linux 下按需挂载时出现问题 1sudo mount /dev/sdb1 Temp 报错 12345The disk contains an unclean file system (0, 0).Metadata kept in Windows cache, refused to mount.Falling back to read-only mount because the NTFS partition is in anunsafe state. Please resume and shutdown Windows fully (no hibernationor fast restarting.) 利用ntfsfix命令解决 1sudo ntfsfix /dev/sdb1 修复脏数据 1234567891011121314Mounting volume... The disk contains an unclean file system (0, 0).Metadata kept in Windows cache, refused to mount.FAILEDAttempting to correct errors...Processing $MFT and $MFTMirr...Reading $MFT... OKReading $MFTMirr... OKComparing $MFTMirr to $MFT... OKProcessing of $MFT and $MFTMirr completed successfully.Setting required flags on partition... OKGoing to empty the journal ($LogFile)... OKChecking the alternate boot sector... OKNTFS volume version is 3.1.NTFS partition /dev/sdb1 was processed successfully. 以读写方式重新加载 1sudo mount -o rw /dev/sdb1","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"},{"name":"NTFS","slug":"NTFS","permalink":"https://linweiyuan.github.io/tags/NTFS/"},{"name":"Windows","slug":"Windows","permalink":"https://linweiyuan.github.io/tags/Windows/"}]},{"title":"某站越权漏洞","slug":"某站越权漏洞","date":"2019-06-07T06:34:55.000Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"2019/06/07/某站越权漏洞.html","link":"","permalink":"https://linweiyuan.github.io/2019/06/07/%E6%9F%90%E7%AB%99%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E.html","excerpt":"","text":"普通用户登录 利用普通用户身份重置 admin 密码 admin 登录 数据泄露","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://linweiyuan.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"https://linweiyuan.github.io/tags/Vulnerability/"},{"name":"Unauthorized","slug":"Unauthorized","permalink":"https://linweiyuan.github.io/tags/Unauthorized/"}]},{"title":"Javassist动态增强类","slug":"Javassist动态增强类","date":"2019-06-05T16:07:35.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/06/05/Javassist动态增强类.html","link":"","permalink":"https://linweiyuan.github.io/2019/06/05/Javassist%E5%8A%A8%E6%80%81%E5%A2%9E%E5%BC%BA%E7%B1%BB.html","excerpt":"","text":"User类，只有一个字段username，在不继承或者其他方式前提下利用Javassist实现类增强 可以看到.class文件已被修改 重新加载字节码后发现password设为private没输出，username值被修改，flag设为public被输出，getter也被输出","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"Java","slug":"程序设计/Java","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"Javassist","slug":"Javassist","permalink":"https://linweiyuan.github.io/tags/Javassist/"},{"name":"Reflection","slug":"Reflection","permalink":"https://linweiyuan.github.io/tags/Reflection/"}]},{"title":"Maven上传Nexus私服带源码","slug":"Maven上传Nexus私服带源码","date":"2019-06-03T08:26:59.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/06/03/Maven上传Nexus私服带源码.html","link":"","permalink":"https://linweiyuan.github.io/2019/06/03/Maven%E4%B8%8A%E4%BC%A0Nexus%E7%A7%81%E6%9C%8D%E5%B8%A6%E6%BA%90%E7%A0%81.html","excerpt":"","text":"加maven-source-plugin插件 123456789101112131415&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;attach&gt;true&lt;/attach&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; settings.xml配置验证信息 123456789&lt;settings&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;id&lt;/id&gt; &lt;username&gt;username&lt;/username&gt; &lt;password&gt;password&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt;&lt;/settings&gt; pom.xml中的id要和settings.xml中的一致 123456&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;id&lt;/id&gt; &lt;url&gt;url&lt;/url&gt; &lt;/repository&gt;&lt;/distributionManagement&gt;","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://linweiyuan.github.io/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://linweiyuan.github.io/tags/Maven/"},{"name":"Nexus","slug":"Nexus","permalink":"https://linweiyuan.github.io/tags/Nexus/"}]},{"title":"Java定时器","slug":"Java定时器","date":"2019-05-21T18:20:09.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/05/21/Java定时器.html","link":"","permalink":"https://linweiyuan.github.io/2019/05/21/Java%E5%AE%9A%E6%97%B6%E5%99%A8.html","excerpt":"","text":"简单起见用Kotlin写 scheduleAtFixedRate12345678910val timerTaskPool = Executors.newScheduledThreadPool(2)timerTaskPool.scheduleAtFixedRate( object : TimerTask() &#123; override fun run() &#123; println(Date()) Thread.sleep(2000) &#125; &#125;, 0, 3, TimeUnit.SECONDS) 运行结果 123Wed May 22 02:24:52 CST 2019Wed May 22 02:24:55 CST 2019Wed May 22 02:24:58 CST 2019 也就是不顾前面的任务有没执行完, 延迟指定时间就再次执行任务 scheduleWithFixedDelay12345678910val timerTaskPool = Executors.newScheduledThreadPool(2)timerTaskPool.scheduleWithFixedDelay( object : TimerTask() &#123; override fun run() &#123; println(Date()) Thread.sleep(2000) &#125; &#125;, 0, 3, TimeUnit.SECONDS) 运行结果 123Wed May 22 02:26:04 CST 2019Wed May 22 02:26:09 CST 2019Wed May 22 02:26:14 CST 2019 延迟 3 秒, 睡了 2 秒, 间隔 5 秒 定时任务尽量用 Pool, 因为 Timer 在分布式系统上可能存在时间不一致或者无法捕获异常的问题","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://linweiyuan.github.io/tags/Kotlin/"},{"name":"ThreadPool","slug":"ThreadPool","permalink":"https://linweiyuan.github.io/tags/ThreadPool/"}]},{"title":"Flask Dockerfile模板","slug":"Flask-Dockerfile模板","date":"2019-05-20T12:20:48.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2019/05/20/Flask-Dockerfile模板.html","link":"","permalink":"https://linweiyuan.github.io/2019/05/20/Flask-Dockerfile%E6%A8%A1%E6%9D%BF.html","excerpt":"","text":"python:alpine基于 Python3, 依赖下载过程中需要 build, 安装python3-dev,build-base,gcc, build 完后删掉, 镜像可减少几百 M 123456789101112131415161718FROM python:alpineLABEL maintainer=&quot;linweiyuan &lt;root@linweiyuan.com&gt;&quot;ENV FOLDER 项目名字COPY . $&#123;FOLDER&#125;WORKDIR $&#123;FOLDER&#125;RUN sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#x27; /etc/apk/repositories \\ &amp;&amp; apk add --no-cache python3-dev build-base gcc \\ &amp;&amp; pip install --no-cache-dir -r requirements.txt \\ &amp;&amp; apk del python3-dev build-base gccEXPOSE 5000CMD [&quot;flask&quot;,&quot;run&quot;,&quot;--host=0.0.0.0&quot;]","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://linweiyuan.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://linweiyuan.github.io/tags/Flask/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"https://linweiyuan.github.io/tags/Dockerfile/"}]},{"title":"Go日期格式化","slug":"Go日期格式化","date":"2019-05-19T16:24:52.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2019/05/19/Go日期格式化.html","link":"","permalink":"https://linweiyuan.github.io/2019/05/19/Go%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96.html","excerpt":"","text":"文档 -&gt; time - The Go Programming Language 1time.Now().Format(&quot;2006-01-02 15:04:05&quot;) 真是一股清流","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://linweiyuan.github.io/tags/Go/"}]},{"title":"Go交叉编译","slug":"Go交叉编译","date":"2019-05-19T15:33:25.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2019/05/19/Go交叉编译.html","link":"","permalink":"https://linweiyuan.github.io/2019/05/19/Go%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91.html","excerpt":"","text":"Linux1CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go Windows1CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go macOS1CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go 其他选项 $GOOS $GOARCH android arm darwin 386 darwin amd64 darwin arm darwin arm64 dragonfly amd64 freebsd 386 freebsd amd64 freebsd arm linux 386 linux amd64 linux arm linux arm64 linux ppc64 linux ppc64le linux mips linux mipsle linux mips64 linux mips64le linux s390x netbsd 386 netbsd amd64 netbsd arm openbsd 386 openbsd amd64 openbsd arm plan9 386 plan9 amd64 solaris amd64 windows 386 windows amd64","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://linweiyuan.github.io/tags/Go/"}]},{"title":"pem to key","slug":"pem-to-key","date":"2019-05-12T06:39:55.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2019/05/12/pem-to-key.html","link":"","permalink":"https://linweiyuan.github.io/2019/05/12/pem-to-key.html","excerpt":"","text":"12openssl x509 -in fullchain1.pem -out server.crtopenssl rsa -in privkey1.pem -out server.key","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://linweiyuan.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"openssl","slug":"openssl","permalink":"https://linweiyuan.github.io/tags/openssl/"}]},{"title":"Linux维护","slug":"Linux维护","date":"2019-05-06T20:59:11.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/05/06/Linux维护.html","link":"","permalink":"https://linweiyuan.github.io/2019/05/06/Linux%E7%BB%B4%E6%8A%A4.html","excerpt":"","text":"启动 1single init=/bin/bash 改密码提示Authentication Token Manipulation Error 1mount -rw -o remount /","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"}]},{"title":"删除Docker无用镜像","slug":"删除Docker无用镜像","date":"2019-05-05T04:39:04.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2019/05/05/删除Docker无用镜像.html","link":"","permalink":"https://linweiyuan.github.io/2019/05/05/%E5%88%A0%E9%99%A4Docker%E6%97%A0%E7%94%A8%E9%95%9C%E5%83%8F.html","excerpt":"","text":"一键删除 build 过程中产生的&lt;none&gt;镜像 1docker images -a | grep none | awk &#x27;&#123;print $3&#125;&#x27; | xargs docker rmi 或者 1docker rmi $(docker images -a | grep none | awk &#x27;&#123;print $3&#125;&#x27;)","categories":[{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linweiyuan.github.io/tags/Docker/"}]},{"title":"Nginx配置SSE","slug":"Nginx配置SSE","date":"2019-04-26T02:37:42.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/04/26/Nginx配置SSE.html","link":"","permalink":"https://linweiyuan.github.io/2019/04/26/Nginx%E9%85%8D%E7%BD%AESSE.html","excerpt":"","text":"加个配置 1proxy_buffering off; 经测试, X-Accel-Buffering: no不好使 与 WebSocket 比较的话, SSE 只能服务器推, WS 全双工, 不过 SSE 更轻量","categories":[{"name":"服务器","slug":"服务器","permalink":"https://linweiyuan.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://linweiyuan.github.io/tags/Nginx/"},{"name":"Server Send Event","slug":"Server-Send-Event","permalink":"https://linweiyuan.github.io/tags/Server-Send-Event/"}]},{"title":"Docker搭建私有仓库","slug":"Docker搭建私有仓库","date":"2019-04-25T13:28:57.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2019/04/25/Docker搭建私有仓库.html","link":"","permalink":"https://linweiyuan.github.io/2019/04/25/Docker%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html","excerpt":"","text":"起个容器 1234567891011registry: container_name: registry image: registry volumes: - ./registry:/var/lib/registry/docker/registry/v2 - ./registry/auth:/auth environment: - REGISTRY_AUTH=htpasswd - REGISTRY_AUTH_HTPASSWD_REALM=Auth - REGISTRY_AUTH_HTPASSWD_PATH=/auth restart: unless-stopped Auth 1htpasswd -Bb -c auth（文件名） 用户名 密码","categories":[{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linweiyuan.github.io/tags/Docker/"},{"name":"Registry","slug":"Registry","permalink":"https://linweiyuan.github.io/tags/Registry/"}]},{"title":"Nginx文件浏览","slug":"Nginx文件浏览","date":"2019-04-20T18:23:01.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/04/20/Nginx文件浏览.html","link":"","permalink":"https://linweiyuan.github.io/2019/04/20/Nginx%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88.html","excerpt":"","text":"123autoindex on;autoindex_exact_size off;autoindex_localtime on; autoindex_exact_size -&gt; on显示字节, off显示人看的 autoindex_localtime -&gt; on显示服务器时间, off则 GMT 中文乱码加charset utf-8;","categories":[{"name":"服务器","slug":"服务器","permalink":"https://linweiyuan.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://linweiyuan.github.io/tags/Nginx/"}]},{"title":"Nginx的Basic认证","slug":"Nginx的Basic认证","date":"2019-04-20T12:48:21.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/04/20/Nginx的Basic认证.html","link":"","permalink":"https://linweiyuan.github.io/2019/04/20/Nginx%E7%9A%84Basic%E8%AE%A4%E8%AF%81.html","excerpt":"","text":"参考 -&gt; Restricting Access with HTTP Basic Authentication 敏感服务不想对外暴露, 简单加个Basic Authentication AUR 是个好东西, htpasswd也有了, apache-tools还可以利用 ab 进行压力测试 1234567891011121314➜ ~ proxychains yaourt htpasswd[proxychains] config file found: /etc/proxychains.conf[proxychains] preloading /usr/lib/libproxychains4.so1 archlinuxcn/apache-tools 2.4.25-1 [installed] Useful Apache tools - htdigest, htpasswd, ab, htdbm2 aur/apache-tools 2.4.39-1 [installed: 2.4.25-1] (115) (1.01) Useful Apache tools - htdigest, htpasswd, ab, htdbm3 aur/python-htpasswd-git .r31.ef677a5-1 (0) (0.00) Python Library for working with htpasswd user (only basic authorization) and group files4 aur/python2-htpasswd-git .r31.ef677a5-1 (5) (0.05) Python 2 Library for working with htpasswd user (only basic authorization) and group files==&gt; Enter n° of packages to be installed (e.g., 1 2 3 or 1-3)==&gt; ---------------------------------------------------------==&gt; 生成密码 1htpasswd -c 文件名 用户名 挂载进 nginx 容器, 在需要的位置配置 12auth_basic &quot;Auth&quot;;auth_basic_user_file `认证文件路径`; 注意文件权限问题 curl 测试一下是否生效 123456789101112131415&lt; HTTP/1.1 401 Unauthorized&lt; Server: nginx/1.15.12&lt; Date: Sat, 20 Apr 2019 12:53:31 GMT&lt; Content-Type: text/html&lt; Content-Length: 180&lt; Connection: keep-alive&lt; WWW-Authenticate: Basic realm=&quot;Auth&quot;&lt;&lt;html&gt;&lt;head&gt;&lt;title&gt;401 Authorization Required&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;401 Authorization Required&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx/1.15.12&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 正常使用","categories":[{"name":"服务器","slug":"服务器","permalink":"https://linweiyuan.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://linweiyuan.github.io/tags/Nginx/"}]},{"title":"Nginx反向代理WebSocket","slug":"Nginx反向代理WebSocket","date":"2019-04-20T11:13:41.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/04/20/Nginx反向代理WebSocket.html","link":"","permalink":"https://linweiyuan.github.io/2019/04/20/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86WebSocket.html","excerpt":"","text":"123456location /ws &#123; proxy_pass http://?; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;;&#125; 实测一个自己的 WS 服务只需proxy_set_header Upgrade $http_upgrade;就足够","categories":[{"name":"服务器","slug":"服务器","permalink":"https://linweiyuan.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://linweiyuan.github.io/tags/Nginx/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://linweiyuan.github.io/tags/WebSocket/"}]},{"title":"Maven代理设置","slug":"Maven代理设置","date":"2019-03-29T15:48:25.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/03/29/Maven代理设置.html","link":"","permalink":"https://linweiyuan.github.io/2019/03/29/Maven%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE.html","excerpt":"","text":"参考 -&gt; Configuring a proxy 编辑~/.m2/settings.xml文件 1234567891011&lt;settings&gt; &lt;proxies&gt; &lt;proxy&gt; &lt;id&gt;proxy&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;https&lt;/protocol&gt; &lt;host&gt;127.0.0.1&lt;/host&gt; &lt;port&gt;8118&lt;/port&gt; &lt;/proxy&gt; &lt;/proxies&gt;&lt;/settings&gt;","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://linweiyuan.github.io/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://linweiyuan.github.io/tags/Maven/"},{"name":"Privoxy","slug":"Privoxy","permalink":"https://linweiyuan.github.io/tags/Privoxy/"}]},{"title":"某站用户弱口令","slug":"某站用户弱口令","date":"2019-03-18T07:18:17.000Z","updated":"2023-05-20T01:12:21.108Z","comments":true,"path":"2019/03/18/某站用户弱口令.html","link":"","permalink":"https://linweiyuan.github.io/2019/03/18/%E6%9F%90%E7%AB%99%E7%94%A8%E6%88%B7%E5%BC%B1%E5%8F%A3%E4%BB%A4.html","excerpt":"","text":"借书历史记录 个人信息","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://linweiyuan.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"https://linweiyuan.github.io/tags/Vulnerability/"},{"name":"ASPX","slug":"ASPX","permalink":"https://linweiyuan.github.io/tags/ASPX/"}]},{"title":"创建运行AVD命令","slug":"创建运行AVD命令","date":"2019-03-17T14:24:06.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2019/03/17/创建运行AVD命令.html","link":"","permalink":"https://linweiyuan.github.io/2019/03/17/%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8CAVD%E5%91%BD%E4%BB%A4.html","excerpt":"","text":"创建 1avdmanager create avd -n &quot;9.0&quot; -k &quot;system-images;android-28;default;x86_64&quot; 运行 1emulator -noaudio -avd 9.0 -noaudio防系统破音","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://linweiyuan.github.io/tags/Android/"},{"name":"AVD","slug":"AVD","permalink":"https://linweiyuan.github.io/tags/AVD/"}]},{"title":"FFmpeg下载M3U8","slug":"FFmpeg下载M3U8","date":"2019-03-11T18:46:10.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2019/03/11/FFmpeg下载M3U8.html","link":"","permalink":"https://linweiyuan.github.io/2019/03/11/FFmpeg%E4%B8%8B%E8%BD%BDM3U8.html","excerpt":"","text":"1ffmpeg -i url 文件名","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://linweiyuan.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://linweiyuan.github.io/tags/FFmpeg/"}]},{"title":"VirtualBox设置分辨率","slug":"VirtualBox设置分辨率","date":"2019-03-06T17:10:01.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/03/06/VirtualBox设置分辨率.html","link":"","permalink":"https://linweiyuan.github.io/2019/03/06/VirtualBox%E8%AE%BE%E7%BD%AE%E5%88%86%E8%BE%A8%E7%8E%87.html","excerpt":"","text":"1VBoxManage setextradata &quot;虚拟机名字&quot; VBoxInternal2/EfiGraphicsResolution 1920x1080","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://linweiyuan.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"VirtualBox","slug":"VirtualBox","permalink":"https://linweiyuan.github.io/tags/VirtualBox/"}]},{"title":"Linux生成强密码","slug":"Linux生成强密码","date":"2019-03-06T17:07:32.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/03/06/Linux生成强密码.html","link":"","permalink":"https://linweiyuan.github.io/2019/03/06/Linux%E7%94%9F%E6%88%90%E5%BC%BA%E5%AF%86%E7%A0%81.html","excerpt":"","text":"1openssl rand -base64 32 | head -c 32; echo","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"}]},{"title":"油管视频下载配置","slug":"油管视频下载配置","date":"2019-03-06T16:58:44.000Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"2019/03/06/油管视频下载配置.html","link":"","permalink":"https://linweiyuan.github.io/2019/03/06/%E6%B2%B9%E7%AE%A1%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E9%85%8D%E7%BD%AE.html","excerpt":"","text":"代理下载并设置文件名, 新建或编辑~/.config/youtube-dl/config 12--proxy socks5://127.0.0.1:1080-o %(title)s.%(ext)s","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://linweiyuan.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"},{"name":"youtube-dl","slug":"youtube-dl","permalink":"https://linweiyuan.github.io/tags/youtube-dl/"}]},{"title":"直接操作Nextcloud文件","slug":"直接操作Nextcloud文件","date":"2019-02-12T10:03:19.000Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"2019/02/12/直接操作Nextcloud文件.html","link":"","permalink":"https://linweiyuan.github.io/2019/02/12/%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9CNextcloud%E6%96%87%E4%BB%B6.html","excerpt":"","text":"直接在服务器上面操作文件, 省去了上传操作, 大文件尤其高效 Nextcloud 提供了工具, 将操作同步到数据库中, 注意指定执行用户, 否则会有权限问题 12docker exec -it -u www-data nextcloud ./occ files:cleanupdocker exec -it -u www-data nextcloud ./occ files:scan --all 刷新网页, 即可看到同步效果","categories":[{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linweiyuan.github.io/tags/Docker/"},{"name":"Nextcloud","slug":"Nextcloud","permalink":"https://linweiyuan.github.io/tags/Nextcloud/"}]},{"title":"某站任意文件上传拿root权限","slug":"某站任意文件上传拿root权限","date":"2019-02-05T05:50:07.000Z","updated":"2023-05-20T01:12:21.104Z","comments":true,"path":"2019/02/05/某站任意文件上传拿root权限.html","link":"","permalink":"https://linweiyuan.github.io/2019/02/05/%E6%9F%90%E7%AB%99%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%8B%BFroot%E6%9D%83%E9%99%90.html","excerpt":"","text":"某站一处图片上传未限制文件类型, 上传小 shell 发现用户是 root, 密码未知 直接上传 ssh 公钥 登录成功","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://linweiyuan.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"https://linweiyuan.github.io/tags/Vulnerability/"},{"name":"JSP","slug":"JSP","permalink":"https://linweiyuan.github.io/tags/JSP/"}]},{"title":"CoreOS初始化脚本","slug":"CoreOS初始化脚本","date":"2019-01-30T06:18:05.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2019/01/30/CoreOS初始化脚本.html","link":"","permalink":"https://linweiyuan.github.io/2019/01/30/CoreOS%E5%88%9D%E5%A7%8B%E5%8C%96%E8%84%9A%E6%9C%AC.html","excerpt":"","text":"1234567891011121314151617181920&#123; &quot;ignition&quot;: &#123; &quot;config&quot;: &#123;&#125;, &quot;timeouts&quot;: &#123;&#125;, &quot;version&quot;: &quot;2.1.0&quot; &#125;, &quot;networkd&quot;: &#123;&#125;, &quot;passwd&quot;: &#123; &quot;users&quot;: [ &#123; &quot;name&quot;: &quot;core&quot;, &quot;sshAuthorizedKeys&quot;: [ &quot;ssh-rsa xxx&quot; ] &#125; ] &#125;, &quot;storage&quot;: &#123;&#125;, &quot;systemd&quot;: &#123;&#125;&#125;","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"CoreOS","slug":"CoreOS","permalink":"https://linweiyuan.github.io/tags/CoreOS/"}]},{"title":"cURL快速连接Tencent-GuestWifi","slug":"cURL快速连接Tencent-GuestWifi","date":"2019-01-16T07:01:09.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2019/01/16/cURL快速连接Tencent-GuestWifi.html","link":"","permalink":"https://linweiyuan.github.io/2019/01/16/cURL%E5%BF%AB%E9%80%9F%E8%BF%9E%E6%8E%A5Tencent-GuestWifi.html","excerpt":"","text":"1curl &quot;http://10.33.172.65:8000/login&quot; -d &quot;username=Tencent-GuestWifi&amp;password=$1&quot; 使用 1./wifi.sh 验证码","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://linweiyuan.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"},{"name":"cURL","slug":"cURL","permalink":"https://linweiyuan.github.io/tags/cURL/"}]},{"title":"VirtualBox默认Headless启动","slug":"VirtualBox默认Headless启动","date":"2018-12-29T03:17:37.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/12/29/VirtualBox默认Headless启动.html","link":"","permalink":"https://linweiyuan.github.io/2018/12/29/VirtualBox%E9%BB%98%E8%AE%A4Headless%E5%90%AF%E5%8A%A8.html","excerpt":"","text":"VBox 在 i3 下打开会缩成一个小框, 特别安装了增强工具后, 根本无法正常使用 曲线救国方案 把自动拉伸去掉, 分辨率变成 800x600 把 VBox 改成 Headless 启动隐藏掉 i3 小框, 参考 -&gt; Ticket #13308 1VBoxManage modifyvm &quot;虚拟机名字&quot; --defaultfrontend headless 打开 Remote Display, VBox 菜单上的, 如果 3389 端口映射还需要登录和额外配置不推荐 rdesktop 直连, 找过其他 GUI, 发现不太好使 1alias rdp=&quot;nohup rdesktop-vrdp 127.0.0.1 &amp;&quot; 把 rdesktop 绑定快捷键, 我选的是Alt+Q 1bindsym Mod1+q [class=&quot;rdesktop&quot;] scratchpad show 暂时解决问题","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://linweiyuan.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"},{"name":"i3","slug":"i3","permalink":"https://linweiyuan.github.io/tags/i3/"},{"name":"VirtualBox","slug":"VirtualBox","permalink":"https://linweiyuan.github.io/tags/VirtualBox/"}]},{"title":"Wget下载Google Drive文件","slug":"Wget下载Google-Drive文件","date":"2018-12-27T10:29:15.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/12/27/Wget下载Google-Drive文件.html","link":"","permalink":"https://linweiyuan.github.io/2018/12/27/Wget%E4%B8%8B%E8%BD%BDGoogle-Drive%E6%96%87%E4%BB%B6.html","excerpt":"","text":"1wget --no-check-certificate -r &#x27;https://docs.google.com/uc?export=download&amp;id=文件ID&#x27; -O 文件名 其中文件 ID 可以在 Share 里获取, 注意-r参数","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://linweiyuan.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"},{"name":"Wget","slug":"Wget","permalink":"https://linweiyuan.github.io/tags/Wget/"},{"name":"Google Drive","slug":"Google-Drive","permalink":"https://linweiyuan.github.io/tags/Google-Drive/"}]},{"title":"Arch Linux下IDEA失去焦点","slug":"Arch-Linux下IDEA失去焦点","date":"2018-12-19T11:00:59.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/12/19/Arch-Linux下IDEA失去焦点.html","link":"","permalink":"https://linweiyuan.github.io/2018/12/19/Arch-Linux%E4%B8%8BIDEA%E5%A4%B1%E5%8E%BB%E7%84%A6%E7%82%B9.html","excerpt":"","text":"环境Arch Linux (4.19.9-arch1-1-ARCH) KDE + Plasma IDEA 2018.3.2 描述窗口切换后, 经常切换不回来, 任务栏虽然有焦点, 但是窗口无法显示, 要点其他窗口后再点回 IDEA 才能切换回来, 非常不便 解决方案参考 -&gt; IntelliJ stealing focus, 修改 Help -&gt; Edit Custom Properties 1suppress.focus.stealing=false 重启 IDEA 后, 一切正常","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"},{"name":"IDEA","slug":"IDEA","permalink":"https://linweiyuan.github.io/tags/IDEA/"}]},{"title":"解决ZuulFilter乱码","slug":"解决ZuulFilter乱码","date":"2018-12-16T18:03:38.000Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"2018/12/16/解决ZuulFilter乱码.html","link":"","permalink":"https://linweiyuan.github.io/2018/12/16/%E8%A7%A3%E5%86%B3ZuulFilter%E4%B9%B1%E7%A0%81.html","excerpt":"","text":"设置响应头 1234val context = RequestContext.getCurrentContext()context.setSendZuulResponse(false)context.addZuulResponseHeader(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;)context.responseBody = JSON.toJSONString(response)","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://linweiyuan.github.io/tags/Spring-Cloud/"},{"name":"Zuul","slug":"Zuul","permalink":"https://linweiyuan.github.io/tags/Zuul/"}]},{"title":"Spring Boot jar瘦身方案","slug":"Spring-Boot-jar瘦身方案","date":"2018-12-14T10:16:01.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/12/14/Spring-Boot-jar瘦身方案.html","link":"","permalink":"https://linweiyuan.github.io/2018/12/14/Spring-Boot-jar%E7%98%A6%E8%BA%AB%E6%96%B9%E6%A1%88.html","excerpt":"","text":"Spring Boot 固然好用, 十八般武艺集于一身, 但是带来的后果是 jar 包太大, 普通加个 web 模块写个 HelloWorldController 打包出来都要 30+M, 如果要修改一行代码或配置都要重新上传。国外 VPS 还好, 带宽弥补了小延迟的不足, 国内小水管简直不能忍, 当然 CI&#x2F;CD 就另当别论 在使用 Spring Cloud 过程中, 把项目分成了几个微服务, 加了几个 Spring Cloud 组件和项目公用模块后, 打包出来的 jar 有 200+M, 这不利于快速迭代。好在 Maven 和 Gradle 都提供了一些方法 Maven 篇虽然可以通过mvn dependency:copy-dependencies把依赖拷出来, 但是如果项目中有相互依赖, 会报错, 所以还是手动把 jar 包分解 Spring Boot 打包出来的 jar 包结构是 123- BOOT-INF - classes - lib 把 lib 拷到某个位置, 其他微服务 jar 处理方式一样, jar 包提示重复就跳过 分解完后修改parent的pom.xml 1234567891011121314151617&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;includes&gt; &lt;include&gt; &lt;groupId&gt;qw&lt;/groupId&gt; &lt;artifactId&gt;er&lt;/artifactId&gt; &lt;/include&gt; &lt;/includes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; groupId和artifactId构造一个不存在的, 然后再打包, 此时打出来的 jar 包结构是 12- BOOT-INF - classes 这里注意 layout 要改成 ZIP, jar 包配置为Main-Class: org.springframework.boot.loader.PropertiesLauncher 如果不改, 配置为Main-Class: org.springframework.boot.loader.JarLauncher, 会无法启动 Gradle 篇 （基于 Kotlin DSL, 非 Groovy）12345678tasks &#123; withType&lt;BootJar&gt; &#123; manifest &#123; attributes(&quot;Main-Class&quot; to &quot;org.springframework.boot.loader.PropertiesLauncher&quot;) &#125; exclude(&quot;**/*.jar&quot;) &#125;&#125; 查看一下大小, 只有 100+K, 未分解之前是 200+M, 此时基本可以实现秒传 最后修改 jar 包启动方式 1java -jar -Dloader.path=jar包分解出来的路径 jar包 或者直接写进配置文件loader.properties（yml 文件不行）再打包, 就不需要额外再指定环境变量 1loader.path=jar包分解出来的路径 此时 jar 可以正常启动提供服务 如果是容器部署, 只需挂载 lib 进去即可","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://linweiyuan.github.io/tags/Spring-Cloud/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://linweiyuan.github.io/tags/Spring-Boot/"}]},{"title":"控制Docker容器启动顺序","slug":"控制Docker容器启动顺序","date":"2018-12-12T08:07:48.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2018/12/12/控制Docker容器启动顺序.html","link":"","permalink":"https://linweiyuan.github.io/2018/12/12/%E6%8E%A7%E5%88%B6Docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F.html","excerpt":"","text":"有些场景需要控制 Docker 容器的启动顺序, 比如一个后端服务要依赖 MySQL、Redis、RabbitMQ 等, 又或者 Eureka Client 一定要在 Eureka Server 启动后才能连接、从 Config Server 获取配置等 Docker 提供了 depends_on 等东西, 顾名思义就是处理依赖关系的, 但其实并不是 比如有 A、B, B depends_on A, 容器启动时, Docker 会确保先启动 A 再启动 B, 但是可能 B 启动完了 A 还在启动, 它并不能保证 A 启动完了 B 才启动, 详情 -&gt; Control startup order in Compose Docker 推荐了几个非官方工具, 都试过后, 发现只有dockerize能用 wait-for-it.sh这玩意不兼容 alpine, 直接报错 wait-for这玩意说是兼容了 alpine, 但是使用过程中全部请求都超时无法进行下一步, 不知道是不是打开方式不对 dockerize只需要加入到容器中运行即可, 不想手动加的可以自己 build 一个镜像出来 首先给dockerize加执行权限, 然后编写 Dockerfile 123FROM openjdk:8-jre-alpineADD dockerize /dockerize build 完之后替换原来镜像, 改写执行命令, 比如 Zuul 依赖 Eureka Server 123zuul: image: 你刚build的镜像 command: ./dockerize -wait tcp://eureka-server:8761 -- java -jar -Xms64m -Xmx64m /zuul.jar docker-compose 启动后, 会出现类似信息 12345zuul | 2018/12/12 08:04:37 Waiting for: tcp://eureka-server:8761...zuul_1 | 2018/12/12 08:04:42 Problem with dial: dial tcp 172.17.0.1:8761: connect: connection refused. Sleeping 1s...zuul_1 | 2018/12/12 08:27:10 Connected to tcp://eureka-server:8761 等 Eureka Server 启动完, Zuul 才启动","categories":[{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linweiyuan.github.io/tags/Docker/"},{"name":"Docker Compose","slug":"Docker-Compose","permalink":"https://linweiyuan.github.io/tags/Docker-Compose/"}]},{"title":"RabbitMQ in Docker内存设置","slug":"RabbitMQ-in-Docker内存设置","date":"2018-12-11T14:41:28.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/12/11/RabbitMQ-in-Docker内存设置.html","link":"","permalink":"https://linweiyuan.github.io/2018/12/11/RabbitMQ-in-Docker%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE.html","excerpt":"","text":"123rabbitmq: environment: - RABBITMQ_VM_MEMORY_HIGH_WATERMARK=96M","categories":[{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linweiyuan.github.io/tags/Docker/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://linweiyuan.github.io/tags/RabbitMQ/"}]},{"title":"Docker容器dpkg报错","slug":"Docker容器dpkg报错","date":"2018-12-10T13:39:25.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/12/10/Docker容器dpkg报错.html","link":"","permalink":"https://linweiyuan.github.io/2018/12/10/Docker%E5%AE%B9%E5%99%A8dpkg%E6%8A%A5%E9%94%99.html","excerpt":"","text":"在 Arch Linux 的 Kernel 滚到 4.19 后, 容器内执行 Debian 系的 dpkg 报错, 一般是 1dpkg: error: error creating new backup file &#x27;/var/lib/dpkg/status-old&#x27;: Invalid cross-device link 原因 -&gt; #836211 - dpkg: Cannot upgrade some packages on overlayfs: Invalid cross-device link - Debian Bug report log 在官方修复这个 bug 之前, 解决方案有两个 降级内核至 4.18 修改内核参数(推荐) 修改内核参数有几个方式, 比较方便的是改/etc/default/grub, 加上overlay.metacopy=N 1GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet overlay.metacopy=N&quot; 修改完后, 重新生成grub.cfg 1sudo grub-mkconfig -o /boot/grub/grub.cfg 到目前为止(18 年 12 月 10 日), 内核滚到了 4.19.8, 这个 bug 还存在4.19.11-arch1-1-ARCH (18 年 12 月 21 日)修复了这个 bug","categories":[{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linweiyuan.github.io/tags/Docker/"}]},{"title":"Feign使用Hystrix不生效","slug":"Feign使用Hystrix不生效","date":"2018-12-05T14:31:29.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/12/05/Feign使用Hystrix不生效.html","link":"","permalink":"https://linweiyuan.github.io/2018/12/05/Feign%E4%BD%BF%E7%94%A8Hystrix%E4%B8%8D%E7%94%9F%E6%95%88.html","excerpt":"","text":"检查是不是版本问题, 参考 -&gt;Disable HystrixCommands For FeignClients By Default 修改配置 123feign: hystrix: enabled: true","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://linweiyuan.github.io/tags/Spring-Cloud/"},{"name":"Feign","slug":"Feign","permalink":"https://linweiyuan.github.io/tags/Feign/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://linweiyuan.github.io/tags/Hystrix/"}]},{"title":"Arch Linux解决deepin-wechat闪退","slug":"Arch-Linux解决deepin-wechat闪退","date":"2018-12-05T02:37:11.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/12/05/Arch-Linux解决deepin-wechat闪退.html","link":"","permalink":"https://linweiyuan.github.io/2018/12/05/Arch-Linux%E8%A7%A3%E5%86%B3deepin-wechat%E9%97%AA%E9%80%80.html","excerpt":"","text":"1yaourt -S deepin-wechat 安装后启动闪退, 修改配置文件/opt/deepinwine/apps/Deepin-WeChat/run.sh 原内容 1/opt/deepinwine/tools/run.sh $BOTTLENAME $APPVER &quot;$1&quot; &quot;$2&quot; &quot;$3&quot; 注释掉, 或者替换为 1env WINEPREFIX=&quot;$HOME/.deepinwine/Deepin-WeChat&quot; wine &quot;c:\\\\Program Files\\\\Tencent\\\\WeChat\\\\WeChat.exe&quot; &amp; 启动一切正常, 版本2.6.4.38-4","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"},{"name":"deepin-wechat","slug":"deepin-wechat","permalink":"https://linweiyuan.github.io/tags/deepin-wechat/"}]},{"title":"Arch Linux安装脚本","slug":"Arch-Linux安装脚本","date":"2018-11-17T09:53:20.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/11/17/Arch-Linux安装脚本.html","link":"","permalink":"https://linweiyuan.github.io/2018/11/17/Arch-Linux%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC.html","excerpt":"","text":"进阶版：Arch Linux 简易安装脚本（i3, kde, deepin）适用于UEFI + KDE + Plasma 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299#!/bin/bashprepare() &#123; # 分区 DISK=/dev/nvme0n1 ESP=/dev/nvme0n1p1 ROOT=/dev/nvme0n1p2 parted $DISK mklabel gpt parted $DISK mkpart primary 1 512M parted $DISK mkpart primary &#x27;512M -1&#x27; # -1转义 parted $DISK set 1 boot on # 格式化 mkfs.fat -F32 $ESP mkfs.ext4 $ROOT # 挂载 mount $ROOT /mnt mkdir -p /mnt/boot/efi mount $ESP /mnt/boot/efi # archlinux源 echo &#x27;Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/x86_64&#x27; &gt; /etc/pacman.d/mirrorlist # 安装 pacstrap /mnt base base-devel bash-completion grub efibootmgr genfstab -U -p /mnt &gt; /mnt/etc/fstab # 配置grub arch-chroot /mnt grub-install --efi-directory=/boot/efi --bootloader-id=Arch arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg arch-chroot /mnt sed &#x27;/set timeout=5/&#123;s/5/0/&#125;&#x27; -i /boot/grub/grub.cfg # 后面还会用到 cp install.sh /mnt/root # 重启 umount /mnt/boot/efi umount /mnt reboot -f&#125;pgk=( adobe-source-han-sans-cn-fonts adobe-source-han-sans-jp-fonts adobe-source-han-sans-kr-fonts # anaconda android-apktool android-emulator android-file-transfer # android-ndk android-platform android-sdk-build-tools android-studio android-support android-support-repository android-tools apache-tools ark chromium deepin-screenshot deepin-screen-recorder docker docker-compose # docker-machine dolphin fcitx-im fcitx-sogoupinyin filelight filezilla # gimp git gwenview gradle intellij-idea-ultimate-edition intellij-idea-ultimate-edition-jre jdk8 jq kate kcm-fcitx kdialog kinfocenter konsole libreoffice-still libsodium lrzsz maven metasploit mlocate netease-cloud-music net-tools nodejs noto-fonts noto-fonts-emoji npm ntfs-3g okteta okular # openntpd openssh pepper-flash phonon-qt5-vlc plasma-desktop plasma-nm plasma-pa powerdevil # powerpill privoxy proxychains-ng python-pip redis-desktop-manager rsync sddm shadowsocks sublime-text-dev teamviewer typora unrar unzip user-manager virtualbox-ext-oracle virtualbox-guest-iso virtualbox-host-modules-arch vokoscreen-git wewechat wireshark-qt xorg-server xorg-xkill yakuake youtube-dl zip zsh)aur=( android-google-repository android-sources-28 android-x86-64-system-image-28 archlinux-themes-sddm burpsuite deepin-wine-thunderspeed dex2jar dirbuster # jd-gui # build太久 maltego python-genpac)aur() &#123; yaourt -S --noconfirm --needed $&#123;aur[@]&#125;&#125;setup() &#123; # 基本数据 HOSTNAME=&#x27;主机名&#x27; USERNAME=&#x27;用户名&#x27; PASSWORD=&#x27;密码&#x27; SS_CONFIG_NAME=&#x27;SS配置文件名&#x27; SS_SERVER=&#x27;SS服务器地址&#x27; SS_PORT=&#x27;SS端口&#x27; SS_PASSWORD=&#x27;SS密码&#x27; SS_METHOD=&#x27;SS加密方式&#x27; # archlinuxcn源 sed &#x27;/#Color\\|#TotalDownload\\|#\\[multilib\\]/&#123;s/#//&#125;&#x27; -i /etc/pacman.conf sed &#x27;s/Required DatabaseOptional/Never/g&#x27; -i /etc/pacman.conf sed &#x27;94s/#//&#x27; -i /etc/pacman.conf # [multilib] echo -e &#x27;\\n[archlinuxcn]\\nServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/x86_64&#x27; &gt;&gt; /etc/pacman.conf pacman -Syy --noconfirm archlinuxcn-keyring yaourt # 用户 useradd -m $USERNAME # sudo免密码 echo -e &quot;\\n$USERNAME ALL=(ALL) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers echo $USERNAME:$PASSWORD | chpasswd # 安装需要的包 pacman -S --noconfirm --needed $&#123;pgk[@]&#125; # shadowsocks mv /etc/shadowsocks/example.json /etc/shadowsocks/$SS_CONFIG_NAME.json sed &quot;s/my_server_ip/$SS_SERVER/g&quot; -i /etc/shadowsocks/$SS_CONFIG_NAME.json sed &quot;s/8388/$SS_PORT/g&quot; -i /etc/shadowsocks/$SS_CONFIG_NAME.json sed &quot;s/mypassword/$SS_PASSWORD/g&quot; -i /etc/shadowsocks/$SS_CONFIG_NAME.json sed &quot;s/aes-256-cfb/$SS_METHOD/g&quot; -i /etc/shadowsocks/$SS_CONFIG_NAME.json systemctl enable shadowsocks@$SS_CONFIG_NAME.service systemctl start shadowsocks@$SS_CONFIG_NAME.service # proxychains-ng sed &#x27;/#quiet_mode/&#123;s/#//&#125;&#x27; -i /etc/proxychains.conf # 减少输出 sed &quot;s/socks4 127.0.0.1 9050/\\nsocks5 127.0.0.1 1080/g&quot; -i /etc/proxychains.conf # privoxy sed &#x27;s/127.0.0.1:8118/0.0.0.0:8118/g&#x27; -i /etc/privoxy/config echo -e &#x27;\\nforward-socks5 / 127.0.0.1:1080 .&#x27; &gt;&gt; /etc/privoxy/config systemctl enable privoxy.service systemctl start privoxy.service sleep 1s # 配置生效延迟 # AUR使用HTTP代理 export http_proxy=127.0.0.1:8118 export https_proxy=127.0.0.1:8118 # AUR不能用root cp install.sh /home/$USERNAME/ chown $USERNAME:$USERNAME /home/$USERNAME/install.sh cd /home/$USERNAME # 权限问题 su $USERNAME -c &quot;/home/$USERNAME/install.sh aur&quot; ################################################## # 详细配置 # 主机 hostnamectl set-hostname $HOSTNAME # 时区 timedatectl set-timezone Asia/Shanghai # 国际化 sed &#x27;/#en_US.UTF-8\\|#zh_CN.UTF-8/&#123;s/#//&#125;&#x27; -i /etc/locale.gen locale-gen echo &#x27;LANG=en_US.UTF-8&#x27; &gt; /etc/locale.conf # 基本文件夹 su $USERNAME -c &#x27;cd ~ &amp;&amp; mkdir Data Documents Downloads Music Pictures Project Software Temp Videos&#x27; # anaconda # echo &#x27;export PATH=/opt/anaconda/bin:$PATH&#x27; &gt;&gt; /etc/profile # android echo &#x27;export ANDROID_HOME=/opt/android-sdk&#x27; &gt;&gt; /etc/profile ln -s /opt/android-ndk /opt/android-sdk/ndk-bundle chown -R $USERNAME:$USERNAME /opt/android-sdk # Android Studio需要写文件到这些目录，AUR里找不到包 # chown -R $USERNAME:$USERNAME /opt/android-ndk # deepin-screen-recorder su $USERNAME -c &quot;mkdir -p /home/$USERNAME/.config/deepin/deepin-screen-recorder&quot; su $USERNAME -c &quot;echo -e \\&quot;[fileformat]\\nsave_directory=/home/$USERNAME/Videos\\&quot; &gt; ~/.config/deepin/deepin-screen-recorder/config.conf&quot; # docker gpasswd -a $USERNAME docker mkdir /etc/systemd/system/docker.service.d echo -e &#x27;[Service]\\nEnvironment=&quot;HTTP_PROXY=127.0.0.1:8118&quot;\\nEnvironment=&quot;HTTPS_PROXY=127.0.0.1:8118&quot;&#x27; &gt; /etc/systemd/system/docker.service.d/proxy.conf # 即使官方中国仓库或阿里云也不好使 systemctl enable docker.service # fcitx su $USERNAME -c &quot;echo -e &#x27;export GTK_IM_MODULE=fcitx\\nexport QT_IM_MODULE=fcitx\\nexport XMODIFIERS=@im=fcitx&#x27; &gt; /home/$USERNAME/.xprofile&quot; # jdk echo &#x27;export JAVA_HOME=/usr/lib/jvm/java-8-jdk&#x27; &gt;&gt; /etc/profile # mlocate updatedb # nano sed &#x27;48s/# //&#x27; -i /etc/nanorc # 行号 sed &#x27;262s/# //&#x27; -i /etc/nanorc # 代码高亮 # nodejs npm i -g cnpm --registry=https://registry.npm.taobao.org npm i -g hexo-cli # openntpd # systemctl enable openntpd.service # systemctl start openntpd.service # plasma-nm systemctl enable NetworkManager.service # privoxy sed &#x27;s/127.0.0.1:8118/0.0.0.0:8118/g&#x27; -i /etc/privoxy/config echo -e &#x27;\\nforward-socks5 / 127.0.0.1:1080 .&#x27; &gt;&gt; /etc/privoxy/config systemctl enable privoxy.service systemctl start privoxy.service # python-genpac su $USERNAME -c &quot;genpac --format=pac --pac-proxy=\\&quot;SOCKS5 127.0.0.1:1080\\&quot; &gt; /home/$USERNAME/.pac&quot; # sddm sddm --example-config &gt; /etc/sddm.conf sed &#x27;/Current=/&#123;s/=/=archlinux-simplyblack/&#125;&#x27; -i /etc/sddm.conf # 主题 systemctl enable sddm.service # teamviewer systemctl enable teamviewerd.service # virtualbox gpasswd -a $USERNAME vboxusers # wireshark gpasswd -a $USERNAME wireshark # zsh echo $PASSWORD | sudo -S su $USERNAME -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; reboot -f&#125;$1 进入 livecd 时执行 1./install.sh prepare 重启后执行 1./install setup","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://linweiyuan.github.io/tags/Shell/"}]},{"title":"Kotlin重启天翼网关","slug":"Kotlin重启天翼网关","date":"2018-11-13T10:24:39.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/11/13/Kotlin重启天翼网关.html","link":"","permalink":"https://linweiyuan.github.io/2018/11/13/Kotlin%E9%87%8D%E5%90%AF%E5%A4%A9%E7%BF%BC%E7%BD%91%E5%85%B3.html","excerpt":"","text":"jsoup 依赖 1implementation &quot;org.jsoup:jsoup:1.11.3&quot; 1234567891011121314151617181920212223242526272829303132333435363738import org.jsoup.Connectionimport org.jsoup.Jsoupimport java.util.regex.Patternfun main(args: Array&lt;String&gt;) &#123; val username = &quot;admin&quot; val password = &quot;123456&quot; val gateway = &quot;http://192.168.1.1&quot; val indexUrl = &quot;$gateway/cgi-bin/luci&quot; val rebootUrl = &quot;$gateway/cgi-bin/luci/admin/reboot&quot; val response = Jsoup.connect(indexUrl) .data(&quot;username&quot;, username) .data(&quot;psd&quot;, password) .method(Connection.Method.POST) .followRedirects(false) .execute() when (response.statusCode()) &#123; 200 -&gt; println(&quot;用户名或密码错误&quot;) 302 -&gt; &#123; val cookies = response.cookies() val html = Jsoup.connect(&quot;$gateway$&#123;response.header(&quot;Location&quot;)&#125;&quot;) .cookies(cookies) .get() .html() val matcher = Pattern.compile(&quot;token: &#x27;(.*?)&#x27;&quot;).matcher(html) if (matcher.find()) &#123; Jsoup.connect(rebootUrl) .cookies(cookies) .data(&quot;token&quot;, matcher.group(1)) .post() &#125; &#125; &#125;&#125;","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://linweiyuan.github.io/tags/Kotlin/"},{"name":"jsoup","slug":"jsoup","permalink":"https://linweiyuan.github.io/tags/jsoup/"}]},{"title":"@Cacheable注解不生效","slug":"Cacheable注解不生效","date":"2018-10-30T15:17:12.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/10/30/Cacheable注解不生效.html","link":"","permalink":"https://linweiyuan.github.io/2018/10/30/Cacheable%E6%B3%A8%E8%A7%A3%E4%B8%8D%E7%94%9F%E6%95%88.html","excerpt":"","text":"通过学习, 知道@Cacheable是代理, 调用内部方法不生效, 但是遇到了 Shiro 下缓存失效问题, 参考 -&gt; Spring service with cacheable methods gets initialized without cache when autowired in Shiro realm, 解决了问题 1@Lazy","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"Redis","slug":"Redis","permalink":"https://linweiyuan.github.io/tags/Redis/"}]},{"title":"Arch Linux网易云音乐Bug解决","slug":"Arch-Linux网易云音乐Bug解决","date":"2018-10-27T16:50:12.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/10/27/Arch-Linux网易云音乐Bug解决.html","link":"","permalink":"https://linweiyuan.github.io/2018/10/27/Arch-Linux%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90Bug%E8%A7%A3%E5%86%B3.html","excerpt":"","text":"忘记从哪个版本开始, 网易云音乐打开关掉界面后, 程序在系统托盘区走到了通知栏那里 (KDE + Plasma), 并且无法打开右键菜单, 参考 -&gt; AUR (en) - netease-cloud-music上的解决方案, 修改启动命令 1XDG_CURRENT_DESKTOP=DDE netease-cloud-music %U","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"}]},{"title":"Arch Linux取消Redis Desktop Manager的自动更新","slug":"Arch-Linux取消Redis-Desktop-Manager的自动更新","date":"2018-10-27T16:38:51.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/10/27/Arch-Linux取消Redis-Desktop-Manager的自动更新.html","link":"","permalink":"https://linweiyuan.github.io/2018/10/27/Arch-Linux%E5%8F%96%E6%B6%88Redis-Desktop-Manager%E7%9A%84%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0.html","excerpt":"","text":"让Pacman去管理软件的生命周期比较好, 修改/etc/hosts 10.0.0.0 redisdesktop.com","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"}]},{"title":"解决SSH登录CentOS慢","slug":"解决SSH登录CentOS慢","date":"2018-10-18T10:00:25.000Z","updated":"2023-05-20T01:12:21.112Z","comments":true,"path":"2018/10/18/解决SSH登录CentOS慢.html","link":"","permalink":"https://linweiyuan.github.io/2018/10/18/%E8%A7%A3%E5%86%B3SSH%E7%99%BB%E5%BD%95CentOS%E6%85%A2.html","excerpt":"","text":"关闭 DNS 反向解析 编辑/etc/ssh/sshd_config 1UseDNS no","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://linweiyuan.github.io/tags/CentOS/"}]},{"title":"Arch Linux搜狗输入法滚挂","slug":"Arch-Linux搜狗输入法滚挂","date":"2018-09-15T03:41:17.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/09/15/Arch-Linux搜狗输入法滚挂.html","link":"","permalink":"https://linweiyuan.github.io/2018/09/15/Arch-Linux%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E6%BB%9A%E6%8C%82.html","excerpt":"","text":"搜狗输入法滚挂了, 老是提示输入法异常, 请删除配置文件什么的, 试过全部不行 不知道怎么解决, WiKi 也没说什么, 于是自己摸索 台式机滚挂了, 笔记本还是好的, 于是把配置 rsync 过去, not work 重现环境, 升级笔记本, 重启后果然滚挂了, 查看日志揪出几个软件 改源、pacman -Suu 降级、pacman -U 等一系列操作最后的最后发现是 libidn-1.34-2-x86_64.pkg.tar.xz 由于 vlc-3.0.4-2-x86_64.pkg.tar.xz 又依赖它, 所以把这两个暂时加入 IgnorePkg 恢复正常, 搜狗输入法当前版本版本2.2.0.0108-3 当天输入法更新, 修复了这个 bug -&gt; fcitx-sogoupinyin 2.2.0.0108-4","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"},{"name":"Fcitx","slug":"Fcitx","permalink":"https://linweiyuan.github.io/tags/Fcitx/"}]},{"title":"MySQL in Docker时区设置","slug":"MySQL-in-Docker时区设置","date":"2018-09-04T10:03:54.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/09/04/MySQL-in-Docker时区设置.html","link":"","permalink":"https://linweiyuan.github.io/2018/09/04/MySQL-in-Docker%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE.html","excerpt":"","text":"123mysql: environment: - TZ=Asia/Shanghai","categories":[{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linweiyuan.github.io/tags/Docker/"},{"name":"MySQL","slug":"MySQL","permalink":"https://linweiyuan.github.io/tags/MySQL/"}]},{"title":"Jenkins in Docker修改时间","slug":"Jenkins-in-Docker时区设置","date":"2018-09-03T15:02:26.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/09/03/Jenkins-in-Docker时区设置.html","link":"","permalink":"https://linweiyuan.github.io/2018/09/03/Jenkins-in-Docker%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE.html","excerpt":"","text":"官方文档访问 403, 查资料和测试, 下面方式可行 12345jenkins: environment: - JAVA_OPTS=-Duser.timezone=Asia/Shanghai volumes: - /etc/localtime:/etc/localtime","categories":[{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linweiyuan.github.io/tags/Docker/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://linweiyuan.github.io/tags/Jenkins/"}]},{"title":"某站MySQL弱口令导致任意数据修改","slug":"某站MySQL弱口令导致任意数据修改","date":"2018-08-25T05:21:24.000Z","updated":"2023-05-20T01:12:21.104Z","comments":true,"path":"2018/08/25/某站MySQL弱口令导致任意数据修改.html","link":"","permalink":"https://linweiyuan.github.io/2018/08/25/%E6%9F%90%E7%AB%99MySQL%E5%BC%B1%E5%8F%A3%E4%BB%A4%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9.html","excerpt":"","text":"业务数据库 jeeplus 任意数据增删改查","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://linweiyuan.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://linweiyuan.github.io/tags/MySQL/"},{"name":"Vulnerability","slug":"Vulnerability","permalink":"https://linweiyuan.github.io/tags/Vulnerability/"}]},{"title":"某站MySQL弱口令","slug":"某站MySQL弱口令","date":"2018-08-12T03:52:12.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2018/08/12/某站MySQL弱口令.html","link":"","permalink":"https://linweiyuan.github.io/2018/08/12/%E6%9F%90%E7%AB%99MySQL%E5%BC%B1%E5%8F%A3%E4%BB%A4.html","excerpt":"","text":"任意表增删改查","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://linweiyuan.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://linweiyuan.github.io/tags/MySQL/"},{"name":"Vulnerability","slug":"Vulnerability","permalink":"https://linweiyuan.github.io/tags/Vulnerability/"}]},{"title":"修改war包里面的内容","slug":"修改war包里面的内容","date":"2018-07-18T06:22:48.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2018/07/18/修改war包里面的内容.html","link":"","permalink":"https://linweiyuan.github.io/2018/07/18/%E4%BF%AE%E6%94%B9war%E5%8C%85%E9%87%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9.html","excerpt":"","text":"一般情况下, 开发会分为dev、test、prod或更多, 在没有很好地处理好自动化的情况下就要人工打包, 人就难免会出现失误 先解包, 用jar而不是java 1jar -xvf war包 修改好文件, 再替换封包 1jar -uvf war包 修改的文件的路径 前后路径要一致","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"war","slug":"war","permalink":"https://linweiyuan.github.io/tags/war/"}]},{"title":"Linux路由配置","slug":"Linux路由配置","date":"2018-07-17T02:11:18.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/07/17/Linux路由配置.html","link":"","permalink":"https://linweiyuan.github.io/2018/07/17/Linux%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE.html","excerpt":"","text":"123sudo route delete -net 0.0.0.0 wlp2s0sudo route add -net 10.124.0.0 gw 172.27.35.1 netmask 255.255.0.0 wlp2s0sudo route add -net 10.150.0.0 gw 172.27.35.1 netmask 255.255.0.0 wlp2s0","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"}]},{"title":"Gitlab更新代码提示","slug":"GitLab更新代码提示","date":"2018-07-13T08:50:13.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/07/13/GitLab更新代码提示.html","link":"","permalink":"https://linweiyuan.github.io/2018/07/13/GitLab%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA.html","excerpt":"","text":"发送端 1234567891011121314151617try &#123; StringBuilder content = new StringBuilder(); List&lt;Commits&gt; commits = root.getCommits(); for (Commits commit : commits) &#123; Author author = commit.getAuthor(); content.append(author.getName()).append(&quot; - &quot;).append(author.getEmail()).append(&quot;\\n\\n&quot;) .append(&quot;push detected&quot;).append(&quot;\\n\\n&quot;) .append(commit.getMessage()); byte[] bytes = content.toString().getBytes(); DatagramSocket socket = new DatagramSocket(); socket.send(new DatagramPacket(bytes, bytes.length, InetAddress.getByName(&quot;192.168.1.255&quot;), 11111)); socket.close(); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 接收端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import javax.imageio.ImageIO;import javax.swing.*;import java.awt.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.net.DatagramPacket;import java.net.DatagramSocket;public class Reminder extends JFrame &#123; private DatagramSocket socket; public Reminder() throws Exception &#123; initSystemTray(); initListen(initSocket()); &#125; private void initSystemTray() throws Exception &#123; SystemTray tray = SystemTray.getSystemTray(); TrayIcon trayIcon = new TrayIcon(ImageIO.read(getClass().getResourceAsStream(&quot;icon.png&quot;)), &quot;&quot;); trayIcon.setToolTip(&quot;&quot;); tray.add(trayIcon); trayIcon.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; if (e.getButton() == MouseEvent.BUTTON2) &#123; socket.close(); System.exit(0); &#125; &#125; &#125;); &#125; private DatagramPacket initSocket() throws Exception &#123; socket = new DatagramSocket(11111); byte[] bytes = new byte[1024]; return new DatagramPacket(bytes, bytes.length); &#125; private void initListen(DatagramPacket packet) throws Exception &#123; while (true) &#123; socket.receive(packet); showDialog(packet); &#125; &#125; private void showDialog(DatagramPacket packet) &#123; JFrame frame = new JFrame(); frame.setSize(300, 150); frame.setLocationRelativeTo(null); frame.setDefaultCloseOperation(DISPOSE_ON_CLOSE); JTextArea area = new JTextArea(); String osName = System.getProperty(&quot;os.name&quot;); switch (osName) &#123; case &quot;Linux&quot;: area.setFont(new Font(&quot;WenQuanYi Micro Hei&quot;, Font.PLAIN, 14)); break; default: break; &#125; area.setText(new String(packet.getData())); frame.add(area); frame.setVisible(true); &#125; public static void main(String[] args) &#123; try &#123; new Reminder(); UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://linweiyuan.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Swing","slug":"Swing","permalink":"https://linweiyuan.github.io/tags/Swing/"},{"name":"GitLab","slug":"GitLab","permalink":"https://linweiyuan.github.io/tags/GitLab/"},{"name":"Socket","slug":"Socket","permalink":"https://linweiyuan.github.io/tags/Socket/"},{"name":"UDP","slug":"UDP","permalink":"https://linweiyuan.github.io/tags/UDP/"}]},{"title":"无图形化界面下WebLogic第三方API","slug":"无图形化界面下WebLogic第三方API","date":"2018-06-19T08:20:32.000Z","updated":"2023-05-20T01:12:21.100Z","comments":true,"path":"2018/06/19/无图形化界面下WebLogic第三方API.html","link":"","permalink":"https://linweiyuan.github.io/2018/06/19/%E6%97%A0%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E4%B8%8BWebLogic%E7%AC%AC%E4%B8%89%E6%96%B9API.html","excerpt":"","text":"部署 1234567java -cp weblogic.jar weblogic.Deployer \\-adminurl t3://127.0.0.1:7001 \\-user 用户名 \\-password 密码 \\-redeploy \\-name 自定义名字 \\-source war包 更改中心的锁定并编辑 -&gt; 释放配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import org.jsoup.Connection;import org.jsoup.Jsoup;import java.util.Map;public class FuckWebLogic &#123; public static void main(String[] args) &#123; try &#123; String SERVER = &quot;http://127.0.0.1:7001/console&quot;; Connection connection = Jsoup.connect(SERVER + &quot;/j_security_check&quot;) .method(Connection.Method.POST) .data(&quot;j_username&quot;, &quot;username&quot;) .data(&quot;j_password&quot;, &quot;password&quot;) .followRedirects(false);//不自动重定向, 为了下面根据状态码判断是否登录成功, 不然都是返回200 Connection.Response response = connection.execute(); int statusCode = response.statusCode(); switch (statusCode) &#123; case 200: System.out.println(&quot;login err&quot;); break; case 302: System.out.println(&quot;login ok&quot;); //登录成功的Cookie Map&lt;String, String&gt; cookies = response.cookies(); System.out.println(&quot;Cookie -&gt; &quot; + cookies); //获取页面的防CSRF隐藏参数（这里类似验证码的效果） String token = connection.url(SERVER + &quot;/console.portal&quot;) .method(Connection.Method.GET) .cookies(cookies) .followRedirects(true)//这里就要设置true了 .execute() .parse() .select(&quot;input[name=ChangeManagerPortletfrsc]&quot;).val(); System.out.println(&quot;Token -&gt; &quot; + token); //这时要刷新Cookie, 和上面的隐藏参数要对得上 cookies = response.cookies(); System.out.println(&quot;new Cookie -&gt; &quot; + cookies); //模拟点击操作 response = connection.url(SERVER + &quot;/console.portal&quot;) .method(Connection.Method.POST) .data(&quot;ChangeManagerPortlet_actionOverride&quot;, &quot;/StopEditAction&quot;) .data(&quot;ChangeManagerPortletfrsc&quot;, token) .cookies(cookies) .execute(); //如果标题没有指定字符串, 说明Cookie错误, 跳到登录页了 System.out.println(response.body().contains(&quot;dmz&quot;) ? &quot;ok&quot; : &quot;err&quot;); break; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"https://linweiyuan.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"},{"name":"jsoup","slug":"jsoup","permalink":"https://linweiyuan.github.io/tags/jsoup/"},{"name":"WebLogic","slug":"WebLogic","permalink":"https://linweiyuan.github.io/tags/WebLogic/"}]},{"title":"WebLogic远程调试","slug":"WebLogic远程调试","date":"2018-06-07T03:04:08.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/06/07/WebLogic远程调试.html","link":"","permalink":"https://linweiyuan.github.io/2018/06/07/WebLogic%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95.html","excerpt":"","text":"修改环境变量Software/WebLogic/Oracle/Middleware/Oracle_Home/user_projects/domains/idc/bin/setDomainEnv.sh 修改端口 1234if [ &quot;$&#123;DEBUG_PORT&#125;&quot; = &quot;&quot; ] ; then DEBUG_PORT=&quot;9088&quot; export DEBUG_PORTfi 打开调试 123456789if [ &quot;true&quot; = &quot;true&quot; ] ; then JAVA_DEBUG=&quot;-Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,address=$&#123;DEBUG_PORT&#125;,server=y,suspend=n -Djava.compiler=NONE&quot; export JAVA_DEBUG JAVA_OPTIONS=&quot;$&#123;JAVA_OPTIONS&#125; $&#123;enableHotswapFlag&#125; -ea -da:com.bea... -da:javelin... -da:weblogic... -ea:com.bea.wli... -ea:com.bea.broker... -ea:com.bea.sbconsole...&quot; export JAVA_OPTIONSelse JAVA_OPTIONS=&quot;$&#123;JAVA_OPTIONS&#125; $&#123;enableHotswapFlag&#125; -da&quot; export JAVA_OPTIONSfi 简单粗暴","categories":[{"name":"服务器","slug":"服务器","permalink":"https://linweiyuan.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://linweiyuan.github.io/tags/IDEA/"},{"name":"WebLogic","slug":"WebLogic","permalink":"https://linweiyuan.github.io/tags/WebLogic/"}]},{"title":"Ant脚本杀掉Tomcat","slug":"Ant脚本杀掉Tomcat","date":"2018-05-25T01:42:11.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/05/25/Ant脚本杀掉Tomcat.html","link":"","permalink":"https://linweiyuan.github.io/2018/05/25/Ant%E8%84%9A%E6%9C%AC%E6%9D%80%E6%8E%89Tomcat.html","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;project name=&quot;项目名&quot; basedir=&quot;.&quot; default=&quot;deploy&quot;&gt; &lt;property name=&quot;src.dir&quot; value=&quot;src&quot;/&gt; &lt;property name=&quot;web.dir&quot; value=&quot;web&quot;/&gt; &lt;property name=&quot;build.dir&quot; value=&quot;$&#123;web.dir&#125;/WEB-INF/classes&quot;/&gt; &lt;property name=&quot;tomcat.name&quot; value=&quot;Tomcat目录名&quot;/&gt; &lt;property name=&quot;tomcat.path&quot; value=&quot;Tomcat路径&quot;/&gt; &lt;property name=&quot;deploy.path&quot; value=&quot;$&#123;tomcat.path&#125;/webapps&quot;/&gt; &lt;property name=&quot;war.name&quot; value=&quot;war包&quot;/&gt; &lt;property name=&quot;jdk.version&quot; value=&quot;1.8&quot;/&gt; &lt;path id=&quot;classpath&quot;&gt; &lt;fileset dir=&quot;$&#123;web.dir&#125;/WEB-INF/lib&quot; includes=&quot;*.jar&quot;/&gt; &lt;pathelement path=&quot;$&#123;build.dir&#125;&quot;/&gt; &lt;/path&gt; &lt;target name=&quot;clean&quot;&gt; &lt;echo message=&quot;clean start...&quot;/&gt; &lt;delete&gt; &lt;fileset dir=&quot;$&#123;build.dir&#125;&quot;&gt; &lt;include name=&quot;**/*.class&quot;/&gt; &lt;/fileset&gt; &lt;/delete&gt; &lt;echo message=&quot;clean end...&quot;/&gt; &lt;/target&gt; &lt;target name=&quot;build&quot; depends=&quot;clean&quot;&gt; &lt;echo message=&quot;build start...&quot;/&gt; &lt;mkdir dir=&quot;$&#123;build.dir&#125;&quot;/&gt; &lt;javac destdir=&quot;$&#123;build.dir&#125;&quot; source=&quot;$&#123;jdk.version&#125;&quot; target=&quot;$&#123;jdk.version&#125;&quot; includeantruntime=&quot;true&quot; nowarn=&quot;true&quot;&gt; &lt;src path=&quot;$&#123;src.dir&#125;&quot;/&gt; &lt;classpath refid=&quot;classpath&quot;/&gt; &lt;/javac&gt; &lt;echo message=&quot;build end...&quot;/&gt; &lt;/target&gt; &lt;target name=&quot;war&quot; depends=&quot;build&quot;&gt; &lt;echo message=&quot;pack war start...&quot;/&gt; &lt;tstamp&gt; &lt;format property=&quot;date&quot; pattern=&quot;yyyy_MM_dd&quot;/&gt; &lt;/tstamp&gt; &lt;war destfile=&quot;自定义名字_$&#123;date&#125;.war&quot; webxml=&quot;$&#123;web.dir&#125;/WEB-INF/web.xml&quot;&gt; &lt;fileset dir=&quot;$&#123;web.dir&#125;&quot;&gt; &lt;include name=&quot;**/*.*&quot;/&gt; &lt;/fileset&gt; &lt;classes dir=&quot;$&#123;build.dir&#125;&quot;/&gt; &lt;/war&gt; &lt;echo message=&quot;pack war end...&quot;/&gt; &lt;echo message=&quot;copy war start...&quot;/&gt; &lt;copy tofile=&quot;$&#123;deploy.path&#125;/$&#123;war.name&#125;&quot; preservelastmodified=&quot;true&quot; overwrite=&quot;true&quot;&gt; &lt;fileset dir=&quot;.&quot;&gt; &lt;include name=&quot;自定义名字$&#123;date&#125;.war&quot;/&gt; &lt;/fileset&gt; &lt;/copy&gt; &lt;echo message=&quot;copy war end...&quot;/&gt; &lt;/target&gt; &lt;target name=&quot;deploy&quot; depends=&quot;war&quot;&gt; &lt;echo message=&quot;shutdown tomcat start...&quot;/&gt; &lt;exec executable=&quot;/bin/zsh&quot;&gt; &lt;arg value=&quot;-c&quot;/&gt; &lt;arg value=&quot;ps x | grep tomcat | grep -v grep | awk &#x27;&#123;print $1&#125;&#x27; | xargs kill -9 &amp;amp; &gt; /dev/null&quot;/&gt; &lt;/exec&gt; &lt;echo message=&quot;shutdown tomcat end...&quot;/&gt; &lt;echo message=&quot;startup tomcat start...&quot;/&gt; &lt;exec executable=&quot;/bin/zsh&quot;&gt; &lt;arg value=&quot;$&#123;tomcat.path&#125;/bin/startup.sh&quot;/&gt; &lt;/exec&gt; &lt;echo message=&quot;startup tomcat end...&quot;/&gt; &lt;/target&gt;&lt;/project&gt;","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://linweiyuan.github.io/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Ant","slug":"Ant","permalink":"https://linweiyuan.github.io/tags/Ant/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://linweiyuan.github.io/tags/Tomcat/"},{"name":"Shell","slug":"Shell","permalink":"https://linweiyuan.github.io/tags/Shell/"}]},{"title":"KDE开启VNC","slug":"KDE开启VNC","date":"2018-04-29T04:09:03.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/04/29/KDE开启VNC.html","link":"","permalink":"https://linweiyuan.github.io/2018/04/29/KDE%E5%BC%80%E5%90%AFVNC.html","excerpt":"","text":"TigerVNC 12#!/bin/shdbus-launch startkde KDE Plasma显示正常","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"},{"name":"KDE","slug":"KDE","permalink":"https://linweiyuan.github.io/tags/KDE/"},{"name":"TigerVNC","slug":"TigerVNC","permalink":"https://linweiyuan.github.io/tags/TigerVNC/"}]},{"title":"Tomcat远程调试","slug":"Tomcat远程调试","date":"2018-04-19T03:00:47.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/04/19/Tomcat远程调试.html","link":"","permalink":"https://linweiyuan.github.io/2018/04/19/Tomcat%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95.html","excerpt":"","text":"1./catalina.sh jpda start","categories":[{"name":"服务器","slug":"服务器","permalink":"https://linweiyuan.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://linweiyuan.github.io/tags/Tomcat/"},{"name":"IDEA","slug":"IDEA","permalink":"https://linweiyuan.github.io/tags/IDEA/"}]},{"title":"Git批量恢复删除的文件","slug":"Git批量恢复删除的文件","date":"2018-04-17T07:43:26.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/04/17/Git批量恢复删除的文件.html","link":"","permalink":"https://linweiyuan.github.io/2018/04/17/Git%E6%89%B9%E9%87%8F%E6%81%A2%E5%A4%8D%E5%88%A0%E9%99%A4%E7%9A%84%E6%96%87%E4%BB%B6.html","excerpt":"","text":"1git ls-files -d | xargs -i git checkout &#123;&#125;","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://linweiyuan.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://linweiyuan.github.io/tags/Git/"}]},{"title":"某站XSS漏洞","slug":"某站XSS漏洞-1","date":"2018-03-25T06:12:11.000Z","updated":"2023-05-20T01:12:21.104Z","comments":true,"path":"2018/03/25/某站XSS漏洞-1.html","link":"","permalink":"https://linweiyuan.github.io/2018/03/25/%E6%9F%90%E7%AB%99XSS%E6%BC%8F%E6%B4%9E-1.html","excerpt":"","text":"弹窗","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://linweiyuan.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"https://linweiyuan.github.io/tags/Vulnerability/"},{"name":"XSS","slug":"XSS","permalink":"https://linweiyuan.github.io/tags/XSS/"}]},{"title":"Manjaro的RTL8192EU无线网卡驱动","slug":"Manjaro的RTL8192EU无线网卡驱动","date":"2018-03-12T01:22:19.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/03/12/Manjaro的RTL8192EU无线网卡驱动.html","link":"","permalink":"https://linweiyuan.github.io/2018/03/12/Manjaro%E7%9A%84RTL8192EU%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8.html","excerpt":"","text":"TP-LINK 的TL-WN821N在 Manjaro 下插上了能搜到 Wi-Fi 信号, 但是信号很弱并且输入正确的密码后一直无法连接上, lsusb发现是 1Bus 001 Device 002: ID 0bda:818b Realtek Semiconductor Corp. RTL8192EU 802.11b/g/n WLAN Adapter 然而, lshw -c network却发现 1configuration: broadcast=yes driver=rtl8xxxu driverversion=4.14.24-1-MANJARO firmware=N/A link=no multicast=yes wireless=IEEE 802.11 8192EU的芯片默认是rtl8xxxu的驱动, 我就想有没有8192EU的驱动, 我安装试下 于是上 AUR 搜了搜, 果然有 -&gt; 8192eu-dkms 于是下载了安装, 再把原来的拉黑/etc/modprobe.d/rtl8xxxu_blacklist.conf 1blacklist rtl8xxxu 当然还要装对应的headers 重启后, 再看下驱动 1configuration: broadcast=yes driver=rtl8192eu multicast=yes wireless=unassociated 驱动成功, 信号满格, 输入密码秒连, 并且原来的iw list只支持 123Supported interface modes:* managed* monitor 现在连AP都支持了 1234567Supported interface modes:* IBSS* managed* AP* monitor* P2P-client* P2P-GO","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Manjaro","slug":"Manjaro","permalink":"https://linweiyuan.github.io/tags/Manjaro/"},{"name":"RTL8192EU","slug":"RTL8192EU","permalink":"https://linweiyuan.github.io/tags/RTL8192EU/"}]},{"title":"Git status中文显示数字解决","slug":"Git-status中文显示数字解决","date":"2018-02-26T04:46:54.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/02/26/Git-status中文显示数字解决.html","link":"","permalink":"https://linweiyuan.github.io/2018/02/26/Git-status%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%97%E8%A7%A3%E5%86%B3.html","excerpt":"","text":"1git config --global core.quotepath false","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://linweiyuan.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://linweiyuan.github.io/tags/Git/"}]},{"title":"Arch Linux /tmp分区容量不足解决","slug":"Arch-Linux-tmp分区容量不足解决","date":"2018-02-26T04:29:55.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/02/26/Arch-Linux-tmp分区容量不足解决.html","link":"","permalink":"https://linweiyuan.github.io/2018/02/26/Arch-Linux-tmp%E5%88%86%E5%8C%BA%E5%AE%B9%E9%87%8F%E4%B8%8D%E8%B6%B3%E8%A7%A3%E5%86%B3.html","excerpt":"","text":"yaourt 安装Oracle-XE, 解压的时候报错, /tmp空间不足 参考查 wiki -&gt; tmpfs得知默认会把&#x2F;tmp 分成内存的一半, 我 512M 的内存, 所以分了 243M 原话是 12By default, a tmpfs partition has its maximum size set to half of the availableRAM, however it is possible to overrule this value. 解决方案是 123To explicitly set a maximum size, in this example to override the default /tmpmount, use the size mount option: /etc/fstab tmpfs /tmp tmpfsrw,nodev,nosuid,size=2G 0 0 改完保存重启再安装一切正常","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"},{"name":"Oracle-XE","slug":"Oracle-XE","permalink":"https://linweiyuan.github.io/tags/Oracle-XE/"}]},{"title":"Java多级菜单递归拼装Demo","slug":"Java多级菜单递归拼装Demo","date":"2018-02-08T06:26:38.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/02/08/Java多级菜单递归拼装Demo.html","link":"","permalink":"https://linweiyuan.github.io/2018/02/08/Java%E5%A4%9A%E7%BA%A7%E8%8F%9C%E5%8D%95%E9%80%92%E5%BD%92%E6%8B%BC%E8%A3%85Demo.html","excerpt":"","text":"JEECG的改造 Demo 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic List&lt;TSFunction&gt; getFunctionByRoleId(String roleId) &#123; List&lt;TSFunction&gt; functionList = new ArrayList&lt;&gt;(); // 查询全部菜单 List&lt;TSFunction&gt; functionList0 = tSFunctionMapper.selectAll(); // 角色权限相关菜单 List&lt;TSFunction&gt; roleFunctionList = tSRoleMapper.getFunctionByRoleId(roleId); for (TSFunction function0 : functionList0) &#123; function0.setChildren(makeFunctionList(functionList0, function0.getId(), roleFunctionList)); // 只添加一级菜单（下级菜单已拼装好在里面） if (StringUtil.isEmpty(function0.getParentfunctionid())) &#123; functionList.add(function0); &#125; &#125; return functionList;&#125;public List&lt;TSFunction&gt; makeFunctionList(List&lt;TSFunction&gt; srcFunctionList, String functionId, List&lt;TSFunction&gt; roleFunctionList) &#123; List&lt;TSFunction&gt; functionList = new ArrayList&lt;&gt;(); for (TSFunction function : srcFunctionList) &#123; String id = function.getId(); String parentfunctionid = function.getParentfunctionid(); // 非一级菜单递归查询 if (StringUtil.isNotEmpty(parentfunctionid)) &#123; if (parentfunctionid.equals(functionId)) &#123; function.setChildren(makeFunctionList(srcFunctionList, id, roleFunctionList)); functionList.add(function); &#125; &#125; // 角色权限√处理 for (TSFunction roleFunction : roleFunctionList) &#123; if (id.equals(roleFunction.getId())) &#123; function.setChecked(1); &#125; &#125; &#125; return functionList;&#125; 部分返回结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&#123; &quot;id&quot;: &quot;402889fb486e848101486e8de3d60005&quot;, &quot;functionlevel&quot;: 0, &quot;functionname&quot;: &quot;数据权限&quot;, &quot;functionorder&quot;: &quot;100&quot;, &quot;iconid&quot;: &quot;8a8ab0b246dc81120146dc8180820003&quot;, &quot;deskIconid&quot;: &quot;8a8ab0b246dc81120146dc8180dd001e&quot;, &quot;functiontype&quot;: 1, &quot;checked&quot;: 0, &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;402880f25a980e2a015a981dc8de0005&quot;, &quot;functionlevel&quot;: 1, &quot;functionname&quot;: &quot;请假自定义表单&quot;, &quot;functionorder&quot;: &quot;3&quot;, &quot;functionurl&quot;: &quot;autoFormController/af/employee_leave_form/goViewPage.do&quot;, &quot;parentfunctionid&quot;: &quot;402889fb486e848101486e8de3d60005&quot;, &quot;iconid&quot;: &quot;8a8ab0b246dc81120146dc8180460000&quot;, &quot;deskIconid&quot;: &quot;8a8ab0b246dc81120146dc8180dd001e&quot;, &quot;functiontype&quot;: 1, &quot;checked&quot;: 0, &quot;children&quot;: [] &#125;, &#123; &quot;id&quot;: &quot;402880f25a9833f5015a9843218f000c&quot;, &quot;functionlevel&quot;: 1, &quot;functionname&quot;: &quot;自定义表单查看&quot;, &quot;functionorder&quot;: &quot;4&quot;, &quot;functionurl&quot;: &quot;autoFormController/af/order_form/goUpdatePage.do&quot;, &quot;parentfunctionid&quot;: &quot;402889fb486e848101486e8de3d60005&quot;, &quot;iconid&quot;: &quot;8a8ab0b246dc81120146dc8180460000&quot;, &quot;deskIconid&quot;: &quot;8a8ab0b246dc81120146dc8180dd001e&quot;, &quot;functiontype&quot;: 1, &quot;checked&quot;: 0, &quot;children&quot;: [] &#125;, &#123; &quot;id&quot;: &quot;402881855ab8c48a015ab8d133050018&quot;, &quot;functionlevel&quot;: 1, &quot;functionname&quot;: &quot;测试online表单权限&quot;, &quot;functionorder&quot;: &quot;4&quot;, &quot;parentfunctionid&quot;: &quot;402889fb486e848101486e8de3d60005&quot;, &quot;iconid&quot;: &quot;8a8ab0b246dc81120146dc8180460000&quot;, &quot;deskIconid&quot;: &quot;8a8ab0b246dc81120146dc8180dd001e&quot;, &quot;functiontype&quot;: 1, &quot;checked&quot;: 0, &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;402880f25b1d5a3a015b1d772c2b0013&quot;, &quot;functionlevel&quot;: 1, &quot;functionname&quot;: &quot;请假单编辑页面&quot;, &quot;functionorder&quot;: &quot;2&quot;, &quot;functionurl&quot;: &quot;cgFormBuildController/ftlForm/jform_leave/goUpdate.do&quot;, &quot;parentfunctionid&quot;: &quot;402881855ab8c48a015ab8d133050018&quot;, &quot;iconid&quot;: &quot;8a8ab0b246dc81120146dc8180460000&quot;, &quot;deskIconid&quot;: &quot;8a8ab0b246dc81120146dc8180dd001e&quot;, &quot;functiontype&quot;: 1, &quot;checked&quot;: 0, &quot;children&quot;: [] &#125;, &#123; &quot;id&quot;: &quot;402880f25b1e2ac7015b1e5cdc340010&quot;, &quot;functionlevel&quot;: 2, &quot;functionname&quot;: &quot;online请假加载数据请求&quot;, &quot;functionorder&quot;: &quot;3&quot;, &quot;functionurl&quot;: &quot;cgAutoListController.do?datagrid&amp;configId=jform_leave&quot;, &quot;parentfunctionid&quot;: &quot;402881855ab8c48a015ab8d133050018&quot;, &quot;iconid&quot;: &quot;8a8ab0b246dc81120146dc8180460000&quot;, &quot;deskIconid&quot;: &quot;8a8ab0b246dc81120146dc8180dd001e&quot;, &quot;functiontype&quot;: 1, &quot;checked&quot;: 0, &quot;children&quot;: [] &#125;, &#123; &quot;id&quot;: &quot;402880f25b23a635015b23a992f10003&quot;, &quot;functionlevel&quot;: 1, &quot;functionname&quot;: &quot;ol订单编辑页面&quot;, &quot;functionorder&quot;: &quot;4&quot;, &quot;functionurl&quot;: &quot;cgFormBuildController/ftlForm/jform_order_main/goUpdate.do&quot;, &quot;parentfunctionid&quot;: &quot;402881855ab8c48a015ab8d133050018&quot;, &quot;iconid&quot;: &quot;8a8ab0b246dc81120146dc8180460000&quot;, &quot;deskIconid&quot;: &quot;8a8ab0b246dc81120146dc8180dd001e&quot;, &quot;functiontype&quot;: 1, &quot;checked&quot;: 0, &quot;children&quot;: [] &#125;, &#123; &quot;id&quot;: &quot;402881855ab8c48a015ab8d1f96f001b&quot;, &quot;functionlevel&quot;: 1, &quot;functionname&quot;: &quot;ol请假单查看页面&quot;, &quot;functionorder&quot;: &quot;1&quot;, &quot;functionurl&quot;: &quot;cgFormBuildController/ftlForm/jform_leave/goDetail.do&quot;, &quot;parentfunctionid&quot;: &quot;402881855ab8c48a015ab8d133050018&quot;, &quot;iconid&quot;: &quot;8a8ab0b246dc81120146dc8180460000&quot;, &quot;deskIconid&quot;: &quot;8a8ab0b246dc81120146dc8180dd001e&quot;, &quot;functiontype&quot;: 1, &quot;checked&quot;: 0, &quot;children&quot;: [] &#125; ] &#125;, &#123; &quot;id&quot;: &quot;4028ef81574ae99701574aeb97bd0003&quot;, &quot;functionlevel&quot;: 1, &quot;functionname&quot;: &quot;用户列表数据权限&quot;, &quot;functionorder&quot;: &quot;2&quot;, &quot;functionurl&quot;: &quot;userController.do?datagrid&quot;, &quot;parentfunctionid&quot;: &quot;402889fb486e848101486e8de3d60005&quot;, &quot;iconid&quot;: &quot;8a8ab0b246dc81120146dc8180460000&quot;, &quot;deskIconid&quot;: &quot;8a8ab0b246dc81120146dc8180dd001e&quot;, &quot;functiontype&quot;: 1, &quot;checked&quot;: 0, &quot;children&quot;: [] &#125;, &#123; &quot;id&quot;: &quot;40288088481d019401481d2fcebf000d&quot;, &quot;functionlevel&quot;: 1, &quot;functionname&quot;: &quot;minidao数据权限列表&quot;, &quot;functionorder&quot;: &quot;1&quot;, &quot;functionurl&quot;: &quot;jeecgListDemoController.do?minidaoDatagrid&quot;, &quot;parentfunctionid&quot;: &quot;402889fb486e848101486e8de3d60005&quot;, &quot;iconid&quot;: &quot;8a8ab0b246dc81120146dc8180820003&quot;, &quot;deskIconid&quot;: &quot;8a8ab0b246dc81120146dc8180dd001e&quot;, &quot;functiontype&quot;: 1, &quot;checked&quot;: 0, &quot;children&quot;: [] &#125; ]&#125;","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"JEECG","slug":"JEECG","permalink":"https://linweiyuan.github.io/tags/JEECG/"}]},{"title":"Oracle菜单类型递归查询Demo","slug":"Oracle菜单类型递归查询Demo","date":"2018-02-08T03:43:15.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/02/08/Oracle菜单类型递归查询Demo.html","link":"","permalink":"https://linweiyuan.github.io/2018/02/08/Oracle%E8%8F%9C%E5%8D%95%E7%B1%BB%E5%9E%8B%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2Demo.html","excerpt":"","text":"12345678910111213141516SELECT level, f.id, f.parentfunctionid, rpad(&#x27; &#x27;, (level - 1) * 5) || f.functionname functionname, f.functionorderFROM t_s_function fSTART WITH f.id = &#x27;402889fb486e848101486e8de3d60005&#x27;CONNECT BY f.parentfunctionid = PRIOR f.idORDER BY level, f.functionorder;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://linweiyuan.github.io/tags/Oracle/"},{"name":"SQL","slug":"SQL","permalink":"https://linweiyuan.github.io/tags/SQL/"}]},{"title":"Oracle行转列及去重","slug":"Oracle行转列及去重","date":"2018-02-07T09:23:39.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/02/07/Oracle行转列及去重.html","link":"","permalink":"https://linweiyuan.github.io/2018/02/07/Oracle%E8%A1%8C%E8%BD%AC%E5%88%97%E5%8F%8A%E5%8E%BB%E9%87%8D.html","excerpt":"","text":"在旧版本中, 可以使用wm_concat(), 并且自动去重 新版本 Oracle 默认屏蔽了wm_concat()函数, 可以用listagg() 但是, 有个缺点就是数据会重复, 所以要加个正则 1regexp_replace(?, &#x27;([^,]+)(,\\1)+&#x27;,&#x27;\\1&#x27;)","categories":[{"name":"数据库","slug":"数据库","permalink":"https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://linweiyuan.github.io/tags/Oracle/"},{"name":"SQL","slug":"SQL","permalink":"https://linweiyuan.github.io/tags/SQL/"}]},{"title":"Maven的Oracle的JDBC驱动","slug":"Maven的Oracle的JDBC驱动","date":"2018-02-06T17:11:58.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2018/02/06/Maven的Oracle的JDBC驱动.html","link":"","permalink":"https://linweiyuan.github.io/2018/02/06/Maven%E7%9A%84Oracle%E7%9A%84JDBC%E9%A9%B1%E5%8A%A8.html","excerpt":"","text":"官网下载 JDBC 驱动, 配置 Maven 1mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.5.0 -Dpackaging=jar -Dfile=ojdbc14.jar","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://linweiyuan.github.io/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"https://linweiyuan.github.io/tags/Maven/"},{"name":"Oracle","slug":"Oracle","permalink":"https://linweiyuan.github.io/tags/Oracle/"}]},{"title":"Git保存密码","slug":"Git保存密码","date":"2018-02-05T15:11:58.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2018/02/05/Git保存密码.html","link":"","permalink":"https://linweiyuan.github.io/2018/02/05/Git%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81.html","excerpt":"","text":"1git config --global credential.helper store","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://linweiyuan.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://linweiyuan.github.io/tags/Git/"}]},{"title":"某站XSS漏洞","slug":"某站XSS漏洞-2","date":"2018-01-01T06:15:29.000Z","updated":"2023-05-20T01:12:21.104Z","comments":true,"path":"2018/01/01/某站XSS漏洞-2.html","link":"","permalink":"https://linweiyuan.github.io/2018/01/01/%E6%9F%90%E7%AB%99XSS%E6%BC%8F%E6%B4%9E-2.html","excerpt":"","text":"弹窗","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://linweiyuan.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"https://linweiyuan.github.io/tags/Vulnerability/"},{"name":"XSS","slug":"XSS","permalink":"https://linweiyuan.github.io/tags/XSS/"}]},{"title":"Uploadify插件报queueData错","slug":"Uploadify插件报queueData错","date":"2017-12-20T06:41:09.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2017/12/20/Uploadify插件报queueData错.html","link":"","permalink":"https://linweiyuan.github.io/2017/12/20/Uploadify%E6%8F%92%E4%BB%B6%E6%8A%A5queueData%E9%94%99.html","excerpt":"","text":"利用这个插件上传文件时, 遇到了一个问题, 提示Cannot read property &#39;queueData&#39; of undefined 打开Chrome设置, 允许Flash, 即可","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://linweiyuan.github.io/tags/jQuery/"}]},{"title":"Linux删除指定扩展名文件","slug":"Linux删除指定扩展名文件","date":"2017-12-08T04:53:35.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2017/12/08/Linux删除指定扩展名文件.html","link":"","permalink":"https://linweiyuan.github.io/2017/12/08/Linux%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E6%89%A9%E5%B1%95%E5%90%8D%E6%96%87%E4%BB%B6.html","excerpt":"","text":"maven 下载 jar 的时候, 经常会半途断开连接导致报错, 再次更新就会提示 cache 的问题, 并且不会一次提示全部, 删一个提示下一个, 于是找到了一种一次性删除所有不合法 jar 的方法 1find repository/ -name &#x27;*.lastUpdated&#x27; -exec rm -rf &#123;&#125; \\; 重新下载没下载完的","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"}]},{"title":"Git push 提示HTTP 400","slug":"Git-push-提示HTTP-400","date":"2017-11-25T12:57:44.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/11/25/Git-push-提示HTTP-400.html","link":"","permalink":"https://linweiyuan.github.io/2017/11/25/Git-push-%E6%8F%90%E7%A4%BAHTTP-400.html","excerpt":"","text":"12error: RPC failed; HTTP 400 curl 22 The requested URL returned error: 400 Failed reading client bodyfatal: The remote end hung up unexpectedly HTTP 413, 调 nginx 配置 HTTP 400, 设置下 git 的缓冲区大小, 比如 100M 1git config --global http.postBuffer 104857600","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://linweiyuan.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://linweiyuan.github.io/tags/Git/"}]},{"title":"CentOS Minimal网络配置","slug":"CentOS-Minimal网络配置","date":"2017-11-25T04:38:06.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/11/25/CentOS-Minimal网络配置.html","link":"","permalink":"https://linweiyuan.github.io/2017/11/25/CentOS-Minimal%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.html","excerpt":"","text":"如果 CentOS Minimal 安装时没启动网络, 装完后需再设置才能联网 编辑/etc/sysconfig/network-script/ifcfg-xxx文件, 设置 1ONBOOT=yes 重启网络 1sudo systemctl restart network","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://linweiyuan.github.io/tags/CentOS/"}]},{"title":"Docker镜像加速","slug":"Docker镜像加速","date":"2017-11-24T15:43:38.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/11/24/Docker镜像加速.html","link":"","permalink":"https://linweiyuan.github.io/2017/11/24/Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F.html","excerpt":"","text":"为了永久生效, 可以通过配置文件的方式进行配置, 参考 -&gt; Docker 中国官方镜像加速 修改/etc/docker/daemon.json文件（文件夹没有的就创建）, 加入以下内容 123&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125; 重启 Docker 不一定生效, 最好重启系统","categories":[{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linweiyuan.github.io/tags/Docker/"}]},{"title":"CentOS安装Node.js","slug":"CentOS安装Node-js","date":"2017-10-08T06:18:00.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/10/08/CentOS安装Node-js.html","link":"","permalink":"https://linweiyuan.github.io/2017/10/08/CentOS%E5%AE%89%E8%A3%85Node-js.html","excerpt":"","text":"选择要安装的版本, 联网执行脚本 Node.js v6 LTS 1curl --silent --location https://rpm.nodesource.com/setup_6.x | sudo bash - Node.js 8 1curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash - 安装 1sudo yum -y install nodejs","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://linweiyuan.github.io/tags/CentOS/"},{"name":"Node.js","slug":"Node-js","permalink":"https://linweiyuan.github.io/tags/Node-js/"}]},{"title":"CentOS安装Nginx","slug":"CentOS安装Nginx","date":"2017-10-08T06:17:39.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/10/08/CentOS安装Nginx.html","link":"","permalink":"https://linweiyuan.github.io/2017/10/08/CentOS%E5%AE%89%E8%A3%85Nginx.html","excerpt":"","text":"添加源, 新建/etc/yum.repos.d/nginx.repo 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 更新库 1sudo yum update 安装 1sudo yum -y install nginx","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://linweiyuan.github.io/tags/CentOS/"},{"name":"Nginx","slug":"Nginx","permalink":"https://linweiyuan.github.io/tags/Nginx/"}]},{"title":"Arch Linux查询滚动次数","slug":"Arch-Linux查询滚动次数","date":"2017-09-24T10:29:52.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/09/24/Arch-Linux查询滚动次数.html","link":"","permalink":"https://linweiyuan.github.io/2017/09/24/Arch-Linux%E6%9F%A5%E8%AF%A2%E6%BB%9A%E5%8A%A8%E6%AC%A1%E6%95%B0.html","excerpt":"","text":"1echo $(head -n1 /var/log/pacman.log | cut -d &quot; &quot; -f 1,2) 以来一共滚了 $(grep -c &quot;full system upgrade&quot; /var/log/pacman.log) 次","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"}]},{"title":"Linux终端环境下下载JDK","slug":"Linux终端环境下下载JDK","date":"2017-09-24T04:26:25.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2017/09/24/Linux终端环境下下载JDK.html","link":"","permalink":"https://linweiyuan.github.io/2017/09/24/Linux%E7%BB%88%E7%AB%AF%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%B8%8B%E8%BD%BDJDK.html","excerpt":"","text":"Accept License Agreement效果 1wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/9+181/jdk-9_linux-x64_bin.tar.gz","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://linweiyuan.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"},{"name":"JDK","slug":"JDK","permalink":"https://linweiyuan.github.io/tags/JDK/"}]},{"title":"Linux VPS性能测试","slug":"Linux-VPS性能测试","date":"2017-09-24T02:47:15.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2017/09/24/Linux-VPS性能测试.html","link":"","permalink":"https://linweiyuan.github.io/2017/09/24/Linux-VPS%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html","excerpt":"","text":"1wget -qO- bench.sh | bash","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"https://linweiyuan.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"}]},{"title":"Git设置Socks5代理","slug":"Git设置Socks5代理","date":"2017-09-07T13:52:48.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/09/07/Git设置Socks5代理.html","link":"","permalink":"https://linweiyuan.github.io/2017/09/07/Git%E8%AE%BE%E7%BD%AESocks5%E4%BB%A3%E7%90%86.html","excerpt":"","text":"12git config --global http.proxy &#x27;socks5://127.0.0.1:1080&#x27;git config --global https.proxy &#x27;socks5://127.0.0.1:1080&#x27;","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://linweiyuan.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://linweiyuan.github.io/tags/Git/"}]},{"title":"Android版本API内核相关","slug":"Android版本API内核相关","date":"2017-09-01T06:57:52.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/09/01/Android版本API内核相关.html","link":"","permalink":"https://linweiyuan.github.io/2017/09/01/Android%E7%89%88%E6%9C%ACAPI%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3.html","excerpt":"","text":"Android Version Code Name API Level Linux Kernel 1.0 ? 1 ? 1.1 ? 2 ? 1.5 Cupcake 3 2.6.27 1.6 Donut 4 2.6.29 2.0 Eclair 5 2.6.29 2.0.1 Eclair 6 2.6.29 2.1 Eclair 7 2.6.29 2.2 Fyoro 8 2.6.32 2.3 Gingerbread 9 2.6.35 2.3.3 Gingerbread 10 2.6.35 3.0 Honeycomb 11 2.6.36 3.1 Honeycomb 12 2.6.36 3.2 Honeycomb 13 2.6.36 4.0 Ice Cream Sandwich 14 3.0.1 4.0.3 Ice Cream Sandwich 15 3.0.1 4.1 Jelly Bean 16 3.0.31 4.2 Jelly Bean 17 3.4.0 4.3 Jelly Bean 18 3.4.39 4.4 KitKat 19 3.10 4.4W KitKat 20 3.10 5.0 Lollipop 21 3.16.1 5.1 Lollipop 22 3.16.1 6.0 Marshmallow 23 3.18.10 7.0 Nougat 24 4.4.1 7.1 Nougat 25 4.4.1 8.0 Oreo 26 4.10 8.1 Oreo 27 4.10 9 Pie 28 4.4.107、4.9.84、4.14.42","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://linweiyuan.github.io/tags/Android/"}]},{"title":"Android防止输入法弹出来导致标题栏被顶上去","slug":"Android防止输入法弹出来导致标题栏被顶上去","date":"2017-08-27T14:08:59.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/08/27/Android防止输入法弹出来导致标题栏被顶上去.html","link":"","permalink":"https://linweiyuan.github.io/2017/08/27/Android%E9%98%B2%E6%AD%A2%E8%BE%93%E5%85%A5%E6%B3%95%E5%BC%B9%E5%87%BA%E6%9D%A5%E5%AF%BC%E8%87%B4%E6%A0%87%E9%A2%98%E6%A0%8F%E8%A2%AB%E9%A1%B6%E4%B8%8A%E5%8E%BB.html","excerpt":"","text":"1android:windowSoftInputMode=&quot;adjustResize|stateHidden&quot;","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://linweiyuan.github.io/tags/Android/"}]},{"title":"AngularJS显示图片需要注意的地方","slug":"AngularJS显示图片需要注意的地方","date":"2017-08-24T06:32:43.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/08/24/AngularJS显示图片需要注意的地方.html","link":"","permalink":"https://linweiyuan.github.io/2017/08/24/AngularJS%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9.html","excerpt":"","text":"AngularJS显示图片的时候, 不要直接用src, 官方原话是这样的 1234Using AngularJS markup like &#123;&#123;hash&#125;&#125; in a src attribute doesn&#x27;t work right: Thebrowser will fetch from the URL with the literal text &#123;&#123;hash&#125;&#125; until AngularJSreplaces the expression inside &#123;&#123;hash&#125;&#125;. The ngSrc directive solves thisproblem. 如果直接用src的话, AngularJS在根据src显示图片之前会先请求一次src里面的纯字符串内容, 比如我写 1&lt;img src=&quot;&#123;&#123;pic.url&#125;&#125;&quot; /&gt; 刷新页面会发现一个奇怪的网络请求, 虽然图片还是能正常显示 1http://127.0.0.1:8080/%7B%7Bpic.url%7D%7D 其实就是 1http://127.0.0.1:8080/&#123;&#123;pic.url&#125;&#125; 而用 1&lt;img ng-src=&quot;&#123;&#123;pic.url&#125;&#125;&quot; /&gt; 则不会有这问题","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"https://linweiyuan.github.io/tags/AngularJS/"}]},{"title":"Git执行add操作时提示'warning: CRLF will be replaced by LF...'","slug":"Git执行add操作时提示-warning-CRLF-will-be-replaced-by-LF","date":"2017-08-22T14:26:35.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/08/22/Git执行add操作时提示-warning-CRLF-will-be-replaced-by-LF.html","link":"","permalink":"https://linweiyuan.github.io/2017/08/22/Git%E6%89%A7%E8%A1%8Cadd%E6%93%8D%E4%BD%9C%E6%97%B6%E6%8F%90%E7%A4%BA-warning-CRLF-will-be-replaced-by-LF.html","excerpt":"","text":"1git config --global core.autocrlf true","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://linweiyuan.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://linweiyuan.github.io/tags/Git/"}]},{"title":"Arch Linux开启BBR(重启不失效)","slug":"Arch-Linux开启BBR-重启不失效","date":"2017-08-22T07:10:20.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/08/22/Arch-Linux开启BBR-重启不失效.html","link":"","permalink":"https://linweiyuan.github.io/2017/08/22/Arch-Linux%E5%BC%80%E5%90%AFBBR-%E9%87%8D%E5%90%AF%E4%B8%8D%E5%A4%B1%E6%95%88.html","excerpt":"","text":"编辑配置文件/etc/sysctl.d/99-bbr.conf 12net.core.default_qdisc=fqnet.ipv4.tcp_congestion_control=bbr 重启 检查 1lsmod | grep tcp_bbr","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"}]},{"title":"AngularJS的ng-include要注意的地方","slug":"AngularJS的ng-include要注意的地方","date":"2017-08-16T07:38:44.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/08/16/AngularJS的ng-include要注意的地方.html","link":"","permalink":"https://linweiyuan.github.io/2017/08/16/AngularJS%E7%9A%84ng-include%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9.html","excerpt":"","text":"官方文档 -&gt; ngInclude, 明确写着一句话 12AngularJS expression evaluating to URL. If the source is a string constant, makesure you wrap it in single quotes, e.g. src=&quot;&#x27;myPartialTemplate.html&#x27;&quot;. 双引号里面的单引号不能少","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"https://linweiyuan.github.io/tags/AngularJS/"}]},{"title":"Nginx上传文件报错'413 Request Entity Too Large'","slug":"Nginx上传文件报错-413-Request-Entity-Too-Large","date":"2017-08-13T06:03:34.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2017/08/13/Nginx上传文件报错-413-Request-Entity-Too-Large.html","link":"","permalink":"https://linweiyuan.github.io/2017/08/13/Nginx%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99-413-Request-Entity-Too-Large.html","excerpt":"","text":"1error: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413 Request Entity Too Large 修改 nginx.conf 配置, 比如 100M 1client_max_body_size 100m; 重启 Nginx","categories":[{"name":"服务器","slug":"服务器","permalink":"https://linweiyuan.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://linweiyuan.github.io/tags/Nginx/"}]},{"title":"Redis配置密码认证","slug":"Redis配置密码认证","date":"2017-08-11T05:59:46.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2017/08/11/Redis配置密码认证.html","link":"","permalink":"https://linweiyuan.github.io/2017/08/11/Redis%E9%85%8D%E7%BD%AE%E5%AF%86%E7%A0%81%E8%AE%A4%E8%AF%81.html","excerpt":"","text":"Redis 默认连接是空密码, 如果要配置密码认证, 只需修改配置文件 1requirepass 密码 重启服务即可生效 此时, 如果单纯redis-cli登录, 会发现执行命令会提示需要认证 1234[root@archlinux ~]# redis-cli127.0.0.1:6379&gt; KEYS *(error) NOAUTH Authentication required.127.0.0.1:6379&gt; 截取help片段 12345[root@archlinux ~]# redis-cli --helpredis-cli 4.0.1Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]] -a &lt;password&gt; Password to use when connecting to the server. 加入-a参数后不再提示错误 1234[root@archlinux ~]# redis-cli -a ?127.0.0.1:6379&gt; KEYS *(empty list or set)127.0.0.1:6379&gt;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://linweiyuan.github.io/tags/Redis/"}]},{"title":"Redis配置远程连接","slug":"Redis配置远程连接","date":"2017-08-10T09:58:06.000Z","updated":"2023-05-20T01:12:21.096Z","comments":true,"path":"2017/08/10/Redis配置远程连接.html","link":"","permalink":"https://linweiyuan.github.io/2017/08/10/Redis%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.html","excerpt":"","text":"注释bind 1# bind 127.0.0.1 关掉保护模式 1protected-mode no 重启 Redis","categories":[{"name":"数据库","slug":"数据库","permalink":"https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://linweiyuan.github.io/tags/Redis/"}]},{"title":"Git批量修改提交者信息","slug":"Git批量修改提交者信息","date":"2017-08-09T22:14:20.000Z","updated":"2023-05-20T01:12:21.092Z","comments":true,"path":"2017/08/09/Git批量修改提交者信息.html","link":"","permalink":"https://linweiyuan.github.io/2017/08/09/Git%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%8F%90%E4%BA%A4%E8%80%85%E4%BF%A1%E6%81%AF.html","excerpt":"","text":"官方方法 -&gt; changing-author-info 克隆仓库bare 1git clone git仓库地址 --bare 更改提交者信息 -&gt; OLD_EMAIL,CORRECT_NAME,CORRECT_EMAIL 1234567891011121314151617#!/bin/shgit filter-branch --env-filter &#x27;OLD_EMAIL=&quot;your-old-email@example.com&quot;CORRECT_NAME=&quot;Your Correct Name&quot;CORRECT_EMAIL=&quot;your-correct-email@example.com&quot;if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot; export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;fiif [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot; export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;fi&#x27; --tag-name-filter cat -- --branches --tags 1git push --force --tags origin &#x27;refs/heads/*&#x27;","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://linweiyuan.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://linweiyuan.github.io/tags/Git/"}]}],"categories":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/categories/LMMS/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/categories/ChatGPT/"},{"name":"程序设计","slug":"程序设计","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"Unity","slug":"Unity","permalink":"https://linweiyuan.github.io/categories/Unity/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://linweiyuan.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"游戏","slug":"游戏","permalink":"https://linweiyuan.github.io/categories/%E6%B8%B8%E6%88%8F/"},{"name":"架构设计","slug":"架构设计","permalink":"https://linweiyuan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"},{"name":"Kotlin","slug":"程序设计/Kotlin","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Kotlin/"},{"name":"社区活动","slug":"社区活动","permalink":"https://linweiyuan.github.io/categories/%E7%A4%BE%E5%8C%BA%E6%B4%BB%E5%8A%A8/"},{"name":"操作系统","slug":"操作系统","permalink":"https://linweiyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"容器技术","slug":"容器技术","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"},{"name":"Kubernetes","slug":"容器技术/Kubernetes","permalink":"https://linweiyuan.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Kubernetes/"},{"name":"Github Actions","slug":"Github-Actions","permalink":"https://linweiyuan.github.io/categories/Github-Actions/"},{"name":"ELK","slug":"ELK","permalink":"https://linweiyuan.github.io/categories/ELK/"},{"name":"消息队列","slug":"消息队列","permalink":"https://linweiyuan.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"数据库","slug":"数据库","permalink":"https://linweiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JVM","slug":"JVM","permalink":"https://linweiyuan.github.io/categories/JVM/"},{"name":"网络安全","slug":"网络安全","permalink":"https://linweiyuan.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Java","slug":"程序设计/Java","permalink":"https://linweiyuan.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Java/"},{"name":"构建工具","slug":"构建工具","permalink":"https://linweiyuan.github.io/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"},{"name":"实用技巧","slug":"实用技巧","permalink":"https://linweiyuan.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"服务器","slug":"服务器","permalink":"https://linweiyuan.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"版本控制","slug":"版本控制","permalink":"https://linweiyuan.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"LMMS","slug":"LMMS","permalink":"https://linweiyuan.github.io/tags/LMMS/"},{"name":"千与千寻","slug":"千与千寻","permalink":"https://linweiyuan.github.io/tags/%E5%8D%83%E4%B8%8E%E5%8D%83%E5%AF%BB/"},{"name":"One Summer's Day","slug":"One-Summer-s-Day","permalink":"https://linweiyuan.github.io/tags/One-Summer-s-Day/"},{"name":"Always With Me","slug":"Always-With-Me","permalink":"https://linweiyuan.github.io/tags/Always-With-Me/"},{"name":"一百万个可能","slug":"一百万个可能","permalink":"https://linweiyuan.github.io/tags/%E4%B8%80%E7%99%BE%E4%B8%87%E4%B8%AA%E5%8F%AF%E8%83%BD/"},{"name":"孤勇者","slug":"孤勇者","permalink":"https://linweiyuan.github.io/tags/%E5%AD%A4%E5%8B%87%E8%80%85/"},{"name":"夜的钢琴曲","slug":"夜的钢琴曲","permalink":"https://linweiyuan.github.io/tags/%E5%A4%9C%E7%9A%84%E9%92%A2%E7%90%B4%E6%9B%B2/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://linweiyuan.github.io/tags/ChatGPT/"},{"name":"Cloudflare","slug":"Cloudflare","permalink":"https://linweiyuan.github.io/tags/Cloudflare/"},{"name":"WARP","slug":"WARP","permalink":"https://linweiyuan.github.io/tags/WARP/"},{"name":"Proxy","slug":"Proxy","permalink":"https://linweiyuan.github.io/tags/Proxy/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://linweiyuan.github.io/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"https://linweiyuan.github.io/tags/Promise/"},{"name":"Java","slug":"Java","permalink":"https://linweiyuan.github.io/tags/Java/"},{"name":"Selenium","slug":"Selenium","permalink":"https://linweiyuan.github.io/tags/Selenium/"},{"name":"Golang","slug":"Golang","permalink":"https://linweiyuan.github.io/tags/Golang/"},{"name":"TUI","slug":"TUI","permalink":"https://linweiyuan.github.io/tags/TUI/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://linweiyuan.github.io/tags/Kotlin/"},{"name":"Swing","slug":"Swing","permalink":"https://linweiyuan.github.io/tags/Swing/"},{"name":"jsoup","slug":"jsoup","permalink":"https://linweiyuan.github.io/tags/jsoup/"},{"name":"Python","slug":"Python","permalink":"https://linweiyuan.github.io/tags/Python/"},{"name":"Unity","slug":"Unity","permalink":"https://linweiyuan.github.io/tags/Unity/"},{"name":"原野追逐","slug":"原野追逐","permalink":"https://linweiyuan.github.io/tags/%E5%8E%9F%E9%87%8E%E8%BF%BD%E9%80%90/"},{"name":"Cornfield Chase","slug":"Cornfield-Chase","permalink":"https://linweiyuan.github.io/tags/Cornfield-Chase/"},{"name":"星际穿越","slug":"星际穿越","permalink":"https://linweiyuan.github.io/tags/%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A/"},{"name":"云宫迅音","slug":"云宫迅音","permalink":"https://linweiyuan.github.io/tags/%E4%BA%91%E5%AE%AB%E8%BF%85%E9%9F%B3/"},{"name":"一生所爱","slug":"一生所爱","permalink":"https://linweiyuan.github.io/tags/%E4%B8%80%E7%94%9F%E6%89%80%E7%88%B1/"},{"name":"神话","slug":"神话","permalink":"https://linweiyuan.github.io/tags/%E7%A5%9E%E8%AF%9D/"},{"name":"KVM","slug":"KVM","permalink":"https://linweiyuan.github.io/tags/KVM/"},{"name":"QEMU","slug":"QEMU","permalink":"https://linweiyuan.github.io/tags/QEMU/"},{"name":"Switch","slug":"Switch","permalink":"https://linweiyuan.github.io/tags/Switch/"},{"name":"yuzu","slug":"yuzu","permalink":"https://linweiyuan.github.io/tags/yuzu/"},{"name":"橄榄镇与希望的大地","slug":"橄榄镇与希望的大地","permalink":"https://linweiyuan.github.io/tags/%E6%A9%84%E6%A6%84%E9%95%87%E4%B8%8E%E5%B8%8C%E6%9C%9B%E7%9A%84%E5%A4%A7%E5%9C%B0/"},{"name":"Nvidia","slug":"Nvidia","permalink":"https://linweiyuan.github.io/tags/Nvidia/"},{"name":"VirtIO","slug":"VirtIO","permalink":"https://linweiyuan.github.io/tags/VirtIO/"},{"name":"分布式ID","slug":"分布式ID","permalink":"https://linweiyuan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8FID/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://linweiyuan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"name":"分布式事务","slug":"分布式事务","permalink":"https://linweiyuan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://linweiyuan.github.io/tags/Spring-Boot/"},{"name":"Spring Boot Starter","slug":"Spring-Boot-Starter","permalink":"https://linweiyuan.github.io/tags/Spring-Boot-Starter/"},{"name":"Go","slug":"Go","permalink":"https://linweiyuan.github.io/tags/Go/"},{"name":"React","slug":"React","permalink":"https://linweiyuan.github.io/tags/React/"},{"name":"sqlc","slug":"sqlc","permalink":"https://linweiyuan.github.io/tags/sqlc/"},{"name":"Postgres","slug":"Postgres","permalink":"https://linweiyuan.github.io/tags/Postgres/"},{"name":"Gin","slug":"Gin","permalink":"https://linweiyuan.github.io/tags/Gin/"},{"name":"Ant Design","slug":"Ant-Design","permalink":"https://linweiyuan.github.io/tags/Ant-Design/"},{"name":"我和我的祖国","slug":"我和我的祖国","permalink":"https://linweiyuan.github.io/tags/%E6%88%91%E5%92%8C%E6%88%91%E7%9A%84%E7%A5%96%E5%9B%BD/"},{"name":"IntelliJ IDEA Conf","slug":"IntelliJ-IDEA-Conf","permalink":"https://linweiyuan.github.io/tags/IntelliJ-IDEA-Conf/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://linweiyuan.github.io/tags/Kubernetes/"},{"name":"Pod","slug":"Pod","permalink":"https://linweiyuan.github.io/tags/Pod/"},{"name":"pgAdmin","slug":"pgAdmin","permalink":"https://linweiyuan.github.io/tags/pgAdmin/"},{"name":"Ingress","slug":"Ingress","permalink":"https://linweiyuan.github.io/tags/Ingress/"},{"name":"Github Actions","slug":"Github-Actions","permalink":"https://linweiyuan.github.io/tags/Github-Actions/"},{"name":"i3","slug":"i3","permalink":"https://linweiyuan.github.io/tags/i3/"},{"name":"i3bar","slug":"i3bar","permalink":"https://linweiyuan.github.io/tags/i3bar/"},{"name":"Docker","slug":"Docker","permalink":"https://linweiyuan.github.io/tags/Docker/"},{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://linweiyuan.github.io/tags/Arch-Linux/"},{"name":"Rancher","slug":"Rancher","permalink":"https://linweiyuan.github.io/tags/Rancher/"},{"name":"CentOS","slug":"CentOS","permalink":"https://linweiyuan.github.io/tags/CentOS/"},{"name":"CAP","slug":"CAP","permalink":"https://linweiyuan.github.io/tags/CAP/"},{"name":"BASE","slug":"BASE","permalink":"https://linweiyuan.github.io/tags/BASE/"},{"name":"Netty","slug":"Netty","permalink":"https://linweiyuan.github.io/tags/Netty/"},{"name":"NIO","slug":"NIO","permalink":"https://linweiyuan.github.io/tags/NIO/"},{"name":"JDK18","slug":"JDK18","permalink":"https://linweiyuan.github.io/tags/JDK18/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://linweiyuan.github.io/tags/Elasticsearch/"},{"name":"Logstash","slug":"Logstash","permalink":"https://linweiyuan.github.io/tags/Logstash/"},{"name":"Kibana","slug":"Kibana","permalink":"https://linweiyuan.github.io/tags/Kibana/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://linweiyuan.github.io/tags/RabbitMQ/"},{"name":"Redis","slug":"Redis","permalink":"https://linweiyuan.github.io/tags/Redis/"},{"name":"Thread","slug":"Thread","permalink":"https://linweiyuan.github.io/tags/Thread/"},{"name":"JVM","slug":"JVM","permalink":"https://linweiyuan.github.io/tags/JVM/"},{"name":"Spring","slug":"Spring","permalink":"https://linweiyuan.github.io/tags/Spring/"},{"name":"MySQL","slug":"MySQL","permalink":"https://linweiyuan.github.io/tags/MySQL/"},{"name":"MVCC","slug":"MVCC","permalink":"https://linweiyuan.github.io/tags/MVCC/"},{"name":"Session","slug":"Session","permalink":"https://linweiyuan.github.io/tags/Session/"},{"name":"Cookie","slug":"Cookie","permalink":"https://linweiyuan.github.io/tags/Cookie/"},{"name":"UUID","slug":"UUID","permalink":"https://linweiyuan.github.io/tags/UUID/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://linweiyuan.github.io/tags/MongoDB/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://linweiyuan.github.io/tags/ZooKeeper/"},{"name":"Snowflake","slug":"Snowflake","permalink":"https://linweiyuan.github.io/tags/Snowflake/"},{"name":"WeChatPay","slug":"WeChatPay","permalink":"https://linweiyuan.github.io/tags/WeChatPay/"},{"name":"CORS","slug":"CORS","permalink":"https://linweiyuan.github.io/tags/CORS/"},{"name":"Windows","slug":"Windows","permalink":"https://linweiyuan.github.io/tags/Windows/"},{"name":"Vulnerability","slug":"Vulnerability","permalink":"https://linweiyuan.github.io/tags/Vulnerability/"},{"name":"JSPX","slug":"JSPX","permalink":"https://linweiyuan.github.io/tags/JSPX/"},{"name":"Anko","slug":"Anko","permalink":"https://linweiyuan.github.io/tags/Anko/"},{"name":"XSS","slug":"XSS","permalink":"https://linweiyuan.github.io/tags/XSS/"},{"name":"pip","slug":"pip","permalink":"https://linweiyuan.github.io/tags/pip/"},{"name":"VirtualBox","slug":"VirtualBox","permalink":"https://linweiyuan.github.io/tags/VirtualBox/"},{"name":"Android","slug":"Android","permalink":"https://linweiyuan.github.io/tags/Android/"},{"name":"i3status","slug":"i3status","permalink":"https://linweiyuan.github.io/tags/i3status/"},{"name":"Linux","slug":"Linux","permalink":"https://linweiyuan.github.io/tags/Linux/"},{"name":"NTFS","slug":"NTFS","permalink":"https://linweiyuan.github.io/tags/NTFS/"},{"name":"Unauthorized","slug":"Unauthorized","permalink":"https://linweiyuan.github.io/tags/Unauthorized/"},{"name":"Javassist","slug":"Javassist","permalink":"https://linweiyuan.github.io/tags/Javassist/"},{"name":"Reflection","slug":"Reflection","permalink":"https://linweiyuan.github.io/tags/Reflection/"},{"name":"Maven","slug":"Maven","permalink":"https://linweiyuan.github.io/tags/Maven/"},{"name":"Nexus","slug":"Nexus","permalink":"https://linweiyuan.github.io/tags/Nexus/"},{"name":"ThreadPool","slug":"ThreadPool","permalink":"https://linweiyuan.github.io/tags/ThreadPool/"},{"name":"Flask","slug":"Flask","permalink":"https://linweiyuan.github.io/tags/Flask/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"https://linweiyuan.github.io/tags/Dockerfile/"},{"name":"openssl","slug":"openssl","permalink":"https://linweiyuan.github.io/tags/openssl/"},{"name":"Nginx","slug":"Nginx","permalink":"https://linweiyuan.github.io/tags/Nginx/"},{"name":"Server Send Event","slug":"Server-Send-Event","permalink":"https://linweiyuan.github.io/tags/Server-Send-Event/"},{"name":"Registry","slug":"Registry","permalink":"https://linweiyuan.github.io/tags/Registry/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://linweiyuan.github.io/tags/WebSocket/"},{"name":"Privoxy","slug":"Privoxy","permalink":"https://linweiyuan.github.io/tags/Privoxy/"},{"name":"ASPX","slug":"ASPX","permalink":"https://linweiyuan.github.io/tags/ASPX/"},{"name":"AVD","slug":"AVD","permalink":"https://linweiyuan.github.io/tags/AVD/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://linweiyuan.github.io/tags/FFmpeg/"},{"name":"youtube-dl","slug":"youtube-dl","permalink":"https://linweiyuan.github.io/tags/youtube-dl/"},{"name":"Nextcloud","slug":"Nextcloud","permalink":"https://linweiyuan.github.io/tags/Nextcloud/"},{"name":"JSP","slug":"JSP","permalink":"https://linweiyuan.github.io/tags/JSP/"},{"name":"CoreOS","slug":"CoreOS","permalink":"https://linweiyuan.github.io/tags/CoreOS/"},{"name":"cURL","slug":"cURL","permalink":"https://linweiyuan.github.io/tags/cURL/"},{"name":"Wget","slug":"Wget","permalink":"https://linweiyuan.github.io/tags/Wget/"},{"name":"Google Drive","slug":"Google-Drive","permalink":"https://linweiyuan.github.io/tags/Google-Drive/"},{"name":"IDEA","slug":"IDEA","permalink":"https://linweiyuan.github.io/tags/IDEA/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://linweiyuan.github.io/tags/Spring-Cloud/"},{"name":"Zuul","slug":"Zuul","permalink":"https://linweiyuan.github.io/tags/Zuul/"},{"name":"Docker Compose","slug":"Docker-Compose","permalink":"https://linweiyuan.github.io/tags/Docker-Compose/"},{"name":"Feign","slug":"Feign","permalink":"https://linweiyuan.github.io/tags/Feign/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://linweiyuan.github.io/tags/Hystrix/"},{"name":"deepin-wechat","slug":"deepin-wechat","permalink":"https://linweiyuan.github.io/tags/deepin-wechat/"},{"name":"Shell","slug":"Shell","permalink":"https://linweiyuan.github.io/tags/Shell/"},{"name":"Fcitx","slug":"Fcitx","permalink":"https://linweiyuan.github.io/tags/Fcitx/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://linweiyuan.github.io/tags/Jenkins/"},{"name":"war","slug":"war","permalink":"https://linweiyuan.github.io/tags/war/"},{"name":"GitLab","slug":"GitLab","permalink":"https://linweiyuan.github.io/tags/GitLab/"},{"name":"Socket","slug":"Socket","permalink":"https://linweiyuan.github.io/tags/Socket/"},{"name":"UDP","slug":"UDP","permalink":"https://linweiyuan.github.io/tags/UDP/"},{"name":"WebLogic","slug":"WebLogic","permalink":"https://linweiyuan.github.io/tags/WebLogic/"},{"name":"Ant","slug":"Ant","permalink":"https://linweiyuan.github.io/tags/Ant/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://linweiyuan.github.io/tags/Tomcat/"},{"name":"KDE","slug":"KDE","permalink":"https://linweiyuan.github.io/tags/KDE/"},{"name":"TigerVNC","slug":"TigerVNC","permalink":"https://linweiyuan.github.io/tags/TigerVNC/"},{"name":"Git","slug":"Git","permalink":"https://linweiyuan.github.io/tags/Git/"},{"name":"Manjaro","slug":"Manjaro","permalink":"https://linweiyuan.github.io/tags/Manjaro/"},{"name":"RTL8192EU","slug":"RTL8192EU","permalink":"https://linweiyuan.github.io/tags/RTL8192EU/"},{"name":"Oracle-XE","slug":"Oracle-XE","permalink":"https://linweiyuan.github.io/tags/Oracle-XE/"},{"name":"JEECG","slug":"JEECG","permalink":"https://linweiyuan.github.io/tags/JEECG/"},{"name":"Oracle","slug":"Oracle","permalink":"https://linweiyuan.github.io/tags/Oracle/"},{"name":"SQL","slug":"SQL","permalink":"https://linweiyuan.github.io/tags/SQL/"},{"name":"jQuery","slug":"jQuery","permalink":"https://linweiyuan.github.io/tags/jQuery/"},{"name":"Node.js","slug":"Node-js","permalink":"https://linweiyuan.github.io/tags/Node-js/"},{"name":"JDK","slug":"JDK","permalink":"https://linweiyuan.github.io/tags/JDK/"},{"name":"AngularJS","slug":"AngularJS","permalink":"https://linweiyuan.github.io/tags/AngularJS/"}]}